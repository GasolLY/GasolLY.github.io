<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Gasol</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
    <link rel="alternate" href="/atom.xml" title="Gasol" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Gasol</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['大胆挑战，世界总会让步', '陪伴，是最长情的告白', '从前的日子慢 车马邮件都慢 一生只够爱一个人'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-LevelDB源码分析——10.Compaction操作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%9410.Compaction%E6%93%8D%E4%BD%9C/"
    >LevelDB源码分析——10.Compaction操作</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%9410.Compaction%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2022-02-10T10:30:30.000Z" itemprop="datePublished">2022-02-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/LevelDB/">LevelDB</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="十-Compaction操作"><a href="#十-Compaction操作" class="headerlink" title="十.Compaction操作"></a>十.Compaction操作</h2><p>LevelDB 源码分析系列也步入尾声，本篇将分析 LevelDB 中至关重要的 Compaction 过程，依然从代码的角度出发。建议大家 了解 Compaction 的作用和过程。</p>
<h3 id="1-触发-Compaction"><a href="#1-触发-Compaction" class="headerlink" title="1. 触发 Compaction"></a>1. 触发 Compaction</h3><p>本系列第三篇中描述了内存数据库转为 Sorted Table 的过程，其中会执行 <code>DBImpl::BackgroundCompaction</code> 这一后台任务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">CompactMemTable</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">bool</span> is_manual = (manual_compaction_ != <span class="literal">nullptr</span>);</span><br><span class="line">  InternalKey manual_end;</span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = versions_-&gt;<span class="built_in">PickCompaction</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在假设 <code>imm_</code> 为空，并且不考虑手动 Compaction，那么这里会执行 <code>versions_-&gt;PickCompaction</code> 去选择一个 Compaction，其实现位于 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/db/version_set.cc"><code>db/version_set.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Compaction* <span class="title">VersionSet::PickCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line">  <span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会有两种需要 Compaction 的情况，一种是某一 Level 的分数超过了 1，一种是某一个文件的无效查询次数超过阈值。分数的计算位于版本更新之后的 <code>VersionSet::Finalize</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(config::kL0_CompactionTrigger);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = <span class="built_in">TotalFileSize</span>(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / <span class="built_in">MaxBytesForLevel</span>(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 0 层文件，当文件数量超过阈值（默认 4）时触发 Compaction；对于其他层的文件，当文件的总大小超过阈值时触发 Compaction。而一个文件的的查询次数阈值定义于 <code>VersionSet::Builder::Apply</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We arrange to automatically compact this file after</span></span><br><span class="line"><span class="comment">// a certain number of seeks.  Let&#x27;s assume:</span></span><br><span class="line"><span class="comment">//   (1) One seek costs 10ms</span></span><br><span class="line"><span class="comment">//   (2) Writing or reading 1MB costs 10ms (100MB/s)</span></span><br><span class="line"><span class="comment">//   (3) A compaction of 1MB does 25MB of IO:</span></span><br><span class="line"><span class="comment">//         1MB read from this level</span></span><br><span class="line"><span class="comment">//         10-12MB read from next level (boundaries may be misaligned)</span></span><br><span class="line"><span class="comment">//         10-12MB written to next level</span></span><br><span class="line"><span class="comment">// This implies that 25 seeks cost the same as the compaction</span></span><br><span class="line"><span class="comment">// of 1MB of data.  I.e., one seek costs approximately the</span></span><br><span class="line"><span class="comment">// same as the compaction of 40KB of data.  We are a little</span></span><br><span class="line"><span class="comment">// conservative and allow approximately one seek for every 16KB</span></span><br><span class="line"><span class="comment">// of data before triggering a compaction.</span></span><br><span class="line">f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>));</span><br><span class="line"><span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>英文注释写得十分详细。首先假设：</p>
<ol>
<li>一次查询耗时 10ms；</li>
<li>读/写 1MB 耗时 10ms （假设速度 100MB/s）；</li>
<li>1MB 的 Compaction 需要做 25 MB 的 IO<ol>
<li>本层读 1MB；</li>
<li>下一层读 10-12 MB</li>
<li>Compaction 后写 10-12 MB</li>
</ol>
</li>
</ol>
<p>整体来看，1MB 的数据做 25 次查询和 Compaction 的时间差不多，1 次查询就相当于做 40KB 数据的 Compaction。LevelDB 将其设为更保守的 16KB，进而一个文件的查询次数阈值设定为 <code>FileSize / 16KB</code>。当一次查询中读取了多个文件，则将第一个文件的查询次数 +1，直到其超过阈值、触发 Compaction。继续看 <code>VersionSet::PickCompaction</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Compaction* <span class="title">VersionSet::PickCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size_compaction) &#123;</span><br><span class="line">    level = current_-&gt;compaction_level_;</span><br><span class="line">    <span class="built_in">assert</span>(level &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(level + <span class="number">1</span> &lt; config::kNumLevels);</span><br><span class="line">    c = <span class="keyword">new</span> <span class="built_in">Compaction</span>(options_, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">      <span class="keyword">if</span> (compact_pointer_[level].<span class="built_in">empty</span>() ||</span><br><span class="line">          icmp_.<span class="built_in">Compare</span>(f-&gt;largest.<span class="built_in">Encode</span>(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">push_back</span>(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">push_back</span>(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction) &#123;</span><br><span class="line">    level = current_-&gt;file_to_compact_level_;</span><br><span class="line">    c = <span class="keyword">new</span> <span class="built_in">Compaction</span>(options_, level);</span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">push_back</span>(current_-&gt;file_to_compact_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c-&gt;input_version_ = current_;</span><br><span class="line">  c-&gt;input_version_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line">  <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">    <span class="built_in">GetRange</span>(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">    <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">    <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">    <span class="comment">// which will include the picked file.</span></span><br><span class="line">    current_-&gt;<span class="built_in">GetOverlappingInputs</span>(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">assert</span>(!c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">empty</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetupOtherInputs</span>(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于数据大小触发的 Compaction，会选取 <code>compact_pointer_</code> 后的第一个文件作为 Compaction 对象，即本层上一次 Compaction 区间之后的文件；而查询次数触发的 Compaction 其本身对应一个文件。对于 0 层文件，因为之间存在 Overlap，需要将存在重叠的文件都加入 Compaction 集合里。至此本层的文件选择完毕。</p>
<h3 id="2-扩大-Compaction-文件集合"><a href="#2-扩大-Compaction-文件集合" class="headerlink" title="2. 扩大 Compaction 文件集合"></a>2. 扩大 Compaction 文件集合</h3><p><code>VersionSet::PickCompaction</code> 随后执行 <code>SetupOtherInputs</code> 以扩大 Compaction 文件集合：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Finds the largest key in a vector of files. Returns true if files it not</span></span><br><span class="line"><span class="comment">// empty.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindLargestKey</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; files,</span></span></span><br><span class="line"><span class="params"><span class="function">                    InternalKey* largest_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (files.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *largest_key = files[<span class="number">0</span>]-&gt;largest;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; files.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    FileMetaData* f = files[i];</span><br><span class="line">    <span class="keyword">if</span> (icmp.<span class="built_in">Compare</span>(f-&gt;largest, *largest_key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      *largest_key = f-&gt;largest;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finds minimum file b2=(l2, u2) in level file for which l2 &gt; u1 and</span></span><br><span class="line"><span class="comment">// user_key(l2) = user_key(u1)</span></span><br><span class="line"><span class="function">FileMetaData* <span class="title">FindSmallestBoundaryFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; level_files,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> InternalKey&amp; largest_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* user_cmp = icmp.<span class="built_in">user_comparator</span>();</span><br><span class="line">  FileMetaData* smallest_boundary_file = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; level_files.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    FileMetaData* f = level_files[i];</span><br><span class="line">    <span class="keyword">if</span> (icmp.<span class="built_in">Compare</span>(f-&gt;smallest, largest_key) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        user_cmp-&gt;<span class="built_in">Compare</span>(f-&gt;smallest.<span class="built_in">user_key</span>(), largest_key.<span class="built_in">user_key</span>()) ==</span><br><span class="line">            <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (smallest_boundary_file == <span class="literal">nullptr</span> ||</span><br><span class="line">          icmp.<span class="built_in">Compare</span>(f-&gt;smallest, smallest_boundary_file-&gt;smallest) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        smallest_boundary_file = f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> smallest_boundary_file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extracts the largest file b1 from |compaction_files| and then searches for a</span></span><br><span class="line"><span class="comment">// b2 in |level_files| for which user_key(u1) = user_key(l2). If it finds such a</span></span><br><span class="line"><span class="comment">// file b2 (known as a boundary file) it adds it to |compaction_files| and then</span></span><br><span class="line"><span class="comment">// searches again using this new upper bound.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there are two blocks, b1=(l1, u1) and b2=(l2, u2) and</span></span><br><span class="line"><span class="comment">// user_key(u1) = user_key(l2), and if we compact b1 but not b2 then a</span></span><br><span class="line"><span class="comment">// subsequent get operation will yield an incorrect result because it will</span></span><br><span class="line"><span class="comment">// return the record from b2 in level i rather than from b1 because it searches</span></span><br><span class="line"><span class="comment">// level by level for records matching the supplied user key.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// parameters:</span></span><br><span class="line"><span class="comment">//   in     level_files:      List of files to search for boundary files.</span></span><br><span class="line"><span class="comment">//   in/out compaction_files: List of files to extend by adding boundary files.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBoundaryInputs</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; level_files,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::vector&lt;FileMetaData*&gt;* compaction_files)</span> </span>&#123;</span><br><span class="line">  InternalKey largest_key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Quick return if compaction_files is empty.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">FindLargestKey</span>(icmp, *compaction_files, &amp;largest_key)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> continue_searching = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (continue_searching) &#123;</span><br><span class="line">    FileMetaData* smallest_boundary_file =</span><br><span class="line">        <span class="built_in">FindSmallestBoundaryFile</span>(icmp, level_files, largest_key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a boundary file was found advance largest_key, otherwise we&#x27;re done.</span></span><br><span class="line">    <span class="keyword">if</span> (smallest_boundary_file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      compaction_files-&gt;<span class="built_in">push_back</span>(smallest_boundary_file);</span><br><span class="line">      largest_key = smallest_boundary_file-&gt;largest;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      continue_searching = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::SetupOtherInputs</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;<span class="built_in">level</span>();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AddBoundaryInputs</span>(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先执行的是 <code>AddBoundaryInputs</code>。其英文注释中解释地非常详细：当 Compaction 的范围为 [l1, u1][<em>l</em>1,<em>u</em>1] 时，该范围的数据将会被移动到 Level+1。如果当前 Level 存在文件 [l2, u2][<em>l</em>2,<em>u</em>2]，并且 <code>user_key(u1) = user_key(l2)</code>，那么下一次查询 <code>user_key(u1)</code> 时会在 Level 层提前返回旧的数据！故需要将受影响的文件全部加到 Compaction 文件范围中。继续看 <code>VersionSet::SetupOtherInputs</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::SetupOtherInputs</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">GetRange</span>(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"></span><br><span class="line">  current_-&gt;<span class="built_in">GetOverlappingInputs</span>(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">  InternalKey all_start, all_limit;</span><br><span class="line">  <span class="built_in">GetRange2</span>(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if we can grow the number of inputs in &quot;level&quot; without</span></span><br><span class="line">  <span class="comment">// changing the number of &quot;level+1&quot; files we pick up.</span></span><br><span class="line">  <span class="keyword">if</span> (!c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::vector&lt;FileMetaData*&gt; expanded0;</span><br><span class="line">    current_-&gt;<span class="built_in">GetOverlappingInputs</span>(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">    <span class="built_in">AddBoundaryInputs</span>(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = <span class="built_in">TotalFileSize</span>(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = <span class="built_in">TotalFileSize</span>(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = <span class="built_in">TotalFileSize</span>(expanded0);</span><br><span class="line">    <span class="keyword">if</span> (expanded0.<span class="built_in">size</span>() &gt; c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">        inputs1_size + expanded0_size &lt;</span><br><span class="line">            <span class="built_in">ExpandedCompactionByteSizeLimit</span>(options_)) &#123;</span><br><span class="line">      InternalKey new_start, new_limit;</span><br><span class="line">      <span class="built_in">GetRange</span>(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">      std::vector&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">      current_-&gt;<span class="built_in">GetOverlappingInputs</span>(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                     &amp;expanded1);</span><br><span class="line">      <span class="keyword">if</span> (expanded1.<span class="built_in">size</span>() == c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">Log</span>(options_-&gt;info_log,</span><br><span class="line">            <span class="string">&quot;Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n&quot;</span>,</span><br><span class="line">            level, <span class="built_in"><span class="keyword">int</span></span>(c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>()), <span class="built_in"><span class="keyword">int</span></span>(c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()),</span><br><span class="line">            <span class="built_in"><span class="keyword">long</span></span>(inputs0_size), <span class="built_in"><span class="keyword">long</span></span>(inputs1_size), <span class="built_in"><span class="keyword">int</span></span>(expanded0.<span class="built_in">size</span>()),</span><br><span class="line">            <span class="built_in"><span class="keyword">int</span></span>(expanded1.<span class="built_in">size</span>()), <span class="built_in"><span class="keyword">long</span></span>(expanded0_size), <span class="built_in"><span class="keyword">long</span></span>(inputs1_size));</span><br><span class="line">        smallest = new_start;</span><br><span class="line">        largest = new_limit;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">        c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">        <span class="built_in">GetRange2</span>(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the set of grandparent files that overlap this compaction</span></span><br><span class="line">  <span class="comment">// (parent == level+1; grandparent == level+2)</span></span><br><span class="line">  <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">    current_-&gt;<span class="built_in">GetOverlappingInputs</span>(level + <span class="number">2</span>, &amp;all_start, &amp;all_limit,</span><br><span class="line">                                   &amp;c-&gt;grandparents_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line">  <span class="comment">// We update this immediately instead of waiting for the VersionEdit</span></span><br><span class="line">  <span class="comment">// to be applied so that if the compaction fails, we will try a different</span></span><br><span class="line">  <span class="comment">// key range next time.</span></span><br><span class="line">  compact_pointer_[level] = largest.<span class="built_in">Encode</span>().<span class="built_in">ToString</span>();</span><br><span class="line">  c-&gt;edit_.<span class="built_in">SetCompactPointer</span>(level, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在 Level+1 层将所有存在重叠的文件加入 Compaction 文件集合里，更新 Compaction 的区间 <code>[all_start, all_limit]</code>。再回过头来使用新区间获得 Level 层重叠的文件 <code>expanded0</code>，如果新的数据大小在阈值以内且不会改变 Level+1 层选择的文件，那么则将 Level 层的文件集合更新为 <code>expanded0</code>。最后将当前 Level 的 <code>compact_pointer_</code> 设为当前 Compaction 的最大键。至此扩大 Compaction 文件集合结束，<code>VersionSet::PickCompaction</code> 也返回了 Compaction 对象。</p>
<h3 id="3-执行-Compaction"><a href="#3-执行-Compaction" class="headerlink" title="3. 执行 Compaction"></a>3. 执行 Compaction</h3><p>回到 <code>DBImpl::BackgroundCompaction</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DBImpl</span>:</span>:CompactionState &#123;</span><br><span class="line">  <span class="comment">// Files produced by compaction</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Output</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> number;</span><br><span class="line">    <span class="keyword">uint64_t</span> file_size;</span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">Output* <span class="title">current_output</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;outputs[outputs.<span class="built_in">size</span>() - <span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">CompactionState</span><span class="params">(Compaction* c)</span></span></span><br><span class="line"><span class="function">      : compaction(c),</span></span><br><span class="line"><span class="function">        smallest_snapshot(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        outfile(nullptr),</span></span><br><span class="line"><span class="function">        builder(nullptr),</span></span><br><span class="line"><span class="function">        total_bytes(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  Compaction* <span class="keyword">const</span> compaction;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sequence numbers &lt; smallest_snapshot are not significant since we</span></span><br><span class="line">  <span class="comment">// will never have to service a snapshot below smallest_snapshot.</span></span><br><span class="line">  <span class="comment">// Therefore if we have seen a sequence number S &lt;= smallest_snapshot,</span></span><br><span class="line">  <span class="comment">// we can drop all entries for the same key with sequence numbers &lt; S.</span></span><br><span class="line">  SequenceNumber smallest_snapshot;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Output&gt; outputs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// State kept for output being generated</span></span><br><span class="line">  WritableFile* outfile;</span><br><span class="line">  TableBuilder* builder;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> total_bytes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  Status status;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Nothing to do</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;<span class="built_in">IsTrivialMove</span>()) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    CompactionState* compact = <span class="keyword">new</span> <span class="built_in">CompactionState</span>(c);</span><br><span class="line">    status = <span class="built_in">DoCompactionWork</span>(compact);</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">RecordBackgroundError</span>(status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CleanupCompaction</span>(compact);</span><br><span class="line">    c-&gt;<span class="built_in">ReleaseInputs</span>();</span><br><span class="line">    <span class="built_in">DeleteObsoleteFiles</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Ignore compaction errors found during shutting down</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Compaction error: %s&quot;</span>, status.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不考虑手动模式和 TrivialMove，接下来会根据 <code>Compaction</code> 对象构建 <code>CompactionState</code>，并执行 <code>DBImpl::DoCompactionWork</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;<span class="built_in">NowMicros</span>();</span><br><span class="line">  <span class="keyword">int64_t</span> imm_micros = <span class="number">0</span>;  <span class="comment">// Micros spent doing imm_ compactions</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Compacting %d@%d + %d@%d files&quot;</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;<span class="built_in">num_input_files</span>(<span class="number">0</span>), compact-&gt;compaction-&gt;<span class="built_in">level</span>(),</span><br><span class="line">      compact-&gt;compaction-&gt;<span class="built_in">num_input_files</span>(<span class="number">1</span>),</span><br><span class="line">      compact-&gt;compaction-&gt;<span class="built_in">level</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(versions_-&gt;<span class="built_in">NumLevelFiles</span>(compact-&gt;compaction-&gt;<span class="built_in">level</span>()) &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">assert</span>(compact-&gt;builder == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(compact-&gt;outfile == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (snapshots_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = snapshots_.<span class="built_in">oldest</span>()-&gt;<span class="built_in">sequence_number</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Iterator* input = versions_-&gt;<span class="built_in">MakeInputIterator</span>(compact-&gt;compaction);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>compact-&gt;smallest_snapshot</code> 是为了让当前的 Snapshot 的数据在 Compaction 过程中不丢失。<code>versions_-&gt;MakeInputIterator</code> 返回 Compaction 文件集合的合并迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator* <span class="title">VersionSet::MakeInputIterator</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  ReadOptions options;</span><br><span class="line">  options.verify_checksums = options_-&gt;paranoid_checks;</span><br><span class="line">  options.fill_cache = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level-0 files have to be merged together.  For other levels,</span></span><br><span class="line">  <span class="comment">// we will make a concatenating iterator per level.</span></span><br><span class="line">  <span class="comment">// TODO(opt): use concatenating iterator for level-0 if there is no overlap</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> space = (c-&gt;<span class="built_in">level</span>() == <span class="number">0</span> ? c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() + <span class="number">1</span> : <span class="number">2</span>);</span><br><span class="line">  Iterator** list = <span class="keyword">new</span> Iterator*[space];</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!c-&gt;inputs_[which].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c-&gt;<span class="built_in">level</span>() + which == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; files = c-&gt;inputs_[which];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          list[num++] = table_cache_-&gt;<span class="built_in">NewIterator</span>(options, files[i]-&gt;number,</span><br><span class="line">                                                  files[i]-&gt;file_size);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Create concatenating iterator for the files from this level</span></span><br><span class="line">        list[num++] = <span class="built_in">NewTwoLevelIterator</span>(</span><br><span class="line">            <span class="keyword">new</span> Version::<span class="built_in">LevelFileNumIterator</span>(icmp_, &amp;c-&gt;inputs_[which]),</span><br><span class="line">            &amp;GetFileIterator, table_cache_, options);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(num &lt;= space);</span><br><span class="line">  Iterator* result = <span class="built_in">NewMergingIterator</span>(&amp;icmp_, list, num);</span><br><span class="line">  <span class="keyword">delete</span>[] list;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看 <code>DBImpl::DoCompactionWork</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Release mutex while we&#x27;re actually doing the compaction work</span></span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  input-&gt;<span class="built_in">SeekToFirst</span>();</span><br><span class="line">  Status status;</span><br><span class="line">  ParsedInternalKey ikey;</span><br><span class="line">  std::string current_user_key;</span><br><span class="line">  <span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">  SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">  <span class="keyword">while</span> (input-&gt;<span class="built_in">Valid</span>() &amp;&amp; !shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Prioritize immutable compaction work</span></span><br><span class="line">    <span class="keyword">if</span> (has_imm_.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;<span class="built_in">NowMicros</span>();</span><br><span class="line">      mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">CompactMemTable</span>();</span><br><span class="line">        <span class="comment">// Wake up MakeRoomForWrite() if necessary.</span></span><br><span class="line">        background_work_finished_signal_.<span class="built_in">SignalAll</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">      imm_micros += (env_-&gt;<span class="built_in">NowMicros</span>() - imm_start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Slice key = input-&gt;<span class="built_in">key</span>();</span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;compaction-&gt;<span class="built_in">ShouldStopBefore</span>(key) &amp;&amp;</span><br><span class="line">        compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      status = <span class="built_in">FinishCompactionOutputFile</span>(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle key/value, add to state, etc.</span></span><br><span class="line">    <span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ParseInternalKey</span>(key, &amp;ikey)) &#123;</span><br><span class="line">      <span class="comment">// Do not hide error keys</span></span><br><span class="line">      current_user_key.<span class="built_in">clear</span>();</span><br><span class="line">      has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">      last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!has_current_user_key ||</span><br><span class="line">          <span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Compare</span>(ikey.user_key, <span class="built_in">Slice</span>(current_user_key)) !=</span><br><span class="line">              <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// First occurrence of this user key</span></span><br><span class="line">        current_user_key.<span class="built_in">assign</span>(ikey.user_key.<span class="built_in">data</span>(), ikey.user_key.<span class="built_in">size</span>());</span><br><span class="line">        has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">        last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;</span><br><span class="line">        <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">        drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line">                 ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">                 compact-&gt;compaction-&gt;<span class="built_in">IsBaseLevelForKey</span>(ikey.user_key)) &#123;</span><br><span class="line">        <span class="comment">// For this user key:</span></span><br><span class="line">        <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">        <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">        <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">        <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">        <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">        <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">        drop = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last_sequence_for_key = ikey.sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">      <span class="comment">// Open output file if necessary</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        status = <span class="built_in">OpenCompactionOutputFile</span>(compact);</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;<span class="built_in">NumEntries</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        compact-&gt;<span class="built_in">current_output</span>()-&gt;smallest.<span class="built_in">DecodeFrom</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">      compact-&gt;<span class="built_in">current_output</span>()-&gt;largest.<span class="built_in">DecodeFrom</span>(key);</span><br><span class="line">      compact-&gt;builder-&gt;<span class="built_in">Add</span>(key, input-&gt;<span class="built_in">value</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Close output file if it is big enough</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;<span class="built_in">FileSize</span>() &gt;=</span><br><span class="line">          compact-&gt;compaction-&gt;<span class="built_in">MaxOutputFileSize</span>()) &#123;</span><br><span class="line">        status = <span class="built_in">FinishCompactionOutputFile</span>(compact, input);</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input-&gt;<span class="built_in">Next</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>一个巨大的循环。首先判断是否已经 <code>shutting_down_</code>，如果已经关闭了，则终止当前的 Compaction 过程；随后判断当前是否有 <code>imm_</code>，如果存在的话则也先执行 <code>CompactMemTable</code>；再来判断当前输出的文件是否可以结束了，如果是的话就执行 <code>FinishCompactionOutputFile</code> 完成当前文件。</p>
<p>接下来是是否丢弃键值对的判定。如果某个 <code>user_key</code> 的非最新版本小于快照版本，则可以直接丢弃，因为读最新的版本就足够了；如果某个删除操作的版本小于快照版本，并且在更高层没有相同的 <code>user_key</code>，那么这个删除操作及其之前更早的插入操作可以同时丢弃了。</p>
<p>对于没有丢弃的键值对，将其写入当前的 Table Builder。当输出的大小超过阈值，同样执行 <code>FinishCompactionOutputFile</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::OpenCompactionOutputFile</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(compact != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(compact-&gt;builder == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> file_number;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">    file_number = versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">    pending_outputs_.<span class="built_in">insert</span>(file_number);</span><br><span class="line">    CompactionState::Output out;</span><br><span class="line">    out.number = file_number;</span><br><span class="line">    out.smallest.<span class="built_in">Clear</span>();</span><br><span class="line">    out.largest.<span class="built_in">Clear</span>();</span><br><span class="line">    compact-&gt;outputs.<span class="built_in">push_back</span>(out);</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the output file</span></span><br><span class="line">  std::string fname = <span class="built_in">TableFileName</span>(dbname_, file_number);</span><br><span class="line">  Status s = env_-&gt;<span class="built_in">NewWritableFile</span>(fname, &amp;compact-&gt;outfile);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    compact-&gt;builder = <span class="keyword">new</span> <span class="built_in">TableBuilder</span>(options_, compact-&gt;outfile);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::FinishCompactionOutputFile</span><span class="params">(CompactionState* compact,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Iterator* input)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(compact != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(compact-&gt;outfile != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(compact-&gt;builder != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> output_number = compact-&gt;<span class="built_in">current_output</span>()-&gt;number;</span><br><span class="line">  <span class="built_in">assert</span>(output_number != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for iterator errors</span></span><br><span class="line">  Status s = input-&gt;<span class="built_in">status</span>();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> current_entries = compact-&gt;builder-&gt;<span class="built_in">NumEntries</span>();</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = compact-&gt;builder-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compact-&gt;builder-&gt;<span class="built_in">Abandon</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> current_bytes = compact-&gt;builder-&gt;<span class="built_in">FileSize</span>();</span><br><span class="line">  compact-&gt;<span class="built_in">current_output</span>()-&gt;file_size = current_bytes;</span><br><span class="line">  compact-&gt;total_bytes += current_bytes;</span><br><span class="line">  <span class="keyword">delete</span> compact-&gt;builder;</span><br><span class="line">  compact-&gt;builder = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finish and check for file errors</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = compact-&gt;outfile-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = compact-&gt;outfile-&gt;<span class="built_in">Close</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> compact-&gt;outfile;</span><br><span class="line">  compact-&gt;outfile = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; current_entries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Verify that the table is usable</span></span><br><span class="line">    Iterator* iter =</span><br><span class="line">        table_cache_-&gt;<span class="built_in">NewIterator</span>(<span class="built_in">ReadOptions</span>(), output_number, current_bytes);</span><br><span class="line">    s = iter-&gt;<span class="built_in">status</span>();</span><br><span class="line">    <span class="keyword">delete</span> iter;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Generated table #%llu@%d: %lld keys, %lld bytes&quot;</span>,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)output_number, compact-&gt;compaction-&gt;<span class="built_in">level</span>(),</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)current_entries,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)current_bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续来看 <code>DBImpl::DoCompactionWork</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::InstallCompactionResults</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Compacted %d@%d + %d@%d files =&gt; %lld bytes&quot;</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;<span class="built_in">num_input_files</span>(<span class="number">0</span>), compact-&gt;compaction-&gt;<span class="built_in">level</span>(),</span><br><span class="line">      compact-&gt;compaction-&gt;<span class="built_in">num_input_files</span>(<span class="number">1</span>), compact-&gt;compaction-&gt;<span class="built_in">level</span>() + <span class="number">1</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(compact-&gt;total_bytes));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add compaction outputs</span></span><br><span class="line">  compact-&gt;compaction-&gt;<span class="built_in">AddInputDeletions</span>(compact-&gt;compaction-&gt;<span class="built_in">edit</span>());</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = compact-&gt;compaction-&gt;<span class="built_in">level</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> CompactionState::Output&amp; out = compact-&gt;outputs[i];</span><br><span class="line">    compact-&gt;compaction-&gt;<span class="built_in">edit</span>()-&gt;<span class="built_in">AddFile</span>(level + <span class="number">1</span>, out.number, out.file_size,</span><br><span class="line">                                         out.smallest, out.largest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> versions_-&gt;<span class="built_in">LogAndApply</span>(compact-&gt;compaction-&gt;<span class="built_in">edit</span>(), &amp;mutex_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    status = Status::<span class="built_in">IOError</span>(<span class="string">&quot;Deleting DB during compaction&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    status = <span class="built_in">FinishCompactionOutputFile</span>(compact, input);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    status = input-&gt;<span class="built_in">status</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> input;</span><br><span class="line">  input = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.micros = env_-&gt;<span class="built_in">NowMicros</span>() - start_micros - imm_micros;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compact-&gt;compaction-&gt;<span class="built_in">num_input_files</span>(which); i++) &#123;</span><br><span class="line">      stats.bytes_read += compact-&gt;compaction-&gt;<span class="built_in">input</span>(which, i)-&gt;file_size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    stats.bytes_written += compact-&gt;outputs[i].file_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  stats_[compact-&gt;compaction-&gt;<span class="built_in">level</span>() + <span class="number">1</span>].<span class="built_in">Add</span>(stats);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    status = <span class="built_in">InstallCompactionResults</span>(compact);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">RecordBackgroundError</span>(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;compacted to: %s&quot;</span>, versions_-&gt;<span class="built_in">LevelSummary</span>(&amp;tmp));</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>InstallCompactionResults</code> 时将 Compaction 的文件集合加入到 <code>VersionEdit</code> 的删除列表中，并将新生成的文件加入到新文件列表里，随后执行 <code>versions_-&gt;LogAndApply</code> 更新版本。最后再执行一些清理操作，Compaction 过程就结束了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LevelDB/" rel="tag">LevelDB</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-LevelDB源码分析——9.读写完整流程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%949.%E8%AF%BB%E5%86%99%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/"
    >LevelDB源码分析——9.读写完整流程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%949.%E8%AF%BB%E5%86%99%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/" class="article-date">
  <time datetime="2022-02-10T08:30:30.000Z" itemprop="datePublished">2022-02-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/LevelDB/">LevelDB</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="九-读写完整流程"><a href="#九-读写完整流程" class="headerlink" title="九.读写完整流程"></a>九.读写完整流程</h2><p>本系列之前的数篇博文从面向对象的角度分析了 LevelDB 中的核心组件，理解了每个类的作用。本篇将从面向过程的角度，分析 LevelDB 创建、打开和读写的完整流程。</p>
<h3 id="1-新建数据库并写入"><a href="#1-新建数据库并写入" class="headerlink" title="1. 新建数据库并写入"></a>1. 新建数据库并写入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  leveldb::DB* db;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    leveldb::Options options;</span><br><span class="line">    options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">    options.compression = leveldb::kNoCompression;</span><br><span class="line">    leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;testdb&quot;</span>, &amp;db);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    leveldb::WriteOptions options;</span><br><span class="line">    leveldb::Status status = db-&gt;<span class="built_in">Put</span>(options, <span class="string">&quot;[Key]&quot;</span>, <span class="string">&quot;[Value]&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保当前路径下没有 <code>testdb</code> 目录，然后执行上方的代码。可以在写入前加入 <code>getchar()</code> 中断以观察中间的状态，测试得到的中间状态如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ ls -l</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r--  1 pxf  staff     0B Sep  7 10:02 000003.log</span><br><span class="line">-rw-r--r--  1 pxf  staff    16B Sep  7 10:02 CURRENT</span><br><span class="line">-rw-r--r--  1 pxf  staff     0B Sep  7 10:02 LOCK</span><br><span class="line">-rw-r--r--  1 pxf  staff    56B Sep  7 10:02 LOG</span><br><span class="line">-rw-r--r--  1 pxf  staff    50B Sep  7 10:02 MANIFEST-000002</span><br></pre></td></tr></table></figure>

<p>待写入完成后，文件 <code>000003.log</code> 的大小变为 34，其余大小不变。</p>
<p>接下来沿着代码一步一步分析，这里推荐使用 VS Code 查看函数实现。首先来看 <code>leveldb::DB::Open</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DB::Open</span><span class="params">(<span class="keyword">const</span> Options&amp; options, <span class="keyword">const</span> std::string&amp; dbname, DB** dbptr)</span> </span>&#123;</span><br><span class="line">  *dbptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  DBImpl* impl = <span class="keyword">new</span> <span class="built_in">DBImpl</span>(options, dbname);</span><br><span class="line">  impl-&gt;mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  <span class="comment">// Recover handles create_if_missing, error_if_exists</span></span><br><span class="line">  <span class="keyword">bool</span> save_manifest = <span class="literal">false</span>;</span><br><span class="line">  Status s = impl-&gt;<span class="built_in">Recover</span>(&amp;edit, &amp;save_manifest);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; impl-&gt;mem_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Create new log and a corresponding memtable.</span></span><br><span class="line">    <span class="keyword">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">    WritableFile* lfile;</span><br><span class="line">    s = options.env-&gt;<span class="built_in">NewWritableFile</span>(<span class="built_in">LogFileName</span>(dbname, new_log_number),</span><br><span class="line">                                     &amp;lfile);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      edit.<span class="built_in">SetLogNumber</span>(new_log_number);</span><br><span class="line">      impl-&gt;logfile_ = lfile;</span><br><span class="line">      impl-&gt;logfile_number_ = new_log_number;</span><br><span class="line">      impl-&gt;log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(lfile);</span><br><span class="line">      impl-&gt;mem_ = <span class="keyword">new</span> <span class="built_in">MemTable</span>(impl-&gt;internal_comparator_);</span><br><span class="line">      impl-&gt;mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; save_manifest) &#123;</span><br><span class="line">    edit.<span class="built_in">SetPrevLogNumber</span>(<span class="number">0</span>);  <span class="comment">// No older logs needed after recovery.</span></span><br><span class="line">    edit.<span class="built_in">SetLogNumber</span>(impl-&gt;logfile_number_);</span><br><span class="line">    s = impl-&gt;versions_-&gt;<span class="built_in">LogAndApply</span>(&amp;edit, &amp;impl-&gt;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    impl-&gt;<span class="built_in">DeleteObsoleteFiles</span>();</span><br><span class="line">    impl-&gt;<span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  impl-&gt;mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(impl-&gt;mem_ != <span class="literal">nullptr</span>);</span><br><span class="line">    *dbptr = impl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> impl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先给输出参数 <code>*dbptr</code> 赋空指针，然后 new 一个 <code>DBImpl</code> 对象。<code>DBImpl</code> 的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DBImpl::<span class="built_in">DBImpl</span>(<span class="keyword">const</span> Options&amp; raw_options, <span class="keyword">const</span> std::string&amp; dbname)</span><br><span class="line">    : <span class="built_in">env_</span>(raw_options.env),</span><br><span class="line">      <span class="built_in">internal_comparator_</span>(raw_options.comparator),</span><br><span class="line">      <span class="built_in">internal_filter_policy_</span>(raw_options.filter_policy),</span><br><span class="line">      <span class="built_in">options_</span>(<span class="built_in">SanitizeOptions</span>(dbname, &amp;internal_comparator_,</span><br><span class="line">                               &amp;internal_filter_policy_, raw_options)),</span><br><span class="line">      <span class="built_in">owns_info_log_</span>(options_.info_log != raw_options.info_log),</span><br><span class="line">      <span class="built_in">owns_cache_</span>(options_.block_cache != raw_options.block_cache),</span><br><span class="line">      <span class="built_in">dbname_</span>(dbname),</span><br><span class="line">      <span class="built_in">table_cache_</span>(<span class="keyword">new</span> <span class="built_in">TableCache</span>(dbname_, options_, <span class="built_in">TableCacheSize</span>(options_))),</span><br><span class="line">      <span class="built_in">db_lock_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">shutting_down_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">background_work_finished_signal_</span>(&amp;mutex_),</span><br><span class="line">      <span class="built_in">mem_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">imm_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">has_imm_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">logfile_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">logfile_number_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">log_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">seed_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">tmp_batch_</span>(<span class="keyword">new</span> WriteBatch),</span><br><span class="line">      <span class="built_in">background_compaction_scheduled_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">manual_compaction_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">versions_</span>(<span class="keyword">new</span> <span class="built_in">VersionSet</span>(dbname_, &amp;options_, table_cache_,</span><br><span class="line">                               &amp;internal_comparator_)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>都是成员变量的初始化，大部分成员置为 0。值得关注的 <code>SanitizeOptions</code> 实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ClipToRange</span><span class="params">(T* ptr, V minvalue, V maxvalue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;V&gt;(*ptr) &gt; maxvalue) *ptr = maxvalue;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;V&gt;(*ptr) &lt; minvalue) *ptr = minvalue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Options <span class="title">SanitizeOptions</span><span class="params">(<span class="keyword">const</span> std::string&amp; dbname,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> InternalKeyComparator* icmp,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> InternalFilterPolicy* ipolicy,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> Options&amp; src)</span> </span>&#123;</span><br><span class="line">  Options result = src;</span><br><span class="line">  result.comparator = icmp;</span><br><span class="line">  result.filter_policy = (src.filter_policy != <span class="literal">nullptr</span>) ? ipolicy : <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">ClipToRange</span>(&amp;result.max_open_files, <span class="number">64</span> + kNumNonTableCacheFiles, <span class="number">50000</span>);</span><br><span class="line">  <span class="built_in">ClipToRange</span>(&amp;result.write_buffer_size, <span class="number">64</span> &lt;&lt; <span class="number">10</span>, <span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">ClipToRange</span>(&amp;result.max_file_size, <span class="number">1</span> &lt;&lt; <span class="number">20</span>, <span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">ClipToRange</span>(&amp;result.block_size, <span class="number">1</span> &lt;&lt; <span class="number">10</span>, <span class="number">4</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">if</span> (result.info_log == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Open a log file in the same directory as the db</span></span><br><span class="line">    src.env-&gt;<span class="built_in">CreateDir</span>(dbname);  <span class="comment">// In case it does not exist</span></span><br><span class="line">    src.env-&gt;<span class="built_in">RenameFile</span>(<span class="built_in">InfoLogFileName</span>(dbname), <span class="built_in">OldInfoLogFileName</span>(dbname));</span><br><span class="line">    Status s = src.env-&gt;<span class="built_in">NewLogger</span>(<span class="built_in">InfoLogFileName</span>(dbname), &amp;result.info_log);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="comment">// No place suitable for logging</span></span><br><span class="line">      result.info_log = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result.block_cache == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    result.block_cache = <span class="built_in">NewLRUCache</span>(<span class="number">8</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SanitizeOptions</code> 函数将原 <code>src</code> 中的属性进行了安全裁剪，并且创建了 <code>dbname</code> 目录、将原 Info Log 文件重命名并创建了新的 Info Log 文件，也就是 <code>testdb/LOG</code> 文件。最后按需创建了 block cache 并返回作为 <code>DBImpl</code> 的 <code>options_</code>。 <code>DBImpl</code> 的构造函数还为 <code>table_cache_</code>、<code>tmp_batch_</code> 和 <code>version_</code> 创建了新对象。</p>
<p>回到 <code>leveldb::DB::Open</code>，创建 <code>DBImpl</code> 后上锁并执行 <code>impl-&gt;Recover</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Recover</span><span class="params">(VersionEdit* edit, <span class="keyword">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ignore error from CreateDir since the creation of the DB is</span></span><br><span class="line">  <span class="comment">// committed only when the descriptor is created, and this directory</span></span><br><span class="line">  <span class="comment">// may already exist from a previous failed creation attempt.</span></span><br><span class="line">  env_-&gt;<span class="built_in">CreateDir</span>(dbname_);</span><br><span class="line">  <span class="built_in">assert</span>(db_lock_ == <span class="literal">nullptr</span>);</span><br><span class="line">  Status s = env_-&gt;<span class="built_in">LockFile</span>(<span class="built_in">LockFileName</span>(dbname_), &amp;db_lock_);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!env_-&gt;<span class="built_in">FileExists</span>(<span class="built_in">CurrentFileName</span>(dbname_))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options_.create_if_missing) &#123;</span><br><span class="line">      s = <span class="built_in">NewDB</span>();</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">InvalidArgument</span>(</span><br><span class="line">          dbname_, <span class="string">&quot;does not exist (create_if_missing is false)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (options_.error_if_exists) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">InvalidArgument</span>(dbname_,</span><br><span class="line">                                     <span class="string">&quot;exists (error_if_exists is true)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  s = versions_-&gt;<span class="built_in">Recover</span>(save_manifest);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试创建 dbname 目录且忽略错误，启用文件锁 <code>testdb/LOCK</code> 以阻止其他进程操作当前数据库。由于当前没有 CURRENT 文件，并且我们开启了 <code>options.create_if_missing</code>，这里会继续调用 <code>NewDB</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::NewDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  VersionEdit new_db;</span><br><span class="line">  new_db.<span class="built_in">SetComparatorName</span>(<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Name</span>());</span><br><span class="line">  new_db.<span class="built_in">SetLogNumber</span>(<span class="number">0</span>);</span><br><span class="line">  new_db.<span class="built_in">SetNextFile</span>(<span class="number">2</span>);</span><br><span class="line">  new_db.<span class="built_in">SetLastSequence</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> std::string manifest = <span class="built_in">DescriptorFileName</span>(dbname_, <span class="number">1</span>);</span><br><span class="line">  WritableFile* file;</span><br><span class="line">  Status s = env_-&gt;<span class="built_in">NewWritableFile</span>(manifest, &amp;file);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">log::Writer <span class="title">log</span><span class="params">(file)</span></span>;</span><br><span class="line">    std::string record;</span><br><span class="line">    new_db.<span class="built_in">EncodeTo</span>(&amp;record);</span><br><span class="line">    s = log.<span class="built_in">AddRecord</span>(record);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = file-&gt;<span class="built_in">Close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> file;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Make &quot;CURRENT&quot; file that points to the new manifest file.</span></span><br><span class="line">    s = <span class="built_in">SetCurrentFile</span>(env_, dbname_, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    env_-&gt;<span class="built_in">DeleteFile</span>(manifest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NewDB</code> 中创建了一个新的 <code>VersionEdit</code> 对象，将日志编号设为 0，MANIFEST 编号设为 1，NextFile 编号自然是 2 了。而后将 <code>VersionEdit</code> 对象转为日志 Record 写入 MANIFEST 文件中，并将 CURRENT 指向该 MANIFEST。</p>
<p>ちょっと待って（桥豆麻袋），先前观察到的 MANIFEST 文件名为 MANIFEST-000002，和这里分析的编号为 1 并不相符，应该是中间发生了什么。回到 <code>DBImpl::Recover</code> 继续看，接下来将会执行 <code>versions_-&gt;Recover</code>，该函数在上一篇文章中有贴出源码，可以翻回去看一下这里不贴了。简述其过程：根据 CURRENT 文件，读取指向的 MANIFEST 文件中的 VersionEdit 记录，并合成 Version。贴一部分与编号相关的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Version* v = <span class="keyword">new</span> <span class="built_in">Version</span>(<span class="keyword">this</span>);</span><br><span class="line">builder.<span class="built_in">SaveTo</span>(v);</span><br><span class="line"><span class="comment">// Install recovered version</span></span><br><span class="line"><span class="built_in">Finalize</span>(v);</span><br><span class="line"><span class="built_in">AppendVersion</span>(v);</span><br><span class="line">manifest_file_number_ = next_file;</span><br><span class="line">next_file_number_ = next_file + <span class="number">1</span>;</span><br><span class="line">last_sequence_ = last_sequence;</span><br><span class="line">log_number_ = log_number;</span><br><span class="line">prev_log_number_ = prev_log_number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See if we can reuse the existing MANIFEST file.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ReuseManifest</span>(dscname, current)) &#123;</span><br><span class="line">  <span class="comment">// No need to save new manifest</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  *save_manifest = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里将 <code>manifest_file_number_</code> 设为了 <code>next_file</code>，也就是 2。<code>Options::reuse_logs</code> 默认为关闭状态，故这里会将 <code>save_manifest</code> 设为 <code>true</code>，所以后面保存 MANIFEST 时编号就是 2 了。</p>
<p>回到 <code>DBImpl::Recover</code>，当 <code>versions_-&gt;Recover</code> 执行完成后，会读取当前存在的日志文件。而新数据库并没有日志，中间过程就跳过、直接返回了，进而回到 <code>leveldb::DB::Open</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; impl-&gt;mem_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// Create new log and a corresponding memtable.</span></span><br><span class="line">  <span class="keyword">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">  WritableFile* lfile;</span><br><span class="line">  s = options.env-&gt;<span class="built_in">NewWritableFile</span>(<span class="built_in">LogFileName</span>(dbname, new_log_number),</span><br><span class="line">                                   &amp;lfile);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    edit.<span class="built_in">SetLogNumber</span>(new_log_number);</span><br><span class="line">    impl-&gt;logfile_ = lfile;</span><br><span class="line">    impl-&gt;logfile_number_ = new_log_number;</span><br><span class="line">    impl-&gt;log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(lfile);</span><br><span class="line">    impl-&gt;mem_ = <span class="keyword">new</span> <span class="built_in">MemTable</span>(impl-&gt;internal_comparator_);</span><br><span class="line">    impl-&gt;mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; save_manifest) &#123;</span><br><span class="line">  edit.<span class="built_in">SetPrevLogNumber</span>(<span class="number">0</span>);  <span class="comment">// No older logs needed after recovery.</span></span><br><span class="line">  edit.<span class="built_in">SetLogNumber</span>(impl-&gt;logfile_number_);</span><br><span class="line">  s = impl-&gt;versions_-&gt;<span class="built_in">LogAndApply</span>(&amp;edit, &amp;impl-&gt;mutex_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>impl-&gt;mem_</code> 依然保持为空，故申请新的日志编号 3，创建日志文件和对应的内存数据库，也就是 <code>testdb/000003.log</code>。<code>save_manifest</code> 为真，则调用 <code>version_-&gt;LogAndApply</code> 将当前版本 <code>edit</code> 写入文件，也就是最终看到的 <code>testdb/MANIFEST-000002</code>。这里硬核一点，直接看下 MANIFEST 文件的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ hexdump MANIFEST-000002</span><br><span class="line">0000000 56 f9 b8 f8 1c 00 01 01 1a 6c 65 76 65 6c 64 62</span><br><span class="line">0000010 2e 42 79 74 65 77 69 73 65 43 6f 6d 70 61 72 61</span><br><span class="line">0000020 74 6f 72 a4 9c 8b be 08 00 01 02 03 09 00 03 04</span><br><span class="line">0000030 04 00</span><br></pre></td></tr></table></figure>

<p><code>version_-&gt;LogAndApply</code> 创建 MANIFEST 文件后，会先执行 <code>VersionSet::WriteSnapshot</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::WriteSnapshot</span><span class="params">(log::Writer* log)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Break up into multiple records to reduce memory usage on recovery?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save metadata</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  edit.<span class="built_in">SetComparatorName</span>(icmp_.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Name</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!compact_pointer_[level].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      InternalKey key;</span><br><span class="line">      key.<span class="built_in">DecodeFrom</span>(compact_pointer_[level]);</span><br><span class="line">      edit.<span class="built_in">SetCompactPointer</span>(level, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; files = current_-&gt;files_[level];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> FileMetaData* f = files[i];</span><br><span class="line">      edit.<span class="built_in">AddFile</span>(level, f-&gt;number, f-&gt;file_size, f-&gt;smallest, f-&gt;largest);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string record;</span><br><span class="line">  edit.<span class="built_in">EncodeTo</span>(&amp;record);</span><br><span class="line">  <span class="keyword">return</span> log-&gt;<span class="built_in">AddRecord</span>(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先会将比较器的名字作为 Record 写入 MANIFEST 文件中。根据本系列第三篇博文中分析的日志记录方式，每一条 Record 会有 7 字节的 Header，其中前 4 字节为 CRC 校验值可以不理会，5、6 字节为记录的长度，这里是 <code>0x1c = 28</code>，最后是 Record 类型，这里的类型是 <code>kFullType = 1</code>。而后的 28 字节便是记录了比较器名字的 <code>edit</code> 对象，其内容需要根据编码的方式进行解码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tag numbers for serialized VersionEdit.  These numbers are written to</span></span><br><span class="line"><span class="comment">// disk and should not be changed.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Tag</span> &#123;</span></span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionEdit::EncodeTo</span><span class="params">(std::string* dst)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (has_comparator_) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kComparator);</span><br><span class="line">    <span class="built_in">PutLengthPrefixedSlice</span>(dst, comparator_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_log_number_) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kLogNumber);</span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_prev_log_number_) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kPrevLogNumber);</span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_next_file_number_) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kNextFileNumber);</span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, next_file_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_last_sequence_) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kLastSequence);</span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, last_sequence_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kCompactPointer);</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, compact_pointers_[i].first);  <span class="comment">// level</span></span><br><span class="line">    <span class="built_in">PutLengthPrefixedSlice</span>(dst, compact_pointers_[i].second.<span class="built_in">Encode</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_kvp : deleted_files_) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kDeletedFile);</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, deleted_file_kvp.first);   <span class="comment">// level</span></span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, deleted_file_kvp.second);  <span class="comment">// file number</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> FileMetaData&amp; f = new_files_[i].second;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kNewFile);</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, new_files_[i].first);  <span class="comment">// level</span></span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, f.number);</span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, f.file_size);</span><br><span class="line">    <span class="built_in">PutLengthPrefixedSlice</span>(dst, f.smallest.<span class="built_in">Encode</span>());</span><br><span class="line">    <span class="built_in">PutLengthPrefixedSlice</span>(dst, f.largest.<span class="built_in">Encode</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">01</span> <span class="number">1</span>a <span class="number">6</span>c <span class="number">65</span> <span class="number">76</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">64</span> <span class="number">62</span> <span class="number">2</span>e <span class="number">42</span> <span class="number">79</span> <span class="number">74</span> <span class="number">65</span> <span class="number">77</span> <span class="number">69</span> <span class="number">73</span> <span class="number">65</span> <span class="number">43</span> <span class="number">6f</span> <span class="number">6</span>d <span class="number">70</span> <span class="number">61</span> <span class="number">72</span> <span class="number">61</span> <span class="number">74</span> <span class="number">6f</span> <span class="number">72</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>kComparator=1</code>，而后是比较器的长度 <code>0x1a=26</code> 和名字对应的 ASCII 码，<a target="_blank" rel="noopener" href="http://www.unit-conversion.info/texttools/hexadecimal/">翻译过来</a>就是 <code>leveldb.BytewiseComparator</code>。之后的第二条记录便是 <code>leveldb::DB:OpenDB</code> 中的 <code>edit</code> 对象的 Record 记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a4 9c 8b be 08 00 01 02 03 09 00 03 04 04 00</span><br></pre></td></tr></table></figure>

<p>一样的 7 字节 Header，Record 长度为 8，具体内容为：</p>
<ol>
<li><code>kLogNumber=02</code>，对应的日志编号为 3；</li>
<li><code>kPrevLogNumber=09</code>，对应的上一个日志编号为 0；</li>
<li><code>kNextFileNumber=03</code>，对应的下一个文件编号为 4；</li>
<li><code>kLastSequence=04</code>，对应的最新序列号为 0。</li>
</ol>
<p>最后回到 <code>leveldb::DB::OpenDB</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">  impl-&gt;<span class="built_in">DeleteObsoleteFiles</span>();</span><br><span class="line">  impl-&gt;<span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建或恢复成功后，执行 <code>DBImpl::DeleteObsoleteFiles</code> 删除废弃文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::DeleteObsoleteFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// After a background error, we don&#x27;t know whether a new version may</span></span><br><span class="line">    <span class="comment">// or may not have been committed, so we cannot safely garbage collect.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a set of all of the live files</span></span><br><span class="line">  std::set&lt;<span class="keyword">uint64_t</span>&gt; live = pending_outputs_;</span><br><span class="line">  versions_-&gt;<span class="built_in">AddLiveFiles</span>(&amp;live);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; filenames;</span><br><span class="line">  env_-&gt;<span class="built_in">GetChildren</span>(dbname_, &amp;filenames);  <span class="comment">// Ignoring errors on purpose</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  FileType type;</span><br><span class="line">  std::vector&lt;std::string&gt; files_to_delete;</span><br><span class="line">  <span class="keyword">for</span> (std::string&amp; filename : filenames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ParseFileName</span>(filename, &amp;number, &amp;type)) &#123;</span><br><span class="line">      <span class="keyword">bool</span> keep = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> kLogFile:</span><br><span class="line">          keep = ((number &gt;= versions_-&gt;<span class="built_in">LogNumber</span>()) ||</span><br><span class="line">                  (number == versions_-&gt;<span class="built_in">PrevLogNumber</span>()));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kDescriptorFile:</span><br><span class="line">          <span class="comment">// Keep my manifest file, and any newer incarnations&#x27;</span></span><br><span class="line">          <span class="comment">// (in case there is a race that allows other incarnations)</span></span><br><span class="line">          keep = (number &gt;= versions_-&gt;<span class="built_in">ManifestFileNumber</span>());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTableFile:</span><br><span class="line">          keep = (live.<span class="built_in">find</span>(number) != live.<span class="built_in">end</span>());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTempFile:</span><br><span class="line">          <span class="comment">// Any temp files that are currently being written to must</span></span><br><span class="line">          <span class="comment">// be recorded in pending_outputs_, which is inserted into &quot;live&quot;</span></span><br><span class="line">          keep = (live.<span class="built_in">find</span>(number) != live.<span class="built_in">end</span>());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCurrentFile:</span><br><span class="line">        <span class="keyword">case</span> kDBLockFile:</span><br><span class="line">        <span class="keyword">case</span> kInfoLogFile:</span><br><span class="line">          keep = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        files_to_delete.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(filename));</span><br><span class="line">        <span class="keyword">if</span> (type == kTableFile) &#123;</span><br><span class="line">          table_cache_-&gt;<span class="built_in">Evict</span>(number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Delete type=%d #%lld\n&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(type),</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// While deleting all files unblock other threads. All files being deleted</span></span><br><span class="line">  <span class="comment">// have unique names which will not collide with newly created files and</span></span><br><span class="line">  <span class="comment">// are therefore safe to delete while allowing other threads to proceed.</span></span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> std::string&amp; filename : files_to_delete) &#123;</span><br><span class="line">    env_-&gt;<span class="built_in">DeleteFile</span>(dbname_ + <span class="string">&quot;/&quot;</span> + filename);</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的废弃文件也包括创建不久的 <code>testdb/MANIFEST-000001</code>。至此 <code>leveldb::DB::Open</code> 函数分析完毕。</p>
<p>而后执行的写入操作 <code>db-&gt;Put</code>，会将数据写入日志文件和内存数据库。此时使用的日志文件编号为 3，也就是 <code>testdb/000003.db</code>，其写入后的内容为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ hexdump 000003.log</span><br><span class="line">0000000 aa a0 87 24 1b 00 01 01 00 00 00 00 00 00 00 01</span><br><span class="line">0000010 00 00 00 01 05 5b 4b 65 79 5d 07 5b 56 61 6c 75</span><br><span class="line">0000020 65 5d</span><br></pre></td></tr></table></figure>

<p>一样的 7 字节 Header，Record 长度为 <code>0x1b=27</code>，内容为 <code>WriteBatch</code> 编码结果。参考本系列第三篇博文，内容的前 8 字节为序列号，这里是 1；其后的 4 字节为键值对数量，这里也是 1；再后面就是附带长度编码的键值对，分别是 <code>[Key]</code> 和 <code>[Value]</code>。最后代码结束，删除了 <code>db</code> 对象，也就得到了前文叙述的文件状态。</p>
<h3 id="2-打开数据库并读取"><a href="#2-打开数据库并读取" class="headerlink" title="2. 打开数据库并读取"></a>2. 打开数据库并读取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  leveldb::DB* db;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    leveldb::Options options;</span><br><span class="line">    options.compression = leveldb::kNoCompression;</span><br><span class="line">    leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;testdb&quot;</span>, &amp;db);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    std::string key = <span class="string">&quot;[Key]&quot;</span>;</span><br><span class="line">    std::string value;</span><br><span class="line">    leveldb::ReadOptions read_options;</span><br><span class="line">    leveldb::Status status = db-&gt;<span class="built_in">Get</span>(read_options, key, &amp;value);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上一节创建的数据库的基础上，执行上方的代码。首先打开数据库，再读取 Key 对应的 Value。最终的数据库文件状态为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">❯ ls -l</span><br><span class="line">total 40</span><br><span class="line">-rw-r--r--  1 pxf  staff   124B Sep  7 09:57 000005.ldb</span><br><span class="line">-rw-r--r--  1 pxf  staff     0B Sep  7 09:57 000006.log</span><br><span class="line">-rw-r--r--  1 pxf  staff    16B Sep  7 09:57 CURRENT</span><br><span class="line">-rw-r--r--  1 pxf  staff     0B Sep  7 09:57 LOCK</span><br><span class="line">-rw-r--r--  1 pxf  staff   304B Sep  7 09:57 LOG</span><br><span class="line">-rw-r--r--  1 pxf  staff    56B Sep  7 09:57 LOG.old</span><br><span class="line">-rw-r--r--  1 pxf  staff    82B Sep  7 09:57 MANIFEST-000004</span><br></pre></td></tr></table></figure>

<p>和之前一样，沿着代码分析打开数据库的流程。<code>DB::Open</code> 前期的步骤一致，直接跳到 <code>impl-&gt;Recover</code>。由于存在 CURRENT 文件，所以就跳过了 <code>NewDB</code> 的步骤。随后依然是 <code>versions_-&gt;Recover</code>，读取 CURRENT 文件、继而读取 MANIFEST。如上一节中所分析的，LogNumber 为 3，NextFileNumber 为 4，故最后新建的 MANIFEST 文件编号为 4。随后回到 <code>impl-&gt;Recover</code> 执行恢复日志文件数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Recover</span><span class="params">(VersionEdit* edit, <span class="keyword">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">SequenceNumber <span class="title">max_sequence</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recover from all newer log files than the ones named in the</span></span><br><span class="line">  <span class="comment">// descriptor (new log files may have been added by the previous</span></span><br><span class="line">  <span class="comment">// incarnation without registering them in the descriptor).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Note that PrevLogNumber() is no longer used, but we pay</span></span><br><span class="line">  <span class="comment">// attention to it in case we are recovering a database</span></span><br><span class="line">  <span class="comment">// produced by an older version of leveldb.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> min_log = versions_-&gt;<span class="built_in">LogNumber</span>();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> prev_log = versions_-&gt;<span class="built_in">PrevLogNumber</span>();</span><br><span class="line">  std::vector&lt;std::string&gt; filenames;</span><br><span class="line">  s = env_-&gt;<span class="built_in">GetChildren</span>(dbname_, &amp;filenames);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  std::set&lt;<span class="keyword">uint64_t</span>&gt; expected;</span><br><span class="line">  versions_-&gt;<span class="built_in">AddLiveFiles</span>(&amp;expected);</span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  FileType type;</span><br><span class="line">  std::vector&lt;<span class="keyword">uint64_t</span>&gt; logs;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filenames.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ParseFileName</span>(filenames[i], &amp;number, &amp;type)) &#123;</span><br><span class="line">      expected.<span class="built_in">erase</span>(number);</span><br><span class="line">      <span class="keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))</span><br><span class="line">        logs.<span class="built_in">push_back</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!expected.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf), <span class="string">&quot;%d missing files; e.g.&quot;</span>,</span><br><span class="line">             <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(expected.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(buf, <span class="built_in">TableFileName</span>(dbname_, *(expected.<span class="built_in">begin</span>())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recover in the order in which the logs were generated</span></span><br><span class="line">  std::<span class="built_in">sort</span>(logs.<span class="built_in">begin</span>(), logs.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; logs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    s = <span class="built_in">RecoverLogFile</span>(logs[i], (i == logs.<span class="built_in">size</span>() - <span class="number">1</span>), save_manifest, edit,</span><br><span class="line">                       &amp;max_sequence);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The previous incarnation may not have written any MANIFEST</span></span><br><span class="line">    <span class="comment">// records after allocating this log number.  So we manually</span></span><br><span class="line">    <span class="comment">// update the file number allocation counter in VersionSet.</span></span><br><span class="line">    versions_-&gt;<span class="built_in">MarkFileNumberUsed</span>(logs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (versions_-&gt;<span class="built_in">LastSequence</span>() &lt; max_sequence) &#123;</span><br><span class="line">    versions_-&gt;<span class="built_in">SetLastSequence</span>(max_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索数据库目录下的、符合条件的日志文件，然后执行 <code>DBImpl::RecoverLogFile</code> 进行恢复：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::RecoverLogFile</span><span class="params">(<span class="keyword">uint64_t</span> log_number, <span class="keyword">bool</span> last_log,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">bool</span>* save_manifest, VersionEdit* edit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              SequenceNumber* max_sequence)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LogReporter</span> :</span> <span class="keyword">public</span> log::Reader::Reporter &#123;</span><br><span class="line">    Env* env;</span><br><span class="line">    Logger* info_log;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* fname;</span><br><span class="line">    Status* status;  <span class="comment">// null if options_.paranoid_checks==false</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">const</span> Status&amp; s)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="built_in">Log</span>(info_log, <span class="string">&quot;%s%s: dropping %d bytes; %s&quot;</span>,</span><br><span class="line">          (<span class="keyword">this</span>-&gt;status == <span class="literal">nullptr</span> ? <span class="string">&quot;(ignoring error) &quot;</span> : <span class="string">&quot;&quot;</span>), fname,</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(bytes), s.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;status != <span class="literal">nullptr</span> &amp;&amp; <span class="keyword">this</span>-&gt;status-&gt;<span class="built_in">ok</span>()) *<span class="keyword">this</span>-&gt;status = s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the log file</span></span><br><span class="line">  std::string fname = <span class="built_in">LogFileName</span>(dbname_, log_number);</span><br><span class="line">  SequentialFile* file;</span><br><span class="line">  Status status = env_-&gt;<span class="built_in">NewSequentialFile</span>(fname, &amp;file);</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">MaybeIgnoreError</span>(&amp;status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the log reader.</span></span><br><span class="line">  LogReporter reporter;</span><br><span class="line">  reporter.env = env_;</span><br><span class="line">  reporter.info_log = options_.info_log;</span><br><span class="line">  reporter.fname = fname.<span class="built_in">c_str</span>();</span><br><span class="line">  reporter.status = (options_.paranoid_checks ? &amp;status : <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// We intentionally make log::Reader do checksumming even if</span></span><br><span class="line">  <span class="comment">// paranoid_checks==false so that corruptions cause entire commits</span></span><br><span class="line">  <span class="comment">// to be skipped instead of propagating bad information (like overly</span></span><br><span class="line">  <span class="comment">// large sequence numbers).</span></span><br><span class="line">  <span class="function">log::Reader <span class="title">reader</span><span class="params">(file, &amp;reporter, <span class="literal">true</span> <span class="comment">/*checksum*/</span>, <span class="number">0</span> <span class="comment">/*initial_offset*/</span>)</span></span>;</span><br><span class="line">  <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Recovering log #%llu&quot;</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)log_number);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read all the records and add to a memtable</span></span><br><span class="line">  std::string scratch;</span><br><span class="line">  Slice record;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  <span class="keyword">int</span> compactions = <span class="number">0</span>;</span><br><span class="line">  MemTable* mem = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (reader.<span class="built_in">ReadRecord</span>(&amp;record, &amp;scratch) &amp;&amp; status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (record.<span class="built_in">size</span>() &lt; <span class="number">12</span>) &#123;</span><br><span class="line">      reporter.<span class="built_in">Corruption</span>(record.<span class="built_in">size</span>(),</span><br><span class="line">                          Status::<span class="built_in">Corruption</span>(<span class="string">&quot;log record too small&quot;</span>));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WriteBatchInternal::<span class="built_in">SetContents</span>(&amp;batch, record);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      mem = <span class="keyword">new</span> <span class="built_in">MemTable</span>(internal_comparator_);</span><br><span class="line">      mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    status = WriteBatchInternal::<span class="built_in">InsertInto</span>(&amp;batch, mem);</span><br><span class="line">    <span class="built_in">MaybeIgnoreError</span>(&amp;status);</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> SequenceNumber last_seq = WriteBatchInternal::<span class="built_in">Sequence</span>(&amp;batch) +</span><br><span class="line">                                    WriteBatchInternal::<span class="built_in">Count</span>(&amp;batch) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (last_seq &gt; *max_sequence) &#123;</span><br><span class="line">      *max_sequence = last_seq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;<span class="built_in">ApproximateMemoryUsage</span>() &gt; options_.write_buffer_size) &#123;</span><br><span class="line">      compactions++;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">      status = <span class="built_in">WriteLevel0Table</span>(mem, edit, <span class="literal">nullptr</span>);</span><br><span class="line">      mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">      mem = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="comment">// Reflect errors immediately so that conditions like full</span></span><br><span class="line">        <span class="comment">// file-systems cause the DB::Open() to fail.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> file;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if we should keep reusing the last log file.</span></span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; options_.reuse_logs &amp;&amp; last_log &amp;&amp; compactions == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(logfile_ == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">assert</span>(log_ == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">assert</span>(mem_ == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> lfile_size;</span><br><span class="line">    <span class="keyword">if</span> (env_-&gt;<span class="built_in">GetFileSize</span>(fname, &amp;lfile_size).<span class="built_in">ok</span>() &amp;&amp;</span><br><span class="line">        env_-&gt;<span class="built_in">NewAppendableFile</span>(fname, &amp;logfile_).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Reusing old log %s \n&quot;</span>, fname.<span class="built_in">c_str</span>());</span><br><span class="line">      log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(logfile_, lfile_size);</span><br><span class="line">      logfile_number_ = log_number;</span><br><span class="line">      <span class="keyword">if</span> (mem != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        mem_ = mem;</span><br><span class="line">        mem = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mem can be nullptr if lognum exists but was empty.</span></span><br><span class="line">        mem_ = <span class="keyword">new</span> <span class="built_in">MemTable</span>(internal_comparator_);</span><br><span class="line">        mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// mem did not get reused; compact it.</span></span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">      status = <span class="built_in">WriteLevel0Table</span>(mem, edit, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DBImpl::RecoverLogFile</code> 将日志文件中的数据读取到内存数据库中，同时更新序列号，最后将内存数据库中的数据写入 Level0 的 Sorted Table 里，也就是最终状态里的 <code>testdb/000005.ldb</code>。执行完成后回到 <code>DBImpl::Recover</code>，再回到 <code>DB::Open</code> 里。再后面就与上一节中的行为一致了。</p>
<p>最后来看下 MANIFEST 的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ hexdump MANIFEST-000004</span><br><span class="line">0000000 56 f9 b8 f8 1c 00 01 01 1a 6c 65 76 65 6c 64 62</span><br><span class="line">0000010 2e 42 79 74 65 77 69 73 65 43 6f 6d 70 61 72 61</span><br><span class="line">0000020 74 6f 72 9e bc a9 67 28 00 01 02 06 09 00 03 07</span><br><span class="line">0000030 04 01 07 00 05 7c 0d 5b 4b 65 79 5d 01 01 00 00</span><br><span class="line">0000040 00 00 00 00 0d 5b 4b 65 79 5d 01 01 00 00 00 00</span><br><span class="line">0000050 00 00</span><br></pre></td></tr></table></figure>

<p>前面的一段比较器名和上一节中的一致，直接来看第二条记录，也就是第 0x23 个字节开始看。4 字节 CRC，忽略；记录长度为 <code>0x28=40</code>，后面依旧是 <code>VersionEdit</code> 的编码结果：</p>
<ol>
<li><code>kLogNumber=02</code>，对应的日志编号为 6；</li>
<li><code>kPrevLogNumber=09</code>，对应的上一个日志编号为 0；</li>
<li><code>kNextFileNumber=03</code>，对应的下一个文件编号为 7；</li>
<li><code>kLastSequence=04</code>，对应的最新序列号为 1；</li>
<li><code>kNewFile=07</code>，对应新增文件，其 Level 为 0，编号为 5，文件大小 <code>0x7c=124</code>，最小键和最大键都是长度为 <code>0x0d = 13</code> 的 <code>5b 4b 65 79 5d 01 01 00 00 00 00 00 00</code>，格式为 Internal Key。Internal Key 后面的 8 个字节为综合序列号，对应 <code>kTypeValue=1</code>，序列号为 1。</li>
</ol>
<p>至此数据库打开的流程分析完毕。接下来看 <code>leveldb::DB::Get</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::string* value)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  <span class="keyword">if</span> (options.snapshot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    snapshot =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;<span class="built_in">sequence_number</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    snapshot = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* mem = mem_;</span><br><span class="line">  MemTable* imm = imm_;</span><br><span class="line">  Version* current = versions_-&gt;<span class="built_in">current</span>();</span><br><span class="line">  mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  current-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">  Version::GetStats stats;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">    <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = current-&gt;<span class="built_in">Get</span>(options, lkey, value, &amp;stats);</span><br><span class="line">      have_stat_update = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;<span class="built_in">UpdateStats</span>(stats)) &#123;</span><br><span class="line">    <span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  current-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DBImpl::Get</code> 首先会尝试从内存数据中读取数据，如果找不到则会使用 <code>Version::Get</code> 读取，其过程参见上一篇博文。至此读取的流程也分析完毕。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>LevelDB 每次打开数据库时都会创建新的 MANIFEST 文件（默认情况下 <code>Options::reuse_logs=false</code>）；</li>
<li>存储在日志中的键值对，会在下一次打开数据库时转为 <code>.ldb</code> 文件。</li>
</ol>
<p>。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LevelDB/" rel="tag">LevelDB</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-LevelDB源码分析——8.版本管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%948.%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"
    >LevelDB源码分析——8.版本管理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%948.%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2022-02-10T07:30:30.000Z" itemprop="datePublished">2022-02-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/LevelDB/">LevelDB</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="八-版本管理"><a href="#八-版本管理" class="headerlink" title="八.版本管理"></a>八.版本管理</h2><p>本系列的上一篇介绍了 Sorted Table 的构建和读取过程。当 Sorted Table 不断构建出来时，需要使用适当的方式来组织、管理生成的 <code>.ldb</code> 文件。并且 LevelDB 支持快照，这需要 LevelDB 具有版本管理能力。本篇将分析 LevelDB 版本管理相关的代码。</p>
<h3 id="1-版本概述"><a href="#1-版本概述" class="headerlink" title="1. 版本概述"></a>1. 版本概述</h3><p>LevelDB 中的版本管理是针对 Sorted Table 文件的变化的。当有新的内存数据库转为 Sorted Table，或者发生 Compaction 导致有 Sorted Table 增删，都会触发版本的更新。版本管理可以类比 git：</p>
<ol>
<li>初始的时候是一个空的 repo（没有 Sorted Table 文件）；</li>
<li>当有文件增删时，会在之前的版本上做增量的 commit 记录（VersionEdit）；</li>
<li>根据之前的版本和 commit 记录，可以推断出现在的版本（Version）；</li>
<li>根据初始状态和所有 commit 记录可以推断出所有版本（VersionSet）；</li>
<li>使用 HEAD 指向当前使用的版本（CURRENT 文件）。</li>
</ol>
<h3 id="2-版本-Version"><a href="#2-版本-Version" class="headerlink" title="2. 版本 Version"></a>2. 版本 Version</h3><p>首先来看没有未知依赖的 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/db/version_edit.h"><code>db/version_edit.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></span><br><span class="line">  <span class="built_in">FileMetaData</span>() : <span class="built_in">refs</span>(<span class="number">0</span>), <span class="built_in">allowed_seeks</span>(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), <span class="built_in">file_size</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;  <span class="comment">// Seeks allowed until compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;    <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// Largest internal key served by table</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>FileMetaData</code> 记录了 <code>.ldb</code> 文件的元信息，包括允许查找的次数、文件编号 <code>number</code> 和大小 <code>file_size</code> 以及最小和最大的 Key。接下来是 <code>VersionEdit</code> 的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionEdit</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VersionEdit</span>() &#123; <span class="built_in">Clear</span>(); &#125;</span><br><span class="line">  ~<span class="built_in">VersionEdit</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetComparatorName</span><span class="params">(<span class="keyword">const</span> Slice&amp; name)</span> </span>&#123;</span><br><span class="line">    has_comparator_ = <span class="literal">true</span>;</span><br><span class="line">    comparator_ = name.<span class="built_in">ToString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetLogNumber</span><span class="params">(<span class="keyword">uint64_t</span> num)</span> </span>&#123;</span><br><span class="line">    has_log_number_ = <span class="literal">true</span>;</span><br><span class="line">    log_number_ = num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetPrevLogNumber</span><span class="params">(<span class="keyword">uint64_t</span> num)</span> </span>&#123;</span><br><span class="line">    has_prev_log_number_ = <span class="literal">true</span>;</span><br><span class="line">    prev_log_number_ = num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetNextFile</span><span class="params">(<span class="keyword">uint64_t</span> num)</span> </span>&#123;</span><br><span class="line">    has_next_file_number_ = <span class="literal">true</span>;</span><br><span class="line">    next_file_number_ = num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetLastSequence</span><span class="params">(SequenceNumber seq)</span> </span>&#123;</span><br><span class="line">    has_last_sequence_ = <span class="literal">true</span>;</span><br><span class="line">    last_sequence_ = seq;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetCompactPointer</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">const</span> InternalKey&amp; key)</span> </span>&#123;</span><br><span class="line">    compact_pointers_.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(level, key));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the specified file at the specified number.</span></span><br><span class="line">  <span class="comment">// REQUIRES: This version has not been saved (see VersionSet::SaveTo)</span></span><br><span class="line">  <span class="comment">// REQUIRES: &quot;smallest&quot; and &quot;largest&quot; are smallest and largest keys in file</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">const</span> InternalKey&amp; smallest, <span class="keyword">const</span> InternalKey&amp; largest)</span> </span>&#123;</span><br><span class="line">    FileMetaData f;</span><br><span class="line">    f.number = file;</span><br><span class="line">    f.file_size = file_size;</span><br><span class="line">    f.smallest = smallest;</span><br><span class="line">    f.largest = largest;</span><br><span class="line">    new_files_.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(level, f));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete the specified &quot;file&quot; from the specified &quot;level&quot;.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">DeleteFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file)</span> </span>&#123;</span><br><span class="line">    deleted_files_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(level, file));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">EncodeTo</span><span class="params">(std::string* dst)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">Status <span class="title">DecodeFrom</span><span class="params">(<span class="keyword">const</span> Slice&amp; src)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> std::set&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet;</span><br><span class="line"></span><br><span class="line">  std::string comparator_;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">  SequenceNumber last_sequence_;</span><br><span class="line">  <span class="keyword">bool</span> has_comparator_;</span><br><span class="line">  <span class="keyword">bool</span> has_log_number_;</span><br><span class="line">  <span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line">  <span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line">  <span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line">  DeletedFileSet deleted_files_;</span><br><span class="line">  std::vector&lt;std::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>VersionEdit</code> 包含了几项可编辑属性：</p>
<ol>
<li><code>comparator_</code>，比较器的名称；</li>
<li><code>log_number_</code>，日志编号；</li>
<li><code>prev_log_number_</code>，上一个日志编号；</li>
<li><code>next_file_number_</code>，下一个文件编号；</li>
<li><code>last_sequence_</code>，最后的序列号；</li>
<li><code>compact_pointers_</code>，暂时不清楚是什么；</li>
<li><code>delted_files_</code>，删除的文件，记录了 <code>level</code> 和文件号；</li>
<li><code>new_files_</code>，新增的文件，记录了 <code>level</code> 和 <code>FileMetaData</code>。</li>
</ol>
<p>上面几项属性有些还不清楚作用，先搁置不用慌。另外两个重要的接口 <code>EncodeTo</code> 和 <code>DecodeFrom</code> 负责编解码，实现在对应的 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/db/version_edit.cc"><code>.cc</code></a> 中，不在赘述。接下来，继续看 <code>Version</code> 的定义 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/db/version_set.h"><code>db/version_set.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Version</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Lookup the value for key.  If found, store it in *val and</span></span><br><span class="line">  <span class="comment">// return OK.  Else return a non-OK status.  Fills *stats.</span></span><br><span class="line">  <span class="comment">// REQUIRES: lock is not held</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">GetStats</span> &#123;</span></span><br><span class="line">    FileMetaData* seek_file;</span><br><span class="line">    <span class="keyword">int</span> seek_file_level;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append to *iters a sequence of iterators that will</span></span><br><span class="line">  <span class="comment">// yield the contents of this Version when merged together.</span></span><br><span class="line">  <span class="comment">// REQUIRES: This version has been saved (see VersionSet::SaveTo)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddIterators</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp;, std::vector&lt;Iterator*&gt;* iters)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp;, <span class="keyword">const</span> LookupKey&amp; key, std::string* val,</span></span></span><br><span class="line"><span class="params"><span class="function">             GetStats* stats)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Adds &quot;stats&quot; into the current state.  Returns true if a new</span></span><br><span class="line">  <span class="comment">// compaction may need to be triggered, false otherwise.</span></span><br><span class="line">  <span class="comment">// REQUIRES: lock is held</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">UpdateStats</span><span class="params">(<span class="keyword">const</span> GetStats&amp; stats)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record a sample of bytes read at the specified internal key.</span></span><br><span class="line">  <span class="comment">// Samples are taken approximately once every config::kReadBytesPeriod</span></span><br><span class="line">  <span class="comment">// bytes.  Returns true if a new compaction may need to be triggered.</span></span><br><span class="line">  <span class="comment">// REQUIRES: lock is held</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">RecordReadSample</span><span class="params">(Slice key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reference count management (so Versions do not disappear out from</span></span><br><span class="line">  <span class="comment">// under live iterators)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetOverlappingInputs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">int</span> level,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> InternalKey* begin,  <span class="comment">// nullptr means before all keys</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> InternalKey* end,    <span class="comment">// nullptr means after all keys</span></span></span></span><br><span class="line"><span class="params"><span class="function">      std::vector&lt;FileMetaData*&gt;* inputs)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff some file in the specified level overlaps</span></span><br><span class="line">  <span class="comment">// some part of [*smallest_user_key,*largest_user_key].</span></span><br><span class="line">  <span class="comment">// smallest_user_key==nullptr represents a key smaller than all the DB&#x27;s keys.</span></span><br><span class="line">  <span class="comment">// largest_user_key==nullptr represents a key largest than all the DB&#x27;s keys.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">OverlapInLevel</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">const</span> Slice* smallest_user_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">const</span> Slice* largest_user_key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the level at which we should place a new memtable compaction</span></span><br><span class="line">  <span class="comment">// result that covers the range [smallest_user_key,largest_user_key].</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">PickLevelForMemTableOutput</span><span class="params">(<span class="keyword">const</span> Slice&amp; smallest_user_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">const</span> Slice&amp; largest_user_key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">NumFiles</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> files_[level].<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a human readable string that describes this version&#x27;s contents.</span></span><br><span class="line">  <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Compaction</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LevelFileNumIterator</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Version</span><span class="params">(VersionSet* vset)</span></span></span><br><span class="line"><span class="function">      : vset_(vset),</span></span><br><span class="line"><span class="function">        next_(this),</span></span><br><span class="line"><span class="function">        prev_(this),</span></span><br><span class="line"><span class="function">        refs_(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        file_to_compact_(nullptr),</span></span><br><span class="line"><span class="function">        file_to_compact_level_(<span class="number">-1</span>),</span></span><br><span class="line"><span class="function">        compaction_score_(<span class="number">-1</span>),</span></span><br><span class="line"><span class="function">        compaction_level_(<span class="number">-1</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Version</span>(<span class="keyword">const</span> Version&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Version&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Version&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Version</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewConcatenatingIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp;, <span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call func(arg, level, f) for every file that overlaps user_key in</span></span><br><span class="line">  <span class="comment">// order from newest to oldest.  If an invocation of func returns</span></span><br><span class="line">  <span class="comment">// false, makes no more calls.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// REQUIRES: user portion of internal_key == user_key.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">bool</span> (*func)(<span class="keyword">void</span>*, <span class="keyword">int</span>, FileMetaData*))</span></span>;</span><br><span class="line"></span><br><span class="line">  VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">  Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">  Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line">  <span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// List of files per level</span></span><br><span class="line">  std::vector&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">  FileMetaData* file_to_compact_;</span><br><span class="line">  <span class="keyword">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line">  <span class="comment">// Score &lt; 1 means compaction is not strictly needed.  These fields</span></span><br><span class="line">  <span class="comment">// are initialized by Finalize().</span></span><br><span class="line">  <span class="keyword">double</span> compaction_score_;</span><br><span class="line">  <span class="keyword">int</span> compaction_level_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先把属性列出来：</p>
<ol>
<li><code>vset_</code>，<code>VersionSet</code> 对象指针，该类下文再介绍，搁置；</li>
<li><code>next_</code> 和 <code>prev_</code>，成对出现，双向链表无疑；</li>
<li><code>refs_</code>，引用计数；</li>
<li><code>files_</code>，每一个 <code>level</code> 中的文件元信息列表；</li>
<li><code>file_to_compact_</code> 和 <code>file_to_compact_level_</code>，准备合并的文件及其 <code>level</code>，搁置；</li>
<li><code>compaction_score_</code> 和 <code>compaction_level_</code>，需要执行合并的 <code>level</code> 及打分，搁置。</li>
</ol>
<p>对属性有一个印象就好。接下来拆开来看这个类成员函数的实现 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/db/version_set.cc"><code>db/version_set.cc</code></a>，首先看迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the smallest index i such that files[i]-&gt;largest &gt;= key.</span></span><br><span class="line"><span class="comment">// Return files.size() if there is no such file.</span></span><br><span class="line"><span class="comment">// REQUIRES: &quot;files&quot; contains a sorted list of non-overlapping files.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindFile</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; files, <span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> right = files.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> FileMetaData* f = files[mid];</span><br><span class="line">    <span class="keyword">if</span> (icmp.InternalKeyComparator::<span class="built_in">Compare</span>(f-&gt;largest.<span class="built_in">Encode</span>(), key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Key at &quot;mid.largest&quot; is &lt; &quot;target&quot;.  Therefore all</span></span><br><span class="line">      <span class="comment">// files at or before &quot;mid&quot; are uninteresting.</span></span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Key at &quot;mid.largest&quot; is &gt;= &quot;target&quot;.  Therefore all files</span></span><br><span class="line">      <span class="comment">// after &quot;mid&quot; are uninteresting.</span></span><br><span class="line">      right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An internal iterator.  For a given version/level pair, yields</span></span><br><span class="line"><span class="comment">// information about the files in the level.  For a given entry, key()</span></span><br><span class="line"><span class="comment">// is the largest key that occurs in the file, and value() is an</span></span><br><span class="line"><span class="comment">// 16-byte value containing the file number and file size, both</span></span><br><span class="line"><span class="comment">// encoded using EncodeFixed64.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Version</span>:</span>:LevelFileNumIterator : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LevelFileNumIterator</span>(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span><br><span class="line">                       <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;* flist)</span><br><span class="line">      : <span class="built_in">icmp_</span>(icmp), <span class="built_in">flist_</span>(flist), <span class="built_in">index_</span>(flist-&gt;<span class="built_in">size</span>()) &#123;  <span class="comment">// Marks as invalid</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> index_ &lt; flist_-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    index_ = <span class="built_in">FindFile</span>(icmp_, *flist_, target);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; index_ = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    index_ = flist_-&gt;<span class="built_in">empty</span>() ? <span class="number">0</span> : flist_-&gt;<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    index_++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">if</span> (index_ == <span class="number">0</span>) &#123;</span><br><span class="line">      index_ = flist_-&gt;<span class="built_in">size</span>();  <span class="comment">// Marks as invalid</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      index_--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> (*flist_)[index_]-&gt;largest.<span class="built_in">Encode</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="built_in">EncodeFixed64</span>(value_buf_, (*flist_)[index_]-&gt;number);</span><br><span class="line">    <span class="built_in">EncodeFixed64</span>(value_buf_ + <span class="number">8</span>, (*flist_)[index_]-&gt;file_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(value_buf_, <span class="built_in"><span class="keyword">sizeof</span></span>(value_buf_));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> Status::<span class="built_in">OK</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator icmp_;</span><br><span class="line">  <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;* <span class="keyword">const</span> flist_;</span><br><span class="line">  <span class="keyword">uint32_t</span> index_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Backing store for value().  Holds the file number and size.</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="keyword">char</span> value_buf_[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Iterator* <span class="title">GetFileIterator</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">const</span> Slice&amp; file_value)</span> </span>&#123;</span><br><span class="line">  TableCache* cache = <span class="keyword">reinterpret_cast</span>&lt;TableCache*&gt;(arg);</span><br><span class="line">  <span class="keyword">if</span> (file_value.<span class="built_in">size</span>() != <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewErrorIterator</span>(</span><br><span class="line">        Status::<span class="built_in">Corruption</span>(<span class="string">&quot;FileReader invoked with unexpected value&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cache-&gt;<span class="built_in">NewIterator</span>(options, <span class="built_in">DecodeFixed64</span>(file_value.<span class="built_in">data</span>()),</span><br><span class="line">                              <span class="built_in">DecodeFixed64</span>(file_value.<span class="built_in">data</span>() + <span class="number">8</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">Version::NewConcatenatingIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="keyword">int</span> level)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NewTwoLevelIterator</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">LevelFileNumIterator</span>(vset_-&gt;icmp_, &amp;files_[level]), &amp;GetFileIterator,</span><br><span class="line">      vset_-&gt;table_cache_, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::AddIterators</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::vector&lt;Iterator*&gt;* iters)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Merge all level zero files together since they may overlap</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    iters-&gt;<span class="built_in">push_back</span>(vset_-&gt;table_cache_-&gt;<span class="built_in">NewIterator</span>(</span><br><span class="line">        options, files_[<span class="number">0</span>][i]-&gt;number, files_[<span class="number">0</span>][i]-&gt;file_size));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For levels &gt; 0, we can use a concatenating iterator that sequentially</span></span><br><span class="line">  <span class="comment">// walks through the non-overlapping files in the level, opening them</span></span><br><span class="line">  <span class="comment">// lazily.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">1</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!files_[level].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      iters-&gt;<span class="built_in">push_back</span>(<span class="built_in">NewConcatenatingIterator</span>(options, level));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FindFile</code> 函数实现了一个简单的二分查找，可以在文件信息列表里快速找到第一个 <code>largest_key &gt;= key</code> 的文件信息编号。而后这里定义了一个文件信息列表的迭代器 <code>Version::LevelFileNumIterator</code>，其实现的功能是将 <code>largest_key</code> 作为 Key，文件编号和大小作为 Value，遍历和检索文件信息列表。该函数将在 <code>Version::NewConcatenatingIterator</code> 中作为第一级迭代器，对应的第二级便是其 Value 对应的 Sorted Table 文件的迭代器 <code>GetFileIterator</code>。这样就可以根据某个 Level 的文件信息列表，生成该 Level 下所有 Sorted Table 数据的迭代器。这还没结束，<code>Version::AddIterators</code> 会将所有 Level 的迭代器组合成一个列表，用来生成一个 <code>MergingIterator</code> 以遍历所有 Level 的数据（实现位于 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/db/db_impl.cc#L1088"><code>DBImpl::NewInternalIterator</code></a>）。仔细体会这个精妙的设计，然后继续来看 <code>Version::Get</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callback from TableCache::Get()</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SaverState</span> &#123;</span></span><br><span class="line">  kNotFound,</span><br><span class="line">  kFound,</span><br><span class="line">  kDeleted,</span><br><span class="line">  kCorrupt,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Saver</span> &#123;</span></span><br><span class="line">  SaverState state;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp;</span><br><span class="line">  Slice user_key;</span><br><span class="line">  std::string* value;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveValue</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> Slice&amp; ikey, <span class="keyword">const</span> Slice&amp; v)</span> </span>&#123;</span><br><span class="line">  Saver* s = <span class="keyword">reinterpret_cast</span>&lt;Saver*&gt;(arg);</span><br><span class="line">  ParsedInternalKey parsed_key;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ParseInternalKey</span>(ikey, &amp;parsed_key)) &#123;</span><br><span class="line">    s-&gt;state = kCorrupt;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;ucmp-&gt;<span class="built_in">Compare</span>(parsed_key.user_key, s-&gt;user_key) == <span class="number">0</span>) &#123;</span><br><span class="line">      s-&gt;state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;</span><br><span class="line">      <span class="keyword">if</span> (s-&gt;state == kFound) &#123;</span><br><span class="line">        s-&gt;value-&gt;<span class="built_in">assign</span>(v.<span class="built_in">data</span>(), v.<span class="built_in">size</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">NewestFirst</span><span class="params">(FileMetaData* a, FileMetaData* b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a-&gt;number &gt; b-&gt;number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">bool</span> (*func)(<span class="keyword">void</span>*, <span class="keyword">int</span>, FileMetaData*))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp = vset_-&gt;icmp_.<span class="built_in">user_comparator</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search level-0 in order from newest to oldest.</span></span><br><span class="line">  std::vector&lt;FileMetaData*&gt; tmp;</span><br><span class="line">  tmp.<span class="built_in">reserve</span>(files_[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    FileMetaData* f = files_[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">if</span> (ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;smallest.<span class="built_in">user_key</span>()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;largest.<span class="built_in">user_key</span>()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      tmp.<span class="built_in">push_back</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tmp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), NewestFirst);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(*func)(arg, <span class="number">0</span>, tmp[i])) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search other levels.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">1</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> num_files = files_[level].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary search to find earliest index whose largest key &gt;= internal_key.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index = <span class="built_in">FindFile</span>(vset_-&gt;icmp_, files_[level], internal_key);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; num_files) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][index];</span><br><span class="line">      <span class="keyword">if</span> (ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;smallest.<span class="built_in">user_key</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// All of &quot;f&quot; is past any data for user_key</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(*func)(arg, level, f)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Version::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> LookupKey&amp; k,</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::string* value, GetStats* stats)</span> </span>&#123;</span><br><span class="line">  stats-&gt;seek_file = <span class="literal">nullptr</span>;</span><br><span class="line">  stats-&gt;seek_file_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    Saver saver;</span><br><span class="line">    GetStats* stats;</span><br><span class="line">    <span class="keyword">const</span> ReadOptions* options;</span><br><span class="line">    Slice ikey;</span><br><span class="line">    FileMetaData* last_file_read;</span><br><span class="line">    <span class="keyword">int</span> last_file_read_level;</span><br><span class="line"></span><br><span class="line">    VersionSet* vset;</span><br><span class="line">    Status s;</span><br><span class="line">    <span class="keyword">bool</span> found;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">      State* state = <span class="keyword">reinterpret_cast</span>&lt;State*&gt;(arg);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">          state-&gt;last_file_read != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></span><br><span class="line">        state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;</span><br><span class="line">        state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      state-&gt;last_file_read = f;</span><br><span class="line">      state-&gt;last_file_read_level = level;</span><br><span class="line"></span><br><span class="line">      state-&gt;s = state-&gt;vset-&gt;table_cache_-&gt;<span class="built_in">Get</span>(*state-&gt;options, f-&gt;number,</span><br><span class="line">                                                f-&gt;file_size, state-&gt;ikey,</span><br><span class="line">                                                &amp;state-&gt;saver, SaveValue);</span><br><span class="line">      <span class="keyword">if</span> (!state-&gt;s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in"><span class="keyword">switch</span></span> (state-&gt;saver.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> kNotFound:</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Keep searching in other files</span></span><br><span class="line">        <span class="keyword">case</span> kFound:</span><br><span class="line">          state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">case</span> kDeleted:</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">case</span> kCorrupt:</span><br><span class="line">          state-&gt;s =</span><br><span class="line">              Status::<span class="built_in">Corruption</span>(<span class="string">&quot;corrupted key for &quot;</span>, state-&gt;saver.user_key);</span><br><span class="line">          state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  State state;</span><br><span class="line">  state.found = <span class="literal">false</span>;</span><br><span class="line">  state.stats = stats;</span><br><span class="line">  state.last_file_read = <span class="literal">nullptr</span>;</span><br><span class="line">  state.last_file_read_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  state.options = &amp;options;</span><br><span class="line">  state.ikey = k.<span class="built_in">internal_key</span>();</span><br><span class="line">  state.vset = vset_;</span><br><span class="line"></span><br><span class="line">  state.saver.state = kNotFound;</span><br><span class="line">  state.saver.ucmp = vset_-&gt;icmp_.<span class="built_in">user_comparator</span>();</span><br><span class="line">  state.saver.user_key = k.<span class="built_in">user_key</span>();</span><br><span class="line">  state.saver.value = value;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ForEachOverlapping</span>(state.saver.user_key, state.ikey, &amp;state, &amp;State::Match);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state.found ? state.s : Status::<span class="built_in">NotFound</span>(<span class="built_in">Slice</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名空间中声明了枚举类 <code>SaverState</code>，为查找操作的四种状态：未找到，找到，删除和中断。<code>Saver</code> 负责记录输入的比较器和 <code>user_key</code>，以及输出的 <code>SaverState</code> 和查找得到的 <code>value</code>。<code>SaveValue</code> 作为查找操作的回调函数，将会在 Seek 操作完成后执行，其参数为 <code>SaverState</code> 及键值对。通过判断 <code>user_key</code> 是否一致，对 <code>SaverState</code> 进行更新。</p>
<p>再来看 <code>Version::Get</code>，其调用的 <code>Version::ForEachOverlapping</code> 会根据 <code>smallest_key</code> 和 <code>largest_key</code> 筛选出要查找的文件，再通过回调函数调用 <code>table_cache_-&gt;Get</code> 进行查找，如果找到合法的结果则调用回调函数 <code>SaveValue</code>，如果回调得到的结果是 <code>kFound</code>，就可以提前返回了。Level 0 的文件由于可能存在重叠，所以每个文件都需要进行判断；而 Level 1 及以上的文件可以使用 <code>FindFile</code> 二分查找了。</p>
<h3 id="3-版本集-VersionSet"><a href="#3-版本集-VersionSet" class="headerlink" title="3. 版本集 VersionSet"></a>3. 版本集 VersionSet</h3><p>首先来看 <code>VersionSet::Builder</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A helper class so we can efficiently apply a whole sequence</span></span><br><span class="line"><span class="comment">// of edits to a particular state without creating intermediate</span></span><br><span class="line"><span class="comment">// Versions that contain full copies of the intermediate state.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>:</span>:Builder &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Helper to sort by v-&gt;files_[file_number].smallest</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BySmallestKey</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> InternalKeyComparator* internal_comparator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FileMetaData* f1, FileMetaData* f2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> r = internal_comparator-&gt;<span class="built_in">Compare</span>(f1-&gt;smallest, f2-&gt;smallest);</span><br><span class="line">      <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (r &lt; <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Break ties by file number</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (f1-&gt;number &lt; f2-&gt;number);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> std::set&lt;FileMetaData*, BySmallestKey&gt; FileSet;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LevelState</span> &#123;</span></span><br><span class="line">    std::set&lt;<span class="keyword">uint64_t</span>&gt; deleted_files;</span><br><span class="line">    FileSet* added_files;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  VersionSet* vset_;</span><br><span class="line">  Version* base_;</span><br><span class="line">  LevelState levels_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize a builder with the files from *base and other info from *vset</span></span><br><span class="line">  <span class="built_in">Builder</span>(VersionSet* vset, Version* base) : <span class="built_in">vset_</span>(vset), <span class="built_in">base_</span>(base) &#123;</span><br><span class="line">    base_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    BySmallestKey cmp;</span><br><span class="line">    cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">      levels_[level].added_files = <span class="keyword">new</span> <span class="built_in">FileSet</span>(cmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Builder</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">      <span class="keyword">const</span> FileSet* added = levels_[level].added_files;</span><br><span class="line">      std::vector&lt;FileMetaData*&gt; to_unref;</span><br><span class="line">      to_unref.<span class="built_in">reserve</span>(added-&gt;<span class="built_in">size</span>());</span><br><span class="line">      <span class="keyword">for</span> (FileSet::const_iterator it = added-&gt;<span class="built_in">begin</span>(); it != added-&gt;<span class="built_in">end</span>();</span><br><span class="line">           ++it) &#123;</span><br><span class="line">        to_unref.<span class="built_in">push_back</span>(*it);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> added;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; to_unref.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        FileMetaData* f = to_unref[i];</span><br><span class="line">        f-&gt;refs--;</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">delete</span> f;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    base_-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Apply all of the edits in *edit to the current state.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Update compaction pointers</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">      vset_-&gt;compact_pointer_[level] =</span><br><span class="line">          edit-&gt;compact_pointers_[i].second.<span class="built_in">Encode</span>().<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete files</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">      levels_[level].deleted_files.<span class="built_in">insert</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add new files</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">      FileMetaData* f = <span class="keyword">new</span> <span class="built_in">FileMetaData</span>(edit-&gt;new_files_[i].second);</span><br><span class="line">      f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We arrange to automatically compact this file after</span></span><br><span class="line">      <span class="comment">// a certain number of seeks.  Let&#x27;s assume:</span></span><br><span class="line">      <span class="comment">//   (1) One seek costs 10ms</span></span><br><span class="line">      <span class="comment">//   (2) Writing or reading 1MB costs 10ms (100MB/s)</span></span><br><span class="line">      <span class="comment">//   (3) A compaction of 1MB does 25MB of IO:</span></span><br><span class="line">      <span class="comment">//         1MB read from this level</span></span><br><span class="line">      <span class="comment">//         10-12MB read from next level (boundaries may be misaligned)</span></span><br><span class="line">      <span class="comment">//         10-12MB written to next level</span></span><br><span class="line">      <span class="comment">// This implies that 25 seeks cost the same as the compaction</span></span><br><span class="line">      <span class="comment">// of 1MB of data.  I.e., one seek costs approximately the</span></span><br><span class="line">      <span class="comment">// same as the compaction of 40KB of data.  We are a little</span></span><br><span class="line">      <span class="comment">// conservative and allow approximately one seek for every 16KB</span></span><br><span class="line">      <span class="comment">// of data before triggering a compaction.</span></span><br><span class="line">      f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>));</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">      levels_[level].deleted_files.<span class="built_in">erase</span>(f-&gt;number);</span><br><span class="line">      levels_[level].added_files-&gt;<span class="built_in">insert</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the current state in *v.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SaveTo</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">    BySmallestKey cmp;</span><br><span class="line">    cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">      <span class="comment">// Merge the set of added files with the set of pre-existing files.</span></span><br><span class="line">      <span class="comment">// Drop any deleted files.  Store the result in *v.</span></span><br><span class="line">      <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];</span><br><span class="line">      std::vector&lt;FileMetaData*&gt;::const_iterator base_iter = base_files.<span class="built_in">begin</span>();</span><br><span class="line">      std::vector&lt;FileMetaData*&gt;::const_iterator base_end = base_files.<span class="built_in">end</span>();</span><br><span class="line">      <span class="keyword">const</span> FileSet* added_files = levels_[level].added_files;</span><br><span class="line">      v-&gt;files_[level].<span class="built_in">reserve</span>(base_files.<span class="built_in">size</span>() + added_files-&gt;<span class="built_in">size</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; added_file : *added_files) &#123;</span><br><span class="line">        <span class="comment">// Add all smaller files listed in base_</span></span><br><span class="line">        <span class="keyword">for</span> (std::vector&lt;FileMetaData*&gt;::const_iterator bpos =</span><br><span class="line">                 std::<span class="built_in">upper_bound</span>(base_iter, base_end, added_file, cmp);</span><br><span class="line">             base_iter != bpos; ++base_iter) &#123;</span><br><span class="line">          <span class="built_in">MaybeAddFile</span>(v, level, *base_iter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">MaybeAddFile</span>(v, level, added_file);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add remaining base files</span></span><br><span class="line">      <span class="keyword">for</span> (; base_iter != base_end; ++base_iter) &#123;</span><br><span class="line">        <span class="built_in">MaybeAddFile</span>(v, level, *base_iter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">      <span class="comment">// Make sure there is no overlap in levels &gt; 0</span></span><br><span class="line">      <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">1</span>; i &lt; v-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> InternalKey&amp; prev_end = v-&gt;files_[level][i - <span class="number">1</span>]-&gt;largest;</span><br><span class="line">          <span class="keyword">const</span> InternalKey&amp; this_begin = v-&gt;files_[level][i]-&gt;smallest;</span><br><span class="line">          <span class="keyword">if</span> (vset_-&gt;icmp_.<span class="built_in">Compare</span>(prev_end, this_begin) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;overlapping ranges in same level %s vs. %s\n&quot;</span>,</span><br><span class="line">                    prev_end.<span class="built_in">DebugString</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">                    this_begin.<span class="built_in">DebugString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MaybeAddFile</span><span class="params">(Version* v, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (levels_[level].deleted_files.<span class="built_in">count</span>(f-&gt;number) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// File is deleted: do nothing</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::vector&lt;FileMetaData*&gt;* files = &amp;v-&gt;files_[level];</span><br><span class="line">      <span class="keyword">if</span> (level &gt; <span class="number">0</span> &amp;&amp; !files-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// Must not overlap</span></span><br><span class="line">        <span class="built_in">assert</span>(vset_-&gt;icmp_.<span class="built_in">Compare</span>((*files)[files-&gt;<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;largest,</span><br><span class="line">                                    f-&gt;smallest) &lt; <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      f-&gt;refs++;</span><br><span class="line">      files-&gt;<span class="built_in">push_back</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>VersionSet::Builder</code> 中首先定义了一个比较器 <code>BySmallestKey</code>，其会按照文件信息中的 <code>smallest</code> 对文件信息集合 <code>FileSet</code> 中存储的 <code>FileMetaData</code> 排序；定义的结构体 <code>LevelState</code> 中则包括删除的文件编号列表 <code>deleted_files</code> 和新增的文件集合 <code>added_files</code>，<code>VersionSet::Builder</code> 的成员 <code>levels_</code> 则储存所有 Level 的 <code>LevelState</code>。<code>Builder</code> 的构造和析构完成必要的内存申请和释放，成员还包括版本集 <code>vset_</code> 和基础版本 <code>base</code>，核心接口为 <code>Apply</code> 和 <code>SaveTo</code>。<code>Apply</code> 函数中先忽略 <code>compact_pointer_</code> 相关的操作，剩下的就是将 <code>edit</code> 中的增删文件信息插入到 <code>Builder::levels_</code> 里；而 <code>SaveTo</code> 则是将基础版本 <code>base</code> 中的文件信息和 <code>edit</code> 中的增删文件信息合并，按顺序插入到新版本 <code>v</code> 里。</p>
<p>接着来看 <code>VersionSet</code> 的定义 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/db/version_set.h"><code>db/version_set.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VersionSet</span>(<span class="keyword">const</span> std::string&amp; dbname, <span class="keyword">const</span> Options* options,</span><br><span class="line">             TableCache* table_cache, <span class="keyword">const</span> InternalKeyComparator*);</span><br><span class="line">  <span class="built_in">VersionSet</span>(<span class="keyword">const</span> VersionSet&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  VersionSet&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> VersionSet&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">VersionSet</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Apply *edit to the current version to form a new descriptor that</span></span><br><span class="line">  <span class="comment">// is both saved to persistent state and installed as the new</span></span><br><span class="line">  <span class="comment">// current version.  Will release *mu while actually writing to the file.</span></span><br><span class="line">  <span class="comment">// REQUIRES: *mu is held on entry.</span></span><br><span class="line">  <span class="comment">// REQUIRES: no other thread concurrently calls LogAndApply()</span></span><br><span class="line">  <span class="function">Status <span class="title">LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span></span></span><br><span class="line"><span class="function">      <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mu)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recover the last saved descriptor from persistent storage.</span></span><br><span class="line">  <span class="function">Status <span class="title">Recover</span><span class="params">(<span class="keyword">bool</span>* save_manifest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the current version.</span></span><br><span class="line">  <span class="function">Version* <span class="title">current</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> current_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the current manifest file number</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">ManifestFileNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> manifest_file_number_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate and return a new file number</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">NewFileNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> next_file_number_++; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Arrange to reuse &quot;file_number&quot; unless a newer file number has</span></span><br><span class="line">  <span class="comment">// already been allocated.</span></span><br><span class="line">  <span class="comment">// REQUIRES: &quot;file_number&quot; was returned by a call to NewFileNumber().</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReuseFileNumber</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (next_file_number_ == file_number + <span class="number">1</span>) &#123;</span><br><span class="line">      next_file_number_ = file_number;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the number of Table files at the specified level.</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">NumLevelFiles</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the combined file size of all files at the specified level.</span></span><br><span class="line">  <span class="function"><span class="keyword">int64_t</span> <span class="title">NumLevelBytes</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the last sequence number.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">LastSequence</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> last_sequence_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the last sequence number to s.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetLastSequence</span><span class="params">(<span class="keyword">uint64_t</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(s &gt;= last_sequence_);</span><br><span class="line">    last_sequence_ = s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark the specified file number as used.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MarkFileNumberUsed</span><span class="params">(<span class="keyword">uint64_t</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the current log file number.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">LogNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> log_number_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the log file number for the log file that is currently</span></span><br><span class="line">  <span class="comment">// being compacted, or zero if there is no such log file.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">PrevLogNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> prev_log_number_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick level and inputs for a new compaction.</span></span><br><span class="line">  <span class="comment">// Returns nullptr if there is no compaction to be done.</span></span><br><span class="line">  <span class="comment">// Otherwise returns a pointer to a heap-allocated object that</span></span><br><span class="line">  <span class="comment">// describes the compaction.  Caller should delete the result.</span></span><br><span class="line">  <span class="function">Compaction* <span class="title">PickCompaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a compaction object for compacting the range [begin,end] in</span></span><br><span class="line">  <span class="comment">// the specified level.  Returns nullptr if there is nothing in that</span></span><br><span class="line">  <span class="comment">// level that overlaps the specified range.  Caller should delete</span></span><br><span class="line">  <span class="comment">// the result.</span></span><br><span class="line">  <span class="function">Compaction* <span class="title">CompactRange</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">const</span> InternalKey* begin,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> InternalKey* end)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the maximum overlapping data (in bytes) at next level for any</span></span><br><span class="line">  <span class="comment">// file at a level &gt;= 1.</span></span><br><span class="line">  <span class="function"><span class="keyword">int64_t</span> <span class="title">MaxNextLevelOverlappingBytes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an iterator that reads over the compaction inputs for &quot;*c&quot;.</span></span><br><span class="line">  <span class="comment">// The caller should delete the iterator when no longer needed.</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">MakeInputIterator</span><span class="params">(Compaction* c)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff some level needs a compaction.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Version* v = current_;</span><br><span class="line">    <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add all files listed in any live version to *live.</span></span><br><span class="line">  <span class="comment">// May also mutate some internal state.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddLiveFiles</span><span class="params">(std::set&lt;<span class="keyword">uint64_t</span>&gt;* live)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the approximate offset in the database of the data for</span></span><br><span class="line">  <span class="comment">// &quot;key&quot; as of version &quot;v&quot;.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">ApproximateOffsetOf</span><span class="params">(Version* v, <span class="keyword">const</span> InternalKey&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a human-readable short (single-line) summary of the number</span></span><br><span class="line">  <span class="comment">// of files per level.  Uses *scratch as backing store.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LevelSummaryStorage</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">LevelSummary</span><span class="params">(LevelSummaryStorage* scratch)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Compaction</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Version</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ReuseManifest</span><span class="params">(<span class="keyword">const</span> std::string&amp; dscname, <span class="keyword">const</span> std::string&amp; dscbase)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Finalize</span><span class="params">(Version* v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetRange</span><span class="params">(<span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; inputs, InternalKey* smallest,</span></span></span><br><span class="line"><span class="params"><span class="function">                InternalKey* largest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetRange2</span><span class="params">(<span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; inputs1,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; inputs2,</span></span></span><br><span class="line"><span class="params"><span class="function">                 InternalKey* smallest, InternalKey* largest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetupOtherInputs</span><span class="params">(Compaction* c)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save current contents to *log</span></span><br><span class="line">  <span class="function">Status <span class="title">WriteSnapshot</span><span class="params">(log::Writer* log)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AppendVersion</span><span class="params">(Version* v)</span></span>;</span><br><span class="line"></span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> std::string dbname_;</span><br><span class="line">  <span class="keyword">const</span> Options* <span class="keyword">const</span> options_;</span><br><span class="line">  TableCache* <span class="keyword">const</span> table_cache_;</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator icmp_;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> manifest_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence_;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Opened lazily</span></span><br><span class="line">  WritableFile* descriptor_file_;</span><br><span class="line">  log::Writer* descriptor_log_;</span><br><span class="line">  Version dummy_versions_;  <span class="comment">// Head of circular doubly-linked list of versions.</span></span><br><span class="line">  Version* current_;        <span class="comment">// == dummy_versions_.prev_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Per-level key at which the next compaction at that level should start.</span></span><br><span class="line">  <span class="comment">// Either an empty string, or a valid InternalKey.</span></span><br><span class="line">  std::string compact_pointer_[config::kNumLevels];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义很长，先放着，继续看实现的部分（顺序经过重排）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::Ref</span><span class="params">()</span> </span>&#123; ++refs_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::Unref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="keyword">this</span> != &amp;vset_-&gt;dummy_versions_);</span><br><span class="line">  <span class="built_in">assert</span>(refs_ &gt;= <span class="number">1</span>);</span><br><span class="line">  --refs_;</span><br><span class="line">  <span class="keyword">if</span> (refs_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Version::~<span class="built_in">Version</span>() &#123;</span><br><span class="line">  <span class="built_in">assert</span>(refs_ == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove from linked list</span></span><br><span class="line">  prev_-&gt;next_ = next_;</span><br><span class="line">  next_-&gt;prev_ = prev_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop references to files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][i];</span><br><span class="line">      <span class="built_in">assert</span>(f-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">      f-&gt;refs--;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VersionSet::<span class="built_in">VersionSet</span>(<span class="keyword">const</span> std::string&amp; dbname, <span class="keyword">const</span> Options* options,</span><br><span class="line">                       TableCache* table_cache,</span><br><span class="line">                       <span class="keyword">const</span> InternalKeyComparator* cmp)</span><br><span class="line">    : <span class="built_in">env_</span>(options-&gt;env),</span><br><span class="line">      <span class="built_in">dbname_</span>(dbname),</span><br><span class="line">      <span class="built_in">options_</span>(options),</span><br><span class="line">      <span class="built_in">table_cache_</span>(table_cache),</span><br><span class="line">      <span class="built_in">icmp_</span>(*cmp),</span><br><span class="line">      <span class="built_in">next_file_number_</span>(<span class="number">2</span>),</span><br><span class="line">      <span class="built_in">manifest_file_number_</span>(<span class="number">0</span>),  <span class="comment">// Filled by Recover()</span></span><br><span class="line">      <span class="built_in">last_sequence_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">log_number_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">prev_log_number_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">descriptor_file_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">descriptor_log_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">dummy_versions_</span>(<span class="keyword">this</span>),</span><br><span class="line">      <span class="built_in">current_</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="built_in">AppendVersion</span>(<span class="keyword">new</span> <span class="built_in">Version</span>(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VersionSet::~<span class="built_in">VersionSet</span>() &#123;</span><br><span class="line">  current_-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="built_in">assert</span>(dummy_versions_.next_ == &amp;dummy_versions_);  <span class="comment">// List must be empty</span></span><br><span class="line">  <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">  <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::AppendVersion</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make &quot;v&quot; current</span></span><br><span class="line">  <span class="built_in">assert</span>(v-&gt;refs_ == <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">assert</span>(v != current_);</span><br><span class="line">  <span class="keyword">if</span> (current_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    current_-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  current_ = v;</span><br><span class="line">  v-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append to linked list</span></span><br><span class="line">  v-&gt;prev_ = dummy_versions_.prev_;</span><br><span class="line">  v-&gt;next_ = &amp;dummy_versions_;</span><br><span class="line">  v-&gt;prev_-&gt;next_ = v;</span><br><span class="line">  v-&gt;next_-&gt;prev_ = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>VersionSet</code> 构造函数的参数包括数据库的 <code>name</code> 和 <code>options</code>，缓存 <code>table_cache</code> 以及内部比较器 <code>cmp</code>。大部分成员变量都初始化为 0 或 <code>nullptr</code>，值得注意的是 <code>next_file_number_=2</code>，还有 <code>dummy_versions_(this)</code>。<code>dummpy_versions_</code> 注释中说明了是版本双向链表的头部，不会有其他实际功能。构造函数中会执行 <code>AppendVersion</code> 增加一个新版本，也就是在双向链表的尾部插入版本 <code>v</code>，并且将 <code>current_</code> 指向这个最新的版本；而析构函数中会要求当 <code>current_</code> 降低引用计数、完成可能的析构后，<code>dummy_versions_</code> 所指向的双向链表为空。继续看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (edit-&gt;has_log_number_) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">    <span class="built_in">assert</span>(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    edit-&gt;<span class="built_in">SetLogNumber</span>(log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line">    edit-&gt;<span class="built_in">SetPrevLogNumber</span>(prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  edit-&gt;<span class="built_in">SetNextFile</span>(next_file_number_);</span><br><span class="line">  edit-&gt;<span class="built_in">SetLastSequence</span>(last_sequence_);</span><br><span class="line"></span><br><span class="line">  Version* v = <span class="keyword">new</span> <span class="built_in">Version</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">    builder.<span class="built_in">Apply</span>(edit);</span><br><span class="line">    builder.<span class="built_in">SaveTo</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Finalize</span>(v);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line">  <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line">  std::string new_manifest_file;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">    <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">    <span class="built_in">assert</span>(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">    new_manifest_file = <span class="built_in">DescriptorFileName</span>(dbname_, manifest_file_number_);</span><br><span class="line">    edit-&gt;<span class="built_in">SetNextFile</span>(next_file_number_);</span><br><span class="line">    s = env_-&gt;<span class="built_in">NewWritableFile</span>(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      descriptor_log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(descriptor_file_);</span><br><span class="line">      s = <span class="built_in">WriteSnapshot</span>(descriptor_log_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">  &#123;</span><br><span class="line">    mu-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      std::string record;</span><br><span class="line">      edit-&gt;<span class="built_in">EncodeTo</span>(&amp;record);</span><br><span class="line">      s = descriptor_log_-&gt;<span class="built_in">AddRecord</span>(record);</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        s = descriptor_file_-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="built_in">Log</span>(options_-&gt;info_log, <span class="string">&quot;MANIFEST write: %s\n&quot;</span>, s.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">    <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; !new_manifest_file.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      s = <span class="built_in">SetCurrentFile</span>(env_, dbname_, manifest_file_number_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install the new version</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">AppendVersion</span>(v);</span><br><span class="line">    log_number_ = edit-&gt;log_number_;</span><br><span class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">    <span class="keyword">if</span> (!new_manifest_file.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">      descriptor_log_ = <span class="literal">nullptr</span>;</span><br><span class="line">      descriptor_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">      env_-&gt;<span class="built_in">DeleteFile</span>(new_manifest_file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(config::kL0_CompactionTrigger);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = <span class="built_in">TotalFileSize</span>(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / <span class="built_in">MaxBytesForLevel</span>(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心接口 <code>LogAndApply</code> 会根据当前版本 <code>current_</code> 和修订部分 <code>edit</code>，合成一个新版本 <code>v</code>，而后将修订的记录写入 Manifest 文件中，最后将新版本 <code>AppendVersion</code> 到版本集中作为新的 <code>current_</code>，这样就完成了一个新版本的构建。而 <code>Recover</code> 则对应从 Manifest 中恢复版本的过程。由于 <code>Manifest</code> 记录了所有的版本变更信息，使用 <code>VersionSet::Builder</code> 逐个 <code>Apply</code> 就可以获得存储的最新版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::Recover</span><span class="params">(<span class="keyword">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LogReporter</span> :</span> <span class="keyword">public</span> log::Reader::Reporter &#123;</span><br><span class="line">    Status* status;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">const</span> Status&amp; s)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;status-&gt;<span class="built_in">ok</span>()) *<span class="keyword">this</span>-&gt;status = s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read &quot;CURRENT&quot; file, which contains a pointer to the current manifest file</span></span><br><span class="line">  std::string current;</span><br><span class="line">  Status s = <span class="built_in">ReadFileToString</span>(env_, <span class="built_in">CurrentFileName</span>(dbname_), &amp;current);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (current.<span class="built_in">empty</span>() || current[current.<span class="built_in">size</span>() - <span class="number">1</span>] != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;CURRENT file does not end with newline&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  current.<span class="built_in">resize</span>(current.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  std::string dscname = dbname_ + <span class="string">&quot;/&quot;</span> + current;</span><br><span class="line">  SequentialFile* file;</span><br><span class="line">  s = env_-&gt;<span class="built_in">NewSequentialFile</span>(dscname, &amp;file);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">IsNotFound</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;CURRENT points to a non-existent file&quot;</span>,</span><br><span class="line">                                s.<span class="built_in">ToString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> have_log_number = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> have_prev_log_number = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> have_next_file = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> have_last_sequence = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number = <span class="number">0</span>;</span><br><span class="line">  <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    LogReporter reporter;</span><br><span class="line">    reporter.status = &amp;s;</span><br><span class="line">    <span class="function">log::Reader <span class="title">reader</span><span class="params">(file, &amp;reporter, <span class="literal">true</span> <span class="comment">/*checksum*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="number">0</span> <span class="comment">/*initial_offset*/</span>)</span></span>;</span><br><span class="line">    Slice record;</span><br><span class="line">    std::string scratch;</span><br><span class="line">    <span class="keyword">while</span> (reader.<span class="built_in">ReadRecord</span>(&amp;record, &amp;scratch) &amp;&amp; s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      VersionEdit edit;</span><br><span class="line">      s = edit.<span class="built_in">DecodeFrom</span>(record);</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edit.has_comparator_ &amp;&amp;</span><br><span class="line">            edit.comparator_ != icmp_.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Name</span>()) &#123;</span><br><span class="line">          s = Status::<span class="built_in">InvalidArgument</span>(</span><br><span class="line">              edit.comparator_ + <span class="string">&quot; does not match existing comparator &quot;</span>,</span><br><span class="line">              icmp_.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Name</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        builder.<span class="built_in">Apply</span>(&amp;edit);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (edit.has_log_number_) &#123;</span><br><span class="line">        log_number = edit.log_number_;</span><br><span class="line">        have_log_number = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (edit.has_prev_log_number_) &#123;</span><br><span class="line">        prev_log_number = edit.prev_log_number_;</span><br><span class="line">        have_prev_log_number = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (edit.has_next_file_number_) &#123;</span><br><span class="line">        next_file = edit.next_file_number_;</span><br><span class="line">        have_next_file = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (edit.has_last_sequence_) &#123;</span><br><span class="line">        last_sequence = edit.last_sequence_;</span><br><span class="line">        have_last_sequence = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> file;</span><br><span class="line">  file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!have_next_file) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;no meta-nextfile entry in descriptor&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_log_number) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;no meta-lognumber entry in descriptor&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_last_sequence) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;no last-sequence-number entry in descriptor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_prev_log_number) &#123;</span><br><span class="line">      prev_log_number = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MarkFileNumberUsed</span>(prev_log_number);</span><br><span class="line">    <span class="built_in">MarkFileNumberUsed</span>(log_number);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    Version* v = <span class="keyword">new</span> <span class="built_in">Version</span>(<span class="keyword">this</span>);</span><br><span class="line">    builder.<span class="built_in">SaveTo</span>(v);</span><br><span class="line">    <span class="comment">// Install recovered version</span></span><br><span class="line">    <span class="built_in">Finalize</span>(v);</span><br><span class="line">    <span class="built_in">AppendVersion</span>(v);</span><br><span class="line">    manifest_file_number_ = next_file;</span><br><span class="line">    next_file_number_ = next_file + <span class="number">1</span>;</span><br><span class="line">    last_sequence_ = last_sequence;</span><br><span class="line">    log_number_ = log_number;</span><br><span class="line">    prev_log_number_ = prev_log_number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if we can reuse the existing MANIFEST file.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ReuseManifest</span>(dscname, current)) &#123;</span><br><span class="line">      <span class="comment">// No need to save new manifest</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VersionSet::ReuseManifest</span><span class="params">(<span class="keyword">const</span> std::string&amp; dscname,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> std::string&amp; dscbase)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!options_-&gt;reuse_logs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  FileType manifest_type;</span><br><span class="line">  <span class="keyword">uint64_t</span> manifest_number;</span><br><span class="line">  <span class="keyword">uint64_t</span> manifest_size;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ParseFileName</span>(dscbase, &amp;manifest_number, &amp;manifest_type) ||</span><br><span class="line">      manifest_type != kDescriptorFile ||</span><br><span class="line">      !env_-&gt;<span class="built_in">GetFileSize</span>(dscname, &amp;manifest_size).<span class="built_in">ok</span>() ||</span><br><span class="line">      <span class="comment">// Make new compacted MANIFEST if old one is too big</span></span><br><span class="line">      manifest_size &gt;= <span class="built_in">TargetFileSize</span>(options_)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(descriptor_log_ == <span class="literal">nullptr</span>);</span><br><span class="line">  Status r = env_-&gt;<span class="built_in">NewAppendableFile</span>(dscname, &amp;descriptor_file_);</span><br><span class="line">  <span class="keyword">if</span> (!r.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">Log</span>(options_-&gt;info_log, <span class="string">&quot;Reuse MANIFEST: %s\n&quot;</span>, r.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">assert</span>(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Log</span>(options_-&gt;info_log, <span class="string">&quot;Reusing MANIFEST %s\n&quot;</span>, dscname.<span class="built_in">c_str</span>());</span><br><span class="line">  descriptor_log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(descriptor_file_, manifest_size);</span><br><span class="line">  manifest_file_number_ = manifest_number;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::MarkFileNumberUsed</span><span class="params">(<span class="keyword">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (next_file_number_ &lt;= number) &#123;</span><br><span class="line">    next_file_number_ = number + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇分析了版本管理相关的代码，包括 <code>VersionEdit</code>、<code>Version</code> 和 <code>VersionSet</code> 的实现。<code>VersionSet</code> 还有一大部分代码是与 Compaction 相关的，将会在下篇中继续分析。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LevelDB/" rel="tag">LevelDB</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-LevelDB源码分析——7.Sorted String Table续"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%947.Sorted%20String%20Table%E7%BB%AD/"
    >LevelDB源码分析——7.Sorted String Table续</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%947.Sorted%20String%20Table%E7%BB%AD/" class="article-date">
  <time datetime="2022-02-10T06:30:30.000Z" itemprop="datePublished">2022-02-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/LevelDB/">LevelDB</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="七-Sorted-String-Table续"><a href="#七-Sorted-String-Table续" class="headerlink" title="七.Sorted String Table续"></a>七.Sorted String Table续</h2><p>本系列的上一篇介绍了 Sorted Table 的构建过程，本篇就继续分析 Sorted Table 的读取、解析过程。</p>
<h3 id="4-Block"><a href="#4-Block" class="headerlink" title="4. Block"></a>4. Block</h3><p>根据依赖关系，首先来看 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/table/format.cc"><code>table/format.cc</code></a> 中 <code>ReadBlock</code> 函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlockContents</span> &#123;</span></span><br><span class="line">  Slice data;           <span class="comment">// Actual contents of data</span></span><br><span class="line">  <span class="keyword">bool</span> cachable;        <span class="comment">// True iff data can be cached</span></span><br><span class="line">  <span class="keyword">bool</span> heap_allocated;  <span class="comment">// True iff caller should delete[] data.data()</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the block identified by &quot;handle&quot; from &quot;file&quot;.  On failure</span></span><br><span class="line"><span class="comment">// return non-OK.  On success fill *result and return OK.</span></span><br><span class="line"><span class="function">Status <span class="title">ReadBlock</span><span class="params">(RandomAccessFile* file, <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">const</span> BlockHandle&amp; handle, BlockContents* result)</span> </span>&#123;</span><br><span class="line">  result-&gt;data = <span class="built_in">Slice</span>();</span><br><span class="line">  result-&gt;cachable = <span class="literal">false</span>;</span><br><span class="line">  result-&gt;heap_allocated = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read the block contents as well as the type/crc footer.</span></span><br><span class="line">  <span class="comment">// See table_builder.cc for the code that built this structure.</span></span><br><span class="line">  <span class="keyword">size_t</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(handle.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">char</span>[n + kBlockTrailerSize];</span><br><span class="line">  Slice contents;</span><br><span class="line">  Status s = file-&gt;<span class="built_in">Read</span>(handle.<span class="built_in">offset</span>(), n + kBlockTrailerSize, &amp;contents, buf);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (contents.<span class="built_in">size</span>() != n + kBlockTrailerSize) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;truncated block read&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check the crc of the type and the block contents</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data = contents.<span class="built_in">data</span>();  <span class="comment">// Pointer to where Read put the data</span></span><br><span class="line">  <span class="keyword">if</span> (options.verify_checksums) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> crc = crc32c::<span class="built_in">Unmask</span>(<span class="built_in">DecodeFixed32</span>(data + n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> actual = crc32c::<span class="built_in">Value</span>(data, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (actual != crc) &#123;</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;block checksum mismatch&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (data[n]) &#123;</span><br><span class="line">    <span class="keyword">case</span> kNoCompression:</span><br><span class="line">      <span class="keyword">if</span> (data != buf) &#123;</span><br><span class="line">        <span class="comment">// File implementation gave us pointer to some other data.</span></span><br><span class="line">        <span class="comment">// Use it directly under the assumption that it will be live</span></span><br><span class="line">        <span class="comment">// while the file is open.</span></span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        result-&gt;data = <span class="built_in">Slice</span>(data, n);</span><br><span class="line">        result-&gt;heap_allocated = <span class="literal">false</span>;</span><br><span class="line">        result-&gt;cachable = <span class="literal">false</span>;  <span class="comment">// Do not double-cache</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result-&gt;data = <span class="built_in">Slice</span>(buf, n);</span><br><span class="line">        result-&gt;heap_allocated = <span class="literal">true</span>;</span><br><span class="line">        result-&gt;cachable = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ok</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kSnappyCompression: &#123;</span><br><span class="line">      <span class="keyword">size_t</span> ulength = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (!port::<span class="built_in">Snappy_GetUncompressedLength</span>(data, n, &amp;ulength)) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;corrupted compressed block contents&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">char</span>* ubuf = <span class="keyword">new</span> <span class="keyword">char</span>[ulength];</span><br><span class="line">      <span class="keyword">if</span> (!port::<span class="built_in">Snappy_Uncompress</span>(data, n, ubuf)) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        <span class="keyword">delete</span>[] ubuf;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;corrupted compressed block contents&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      result-&gt;data = <span class="built_in">Slice</span>(ubuf, ulength);</span><br><span class="line">      result-&gt;heap_allocated = <span class="literal">true</span>;</span><br><span class="line">      result-&gt;cachable = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad block type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于已经存储的 Sorted Table 文件，提供 <code>ReadOptions</code> 和 <code>BlockHandle</code> 后，可以将 <code>handle</code> 对应的 Block 内容读取到 <code>BlockContents</code> 中。该结构体储存 Block 的字节流，以及能否缓存、是否需要手动清理的标记。<code>ReadBlock</code> 的实现非常直接，读取文件对应位置的字节流，进行必要的校验和解压缩。继续看 <code>Block</code> 的解析部分 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/table/block.h"><code>table/block.h</code></a> ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlockContents</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize the block with the specified contents.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Block</span><span class="params">(<span class="keyword">const</span> BlockContents&amp; contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Block</span>(<span class="keyword">const</span> Block&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Block&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Block&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Block</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">(<span class="keyword">const</span> Comparator* comparator)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iter</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">NumRestarts</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;</span><br><span class="line">  <span class="keyword">size_t</span> size_;</span><br><span class="line">  <span class="keyword">uint32_t</span> restart_offset_;  <span class="comment">// Offset in data_ of restart array</span></span><br><span class="line">  <span class="keyword">bool</span> owned_;               <span class="comment">// Block owns data_[]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接口的核心部分自然是迭代器。迭代器提供 Block 中键值对数据的遍历和查找。继续看对应函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">Block::NumRestarts</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(size_ &gt;= <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">DecodeFixed32</span>(data_ + size_ - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Block::<span class="built_in">Block</span>(<span class="keyword">const</span> BlockContents&amp; contents)</span><br><span class="line">    : <span class="built_in">data_</span>(contents.data.<span class="built_in">data</span>()),</span><br><span class="line">      <span class="built_in">size_</span>(contents.data.<span class="built_in">size</span>()),</span><br><span class="line">      <span class="built_in">owned_</span>(contents.heap_allocated) &#123;</span><br><span class="line">  <span class="keyword">if</span> (size_ &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>)) &#123;</span><br><span class="line">    size_ = <span class="number">0</span>;  <span class="comment">// Error marker</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">size_t</span> max_restarts_allowed = (size_ - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>)) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NumRestarts</span>() &gt; max_restarts_allowed) &#123;</span><br><span class="line">      <span class="comment">// The size is too small for NumRestarts()</span></span><br><span class="line">      size_ = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      restart_offset_ = size_ - (<span class="number">1</span> + <span class="built_in">NumRestarts</span>()) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Block::~<span class="built_in">Block</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (owned_) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] data_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper routine: decode the next block entry starting at &quot;p&quot;,</span></span><br><span class="line"><span class="comment">// storing the number of shared key bytes, non_shared key bytes,</span></span><br><span class="line"><span class="comment">// and the length of the value in &quot;*shared&quot;, &quot;*non_shared&quot;, and</span></span><br><span class="line"><span class="comment">// &quot;*value_length&quot;, respectively.  Will not dereference past &quot;limit&quot;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If any errors are detected, returns nullptr.  Otherwise, returns a</span></span><br><span class="line"><span class="comment">// pointer to the key delta (just past the three decoded values).</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">DecodeEntry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">uint32_t</span>* shared, <span class="keyword">uint32_t</span>* non_shared,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">uint32_t</span>* value_length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (limit - p &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  *shared = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p)[<span class="number">0</span>];</span><br><span class="line">  *non_shared = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p)[<span class="number">1</span>];</span><br><span class="line">  *value_length = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p)[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> ((*shared | *non_shared | *value_length) &lt; <span class="number">128</span>) &#123;</span><br><span class="line">    <span class="comment">// Fast path: all three values are encoded in one byte each</span></span><br><span class="line">    p += <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, shared)) == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, non_shared)) == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, value_length)) == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(limit - p) &lt; (*non_shared + *value_length)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照之前描述的 Block 存储结构，最后 4 字节存储复活点的数量，如 <code>NumRestarts</code> 实现。构造时进行必要的判断，在 <code>restart_offset_</code> 中存储复活点列表的位置。解析条目时，首先假设 <code>shared</code>、<code>non_shared</code> 和 <code>value_length</code> 都小于 128，尝试按照按字节读取长度以提高解析速度。在大部分情况下该规则都是满足的，当少数情况出现超长的串时，会回退到普通的 <code>GetVarint32Ptr</code>。继续看迭代器的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span>:</span>:Iter : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> Comparator* <span class="keyword">const</span> comparator_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> data_;       <span class="comment">// underlying block contents</span></span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="keyword">const</span> restarts_;      <span class="comment">// Offset of restart array (list of fixed32)</span></span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="keyword">const</span> num_restarts_;  <span class="comment">// Number of uint32_t entries in restart array</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// current_ is offset in data_ of current entry.  &gt;= restarts_ if !Valid</span></span><br><span class="line">  <span class="keyword">uint32_t</span> current_;</span><br><span class="line">  <span class="keyword">uint32_t</span> restart_index_;  <span class="comment">// Index of restart block in which current_ falls</span></span><br><span class="line">  std::string key_;</span><br><span class="line">  Slice value_;</span><br><span class="line">  Status status_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; a, <span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparator_-&gt;<span class="built_in">Compare</span>(a, b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the offset in data_ just past the end of the current entry.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">NextEntryOffset</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value_.<span class="built_in">data</span>() + value_.<span class="built_in">size</span>()) - data_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">GetRestartPoint</span><span class="params">(<span class="keyword">uint32_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(index &lt; num_restarts_);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DecodeFixed32</span>(data_ + restarts_ + index * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToRestartPoint</span><span class="params">(<span class="keyword">uint32_t</span> index)</span> </span>&#123;</span><br><span class="line">    key_.<span class="built_in">clear</span>();</span><br><span class="line">    restart_index_ = index;</span><br><span class="line">    <span class="comment">// current_ will be fixed by ParseNextKey();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ParseNextKey() starts at the end of value_, so set value_ accordingly</span></span><br><span class="line">    <span class="keyword">uint32_t</span> offset = <span class="built_in">GetRestartPoint</span>(index);</span><br><span class="line">    value_ = <span class="built_in">Slice</span>(data_ + offset, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Iter</span>(<span class="keyword">const</span> Comparator* comparator, <span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">uint32_t</span> restarts,</span><br><span class="line">       <span class="keyword">uint32_t</span> num_restarts)</span><br><span class="line">      : <span class="built_in">comparator_</span>(comparator),</span><br><span class="line">        <span class="built_in">data_</span>(data),</span><br><span class="line">        <span class="built_in">restarts_</span>(restarts),</span><br><span class="line">        <span class="built_in">num_restarts_</span>(num_restarts),</span><br><span class="line">        <span class="built_in">current_</span>(restarts_),</span><br><span class="line">        <span class="built_in">restart_index_</span>(num_restarts_) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(num_restarts_ &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> current_ &lt; restarts_; &#125;</span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> status_; &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> key_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> value_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="built_in">ParseNextKey</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan backwards to a restart point before current_</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> original = current_;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetRestartPoint</span>(restart_index_) &gt;= original) &#123;</span><br><span class="line">      <span class="keyword">if</span> (restart_index_ == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// No more entries</span></span><br><span class="line">        current_ = restarts_;</span><br><span class="line">        restart_index_ = num_restarts_;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      restart_index_--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SeekToRestartPoint</span>(restart_index_);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// Loop until end of current entry hits the start of original entry</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">ParseNextKey</span>() &amp;&amp; <span class="built_in">NextEntryOffset</span>() &lt; original);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SeekToRestartPoint</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ParseNextKey</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SeekToRestartPoint</span>(num_restarts_ - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">ParseNextKey</span>() &amp;&amp; <span class="built_in">NextEntryOffset</span>() &lt; restarts_) &#123;</span><br><span class="line">      <span class="comment">// Keep skipping</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CorruptionError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    current_ = restarts_;</span><br><span class="line">    restart_index_ = num_restarts_;</span><br><span class="line">    status_ = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad entry in block&quot;</span>);</span><br><span class="line">    key_.<span class="built_in">clear</span>();</span><br><span class="line">    value_.<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ParseNextKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    current_ = <span class="built_in">NextEntryOffset</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p = data_ + current_;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* limit = data_ + restarts_;  <span class="comment">// Restarts come right after data</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= limit) &#123;</span><br><span class="line">      <span class="comment">// No more entries to return.  Mark as invalid.</span></span><br><span class="line">      current_ = restarts_;</span><br><span class="line">      restart_index_ = num_restarts_;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode next entry</span></span><br><span class="line">    <span class="keyword">uint32_t</span> shared, non_shared, value_length;</span><br><span class="line">    p = <span class="built_in">DecodeEntry</span>(p, limit, &amp;shared, &amp;non_shared, &amp;value_length);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || key_.<span class="built_in">size</span>() &lt; shared) &#123;</span><br><span class="line">      <span class="built_in">CorruptionError</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      key_.<span class="built_in">resize</span>(shared);</span><br><span class="line">      key_.<span class="built_in">append</span>(p, non_shared);</span><br><span class="line">      value_ = <span class="built_in">Slice</span>(p + non_shared, value_length);</span><br><span class="line">      <span class="keyword">while</span> (restart_index_ + <span class="number">1</span> &lt; num_restarts_ &amp;&amp;</span><br><span class="line">             <span class="built_in">GetRestartPoint</span>(restart_index_ + <span class="number">1</span>) &lt; current_) &#123;</span><br><span class="line">        ++restart_index_;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">Block::NewIterator</span><span class="params">(<span class="keyword">const</span> Comparator* comparator)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size_ &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewErrorIterator</span>(Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad block contents&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> num_restarts = <span class="built_in">NumRestarts</span>();</span><br><span class="line">  <span class="keyword">if</span> (num_restarts == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewEmptyIterator</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Iter</span>(comparator, data_, restart_offset_, num_restarts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看成员变量：</p>
<ol>
<li>Block 的字节流存储于 <code>data_</code> 中；</li>
<li><code>restarts_</code> 和 <code>num_restarts_</code> 存储复活点列表的偏移和数量；</li>
<li><code>current_</code> 存储当前迭代器的偏移，<code>restart_index_</code> 存储 <code>current_</code> 前面最近的复活点偏移；</li>
<li><code>key_</code> 和 <code>value_</code> 存储键值对。注意 <code>key_</code> 是 <code>std::string</code>，因为有共享前缀，需要存储中间恢复的 <code>Key</code>，而 <code>value_</code> 可以直接从 <code>data_</code> 中截取。</li>
</ol>
<p>函数 <code>NextEntryOffset</code> 根据当前的 <code>value</code> 的位置和大小计算下一个键值对的起始位置，因为每个条目最后存储的是 <code>value</code>。函数 <code>GetRestartPoint</code> 读取第 <code>index</code> 个复活点的位置，函数 <code>SeekToRestartPoint</code> 将当前的 <code>key_</code> 清空、设定 <code>restart_index_</code> 并将 <code>value_</code> 设为复活点前的空串，以便于执行 <code>NextEntryOffset</code> 时获得对应复活点偏移。跳到函数 <code>ParseNextKey</code>，将 <code>current_</code> 设为下一个键值对的起点，通过 <code>DecodeEntry</code> 解析得到需要的长度信息，恢复 <code>key_</code> 并读取 <code>value_</code>。</p>
<p>迭代器存储的状态信息包括 <code>key_</code> 存储的共享前缀，和 <code>value_</code> 存储的下个条目起点。当发生起始点的切换时，需要先执行函数 <code>SeekToRestartPoint</code> 清空当前存储的状态信息，再执行函数 <code>ParseNextKey</code> 解析下一个键值对。按照这个过程读函数 <code>Prev</code>、<code>SeekToFirst</code> 和 <code>SeekToLast</code> 就非常轻松了。最后来看函数 <code>Seek</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Binary search in restart array to find the last restart point</span></span><br><span class="line">  <span class="comment">// with a key &lt; target</span></span><br><span class="line">  <span class="keyword">uint32_t</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> right = num_restarts_ - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> region_offset = <span class="built_in">GetRestartPoint</span>(mid);</span><br><span class="line">    <span class="keyword">uint32_t</span> shared, non_shared, value_length;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr =</span><br><span class="line">      <span class="built_in">DecodeEntry</span>(data_ + region_offset, data_ + restarts_, &amp;shared,</span><br><span class="line">                  &amp;non_shared, &amp;value_length);</span><br><span class="line">    <span class="keyword">if</span> (key_ptr == <span class="literal">nullptr</span> || (shared != <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="built_in">CorruptionError</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Slice <span class="title">mid_key</span><span class="params">(key_ptr, non_shared)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Compare</span>(mid_key, target) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Key at &quot;mid&quot; is smaller than &quot;target&quot;.  Therefore all</span></span><br><span class="line">      <span class="comment">// blocks before &quot;mid&quot; are uninteresting.</span></span><br><span class="line">      left = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Key at &quot;mid&quot; is &gt;= &quot;target&quot;.  Therefore all blocks at or</span></span><br><span class="line">      <span class="comment">// after &quot;mid&quot; are uninteresting.</span></span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linear search (within restart block) for first key &gt;= target</span></span><br><span class="line">  <span class="built_in">SeekToRestartPoint</span>(left);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ParseNextKey</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Compare</span>(key_, target) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在复活点上做二分查找，这里实现的二分查找的结果就是 <code>left</code> 对应的复活点 <code>Key</code> 是严格小于 <code>target</code> 的最大 <code>Key</code>。二分查找完成后跳到复活点处，按顺序恢复每个条目的键值，对比返回。</p>
<p>最后来看一个细节：<code>restart_index_</code> 只会在函数 <code>Prev</code> 里读取到，以确定上一个复活点的位置。如果仔细观察函数 <code>ParseNextKey</code> 中关于 <code>restart_index_</code> 的更新：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (restart_index_ + <span class="number">1</span> &lt; num_restarts_ &amp;&amp;</span><br><span class="line">       <span class="built_in">GetRestartPoint</span>(restart_index_ + <span class="number">1</span>) &lt; current_) &#123;</span><br><span class="line">  ++restart_index_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这里 <code>current_</code> 刚好到达复活点 <code>i</code>，<code>restart_index_</code> 仍然会保持在 <code>i - 1</code> 的，这样在执行 <code>Prev</code> 时 <code>while</code> 循环可以少做一次。Google 大佬实力可见一斑。但从语义的角度，这种做法比较容易让人困惑，我应该不会这么做（所以成不了 Google 大佬。</p>
<h3 id="5-迭代器链"><a href="#5-迭代器链" class="headerlink" title="5. 迭代器链"></a>5. 迭代器链</h3><p>上一节中分析了 Block 的迭代器实现，而对一个 Sorted Table 来说，还需要其他几种迭代器共同组成迭代器链，以高效地完成对 Sorted Table 的遍历和查找。首先来看 <code>IteratorWrapper</code> 的实现 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/table/iterator_wrapper.h"><code>table/iterator_wrapper</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A internal wrapper class with an interface similar to Iterator that</span></span><br><span class="line"><span class="comment">// caches the valid() and key() results for an underlying iterator.</span></span><br><span class="line"><span class="comment">// This can help avoid virtual function calls and also gives better</span></span><br><span class="line"><span class="comment">// cache locality.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorWrapper</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">IteratorWrapper</span>() : <span class="built_in">iter_</span>(<span class="literal">nullptr</span>), <span class="built_in">valid_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">IteratorWrapper</span><span class="params">(Iterator* iter)</span> : iter_(nullptr) &#123;</span> <span class="built_in">Set</span>(iter); &#125;</span><br><span class="line">  ~<span class="built_in">IteratorWrapper</span>() &#123; <span class="keyword">delete</span> iter_; &#125;</span><br><span class="line">  <span class="function">Iterator* <span class="title">iter</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> iter_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Takes ownership of &quot;iter&quot; and will delete it when destroyed, or</span></span><br><span class="line">  <span class="comment">// when Set() is invoked again.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(Iterator* iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> iter_;</span><br><span class="line">    iter_ = iter;</span><br><span class="line">    <span class="keyword">if</span> (iter_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      valid_ = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">Update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterator interface methods</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> valid_; &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> key_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> iter_-&gt;<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Methods below require iter() != nullptr</span></span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    <span class="keyword">return</span> iter_-&gt;<span class="built_in">status</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">Prev</span>();</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">Seek</span>(k);</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">SeekToFirst</span>();</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">SeekToLast</span>();</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    valid_ = iter_-&gt;<span class="built_in">Valid</span>();</span><br><span class="line">    <span class="keyword">if</span> (valid_) &#123;</span><br><span class="line">      key_ = iter_-&gt;<span class="built_in">key</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Iterator* iter_;</span><br><span class="line">  <span class="keyword">bool</span> valid_;</span><br><span class="line">  Slice key_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代器的简单包装，缓存了 <code>key_</code> 和 <code>valid_</code> 属性。按照注释所说的，可以减少虚函数的调用，并且提供更好的缓存局部性。前者很好理解，后者仍然有些困惑。接着来看二级迭代器 <code>TwoLevelIterator</code> 的实现 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/table/two_level_iterator.cc"><code>table/two_level_iterator.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/table.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;table/block.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;table/format.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;table/iterator_wrapper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Iterator* (*BlockFunction)(<span class="keyword">void</span>*, <span class="keyword">const</span> ReadOptions&amp;, <span class="keyword">const</span> Slice&amp;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoLevelIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TwoLevelIterator</span>(Iterator* index_iter, BlockFunction block_function,</span><br><span class="line">                   <span class="keyword">void</span>* arg, <span class="keyword">const</span> ReadOptions&amp; options);</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">TwoLevelIterator</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> data_iter_.<span class="built_in">Valid</span>(); &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> data_iter_.<span class="built_in">key</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> data_iter_.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// It&#x27;d be nice if status() returned a const Status&amp; instead of a Status</span></span><br><span class="line">    <span class="keyword">if</span> (!index_iter_.<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> index_iter_.<span class="built_in">status</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span> &amp;&amp; !data_iter_.<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> data_iter_.<span class="built_in">status</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> status_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SaveError</span><span class="params">(<span class="keyword">const</span> Status&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status_.<span class="built_in">ok</span>() &amp;&amp; !s.<span class="built_in">ok</span>()) status_ = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SkipEmptyDataBlocksForward</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SkipEmptyDataBlocksBackward</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetDataIterator</span><span class="params">(Iterator* data_iter)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">InitDataBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  BlockFunction block_function_;</span><br><span class="line">  <span class="keyword">void</span>* arg_;</span><br><span class="line">  <span class="keyword">const</span> ReadOptions options_;</span><br><span class="line">  Status status_;</span><br><span class="line">  IteratorWrapper index_iter_;</span><br><span class="line">  IteratorWrapper data_iter_;  <span class="comment">// May be nullptr</span></span><br><span class="line">  <span class="comment">// If data_iter_ is non-null, then &quot;data_block_handle_&quot; holds the</span></span><br><span class="line">  <span class="comment">// &quot;index_value&quot; passed to block_function_ to create the data_iter_.</span></span><br><span class="line">  std::string data_block_handle_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TwoLevelIterator::<span class="built_in">TwoLevelIterator</span>(Iterator* index_iter,</span><br><span class="line">                                   BlockFunction block_function, <span class="keyword">void</span>* arg,</span><br><span class="line">                                   <span class="keyword">const</span> ReadOptions&amp; options)</span><br><span class="line">    : <span class="built_in">block_function_</span>(block_function),</span><br><span class="line">      <span class="built_in">arg_</span>(arg),</span><br><span class="line">      <span class="built_in">options_</span>(options),</span><br><span class="line">      <span class="built_in">index_iter_</span>(index_iter),</span><br><span class="line">      <span class="built_in">data_iter_</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">TwoLevelIterator::~<span class="built_in">TwoLevelIterator</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> </span>&#123;</span><br><span class="line">  index_iter_.<span class="built_in">Seek</span>(target);</span><br><span class="line">  <span class="built_in">InitDataBlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">Seek</span>(target);</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksForward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SeekToFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  index_iter_.<span class="built_in">SeekToFirst</span>();</span><br><span class="line">  <span class="built_in">InitDataBlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">SeekToFirst</span>();</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksForward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SeekToLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  index_iter_.<span class="built_in">SeekToLast</span>();</span><br><span class="line">  <span class="built_in">InitDataBlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">SeekToLast</span>();</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksBackward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">  data_iter_.<span class="built_in">Next</span>();</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksForward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::Prev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">  data_iter_.<span class="built_in">Prev</span>();</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksBackward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SkipEmptyDataBlocksForward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (data_iter_.<span class="built_in">iter</span>() == <span class="literal">nullptr</span> || !data_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="comment">// Move to next block</span></span><br><span class="line">    <span class="keyword">if</span> (!index_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="built_in">SetDataIterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index_iter_.<span class="built_in">Next</span>();</span><br><span class="line">    <span class="built_in">InitDataBlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">SeekToFirst</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SkipEmptyDataBlocksBackward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (data_iter_.<span class="built_in">iter</span>() == <span class="literal">nullptr</span> || !data_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="comment">// Move to next block</span></span><br><span class="line">    <span class="keyword">if</span> (!index_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="built_in">SetDataIterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index_iter_.<span class="built_in">Prev</span>();</span><br><span class="line">    <span class="built_in">InitDataBlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">SeekToLast</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SetDataIterator</span><span class="params">(Iterator* data_iter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) <span class="built_in">SaveError</span>(data_iter_.<span class="built_in">status</span>());</span><br><span class="line">  data_iter_.<span class="built_in">Set</span>(data_iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::InitDataBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!index_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="built_in">SetDataIterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Slice handle = index_iter_.<span class="built_in">value</span>();</span><br><span class="line">    <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        handle.<span class="built_in">compare</span>(data_block_handle_) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// data_iter_ is already constructed with this iterator, so</span></span><br><span class="line">      <span class="comment">// no need to change anything</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Iterator* iter = (*block_function_)(arg_, options_, handle);</span><br><span class="line">      data_block_handle_.<span class="built_in">assign</span>(handle.<span class="built_in">data</span>(), handle.<span class="built_in">size</span>());</span><br><span class="line">      <span class="built_in">SetDataIterator</span>(iter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">NewTwoLevelIterator</span><span class="params">(Iterator* index_iter,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockFunction block_function, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">const</span> ReadOptions&amp; options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TwoLevelIterator</span>(index_iter, block_function, arg, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sorted Table 中存储了多个 Data Block，使用 Index Block 完成对 Data Block 的索引。二级迭代器的第一级 <code>index_iter_</code> 完成对 Index Block 的迭代，第二级 <code>data_iter_</code> 完成对 Data Block 的迭代。遍历时移动 <code>data_iter_</code>，并在 <code>data_iter_</code> 边界的地方使用函数 <code>SkipEmptyDataBlocksForward</code> 和 <code>SkipEmptyDataBlocksBackward</code> 实现 Data Block 的前后切换。查找时同样先在 <code>index_iter_</code> 上查找，Index Block 的每个条目存储了 Data Block 的 <code>max_key</code> 和位置大小信息，可以二分；确定 <code>index_iter_</code> 的位置后再读取对应的 Data Block 进一步二分查找。</p>
<p>总结来看 Sorted Table 使用的迭代器们组成的链路如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TwoLevelIterator -&gt; <span class="built_in">IteratorWrapper</span>(index_iter_) -&gt; Block::Iter</span><br><span class="line">                 -&gt; <span class="built_in">IteratorWrapper</span>(data_iter_) -&gt; Block::Iter</span><br></pre></td></tr></table></figure>

<p>另外还有一个合并迭代器 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/table/merger.cc"><code>MergingIterator</code></a>，将会在多 Sorted Table 文件的遍历中使用到。该迭代器管理 n<em>n</em> 个子迭代器，<code>Next</code> 和 <code>Seek</code> 操作时齐头并进、选择最小的那个，具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergingIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MergingIterator</span>(<span class="keyword">const</span> Comparator* comparator, Iterator** children, <span class="keyword">int</span> n)</span><br><span class="line">      : <span class="built_in">comparator_</span>(comparator),</span><br><span class="line">        <span class="built_in">children_</span>(<span class="keyword">new</span> IteratorWrapper[n]),</span><br><span class="line">        <span class="built_in">n_</span>(n),</span><br><span class="line">        <span class="built_in">current_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">        <span class="built_in">direction_</span>(kForward) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">Set</span>(children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">MergingIterator</span>() <span class="keyword">override</span> &#123; <span class="keyword">delete</span>[] children_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> (current_ != <span class="literal">nullptr</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">SeekToFirst</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">    direction_ = kForward;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">SeekToLast</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FindLargest</span>();</span><br><span class="line">    direction_ = kReverse;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">Seek</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">    direction_ = kForward;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that all children are positioned after key().</span></span><br><span class="line">    <span class="comment">// If we are moving in the forward direction, it is already</span></span><br><span class="line">    <span class="comment">// true for all of the non-current_ children since current_ is</span></span><br><span class="line">    <span class="comment">// the smallest child and key() == current_-&gt;key().  Otherwise,</span></span><br><span class="line">    <span class="comment">// we explicitly position the non-current_ children.</span></span><br><span class="line">    <span class="keyword">if</span> (direction_ != kForward) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">        IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">        <span class="keyword">if</span> (child != current_) &#123;</span><br><span class="line">          child-&gt;<span class="built_in">Seek</span>(<span class="built_in">key</span>());</span><br><span class="line">          <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>() &amp;&amp;</span><br><span class="line">              comparator_-&gt;<span class="built_in">Compare</span>(<span class="built_in">key</span>(), child-&gt;<span class="built_in">key</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">            child-&gt;<span class="built_in">Next</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      direction_ = kForward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current_-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that all children are positioned before key().</span></span><br><span class="line">    <span class="comment">// If we are moving in the reverse direction, it is already</span></span><br><span class="line">    <span class="comment">// true for all of the non-current_ children since current_ is</span></span><br><span class="line">    <span class="comment">// the largest child and key() == current_-&gt;key().  Otherwise,</span></span><br><span class="line">    <span class="comment">// we explicitly position the non-current_ children.</span></span><br><span class="line">    <span class="keyword">if</span> (direction_ != kReverse) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">        IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">        <span class="keyword">if</span> (child != current_) &#123;</span><br><span class="line">          child-&gt;<span class="built_in">Seek</span>(<span class="built_in">key</span>());</span><br><span class="line">          <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">            <span class="comment">// Child is at first entry &gt;= key().  Step back one to be &lt; key()</span></span><br><span class="line">            child-&gt;<span class="built_in">Prev</span>();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Child has no entries &gt;= key().  Position at last entry.</span></span><br><span class="line">            child-&gt;<span class="built_in">SeekToLast</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      direction_ = kReverse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current_-&gt;<span class="built_in">Prev</span>();</span><br><span class="line">    <span class="built_in">FindLargest</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> current_-&gt;<span class="built_in">key</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> current_-&gt;<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    Status status;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      status = children_[i].<span class="built_in">status</span>();</span><br><span class="line">      <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Which direction is the iterator moving?</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> &#123;</span> kForward, kReverse &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindSmallest</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindLargest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We might want to use a heap in case there are lots of children.</span></span><br><span class="line">  <span class="comment">// For now we use a simple array since we expect a very small number</span></span><br><span class="line">  <span class="comment">// of children in leveldb.</span></span><br><span class="line">  <span class="keyword">const</span> Comparator* comparator_;</span><br><span class="line">  IteratorWrapper* children_;</span><br><span class="line">  <span class="keyword">int</span> n_;</span><br><span class="line">  IteratorWrapper* current_;</span><br><span class="line">  Direction direction_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergingIterator::FindSmallest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  IteratorWrapper* smallest = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">    IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">    <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (smallest == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        smallest = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator_-&gt;<span class="built_in">Compare</span>(child-&gt;<span class="built_in">key</span>(), smallest-&gt;<span class="built_in">key</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        smallest = child;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  current_ = smallest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergingIterator::FindLargest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  IteratorWrapper* largest = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n_ - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">    <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (largest == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        largest = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator_-&gt;<span class="built_in">Compare</span>(child-&gt;<span class="built_in">key</span>(), largest-&gt;<span class="built_in">key</span>()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        largest = child;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  current_ = largest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-Table"><a href="#6-Table" class="headerlink" title="6. Table"></a>6. Table</h3><p>最后来看 Sorted Table 的实现 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/table/table.cc"><code>table/table.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Table</span>:</span>:Rep &#123;</span><br><span class="line">  ~<span class="built_in">Rep</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> filter;</span><br><span class="line">    <span class="keyword">delete</span>[] filter_data;</span><br><span class="line">    <span class="keyword">delete</span> index_block;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Options options;</span><br><span class="line">  Status status;</span><br><span class="line">  RandomAccessFile* file;</span><br><span class="line">  <span class="keyword">uint64_t</span> cache_id;</span><br><span class="line">  FilterBlockReader* filter;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* filter_data;</span><br><span class="line"></span><br><span class="line">  BlockHandle metaindex_handle;  <span class="comment">// Handle to metaindex_block: saved from footer</span></span><br><span class="line">  Block* index_block;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Table::Open</span><span class="params">(<span class="keyword">const</span> Options&amp; options, RandomAccessFile* file,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">uint64_t</span> size, Table** table)</span> </span>&#123;</span><br><span class="line">  *table = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &lt; Footer::kEncodedLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;file is too short to be an sstable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> footer_space[Footer::kEncodedLength];</span><br><span class="line">  Slice footer_input;</span><br><span class="line">  Status s = file-&gt;<span class="built_in">Read</span>(size - Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                        &amp;footer_input, footer_space);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">  Footer footer;</span><br><span class="line">  s = footer.<span class="built_in">DecodeFrom</span>(&amp;footer_input);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read the index block</span></span><br><span class="line">  BlockContents index_block_contents;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    ReadOptions opt;</span><br><span class="line">    <span class="keyword">if</span> (options.paranoid_checks) &#123;</span><br><span class="line">      opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="built_in">ReadBlock</span>(file, opt, footer.<span class="built_in">index_handle</span>(), &amp;index_block_contents);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// We&#x27;ve successfully read the footer and the index block: we&#x27;re</span></span><br><span class="line">    <span class="comment">// ready to serve requests.</span></span><br><span class="line">    Block* index_block = <span class="keyword">new</span> <span class="built_in">Block</span>(index_block_contents);</span><br><span class="line">    Rep* rep = <span class="keyword">new</span> Table::Rep;</span><br><span class="line">    rep-&gt;options = options;</span><br><span class="line">    rep-&gt;file = file;</span><br><span class="line">    rep-&gt;metaindex_handle = footer.<span class="built_in">metaindex_handle</span>();</span><br><span class="line">    rep-&gt;index_block = index_block;</span><br><span class="line">    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;<span class="built_in">NewId</span>() : <span class="number">0</span>);</span><br><span class="line">    rep-&gt;filter_data = <span class="literal">nullptr</span>;</span><br><span class="line">    rep-&gt;filter = <span class="literal">nullptr</span>;</span><br><span class="line">    *table = <span class="keyword">new</span> <span class="built_in">Table</span>(rep);</span><br><span class="line">    (*table)-&gt;<span class="built_in">ReadMeta</span>(footer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Table::ReadMeta</span><span class="params">(<span class="keyword">const</span> Footer&amp; footer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;options.filter_policy == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// Do not need any metadata</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(sanjay): Skip this if footer.metaindex_handle() size indicates</span></span><br><span class="line">  <span class="comment">// it is an empty block.</span></span><br><span class="line">  ReadOptions opt;</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;options.paranoid_checks) &#123;</span><br><span class="line">    opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  BlockContents contents;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ReadBlock</span>(rep_-&gt;file, opt, footer.<span class="built_in">metaindex_handle</span>(), &amp;contents).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Do not propagate errors since meta info is not needed for operation</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Block* meta = <span class="keyword">new</span> <span class="built_in">Block</span>(contents);</span><br><span class="line"></span><br><span class="line">  Iterator* iter = meta-&gt;<span class="built_in">NewIterator</span>(<span class="built_in">BytewiseComparator</span>());</span><br><span class="line">  std::string key = <span class="string">&quot;filter.&quot;</span>;</span><br><span class="line">  key.<span class="built_in">append</span>(rep_-&gt;options.filter_policy-&gt;<span class="built_in">Name</span>());</span><br><span class="line">  iter-&gt;<span class="built_in">Seek</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (iter-&gt;<span class="built_in">Valid</span>() &amp;&amp; iter-&gt;<span class="built_in">key</span>() == <span class="built_in">Slice</span>(key)) &#123;</span><br><span class="line">    <span class="built_in">ReadFilter</span>(iter-&gt;<span class="built_in">value</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  <span class="keyword">delete</span> meta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Table::ReadFilter</span><span class="params">(<span class="keyword">const</span> Slice&amp; filter_handle_value)</span> </span>&#123;</span><br><span class="line">  Slice v = filter_handle_value;</span><br><span class="line">  BlockHandle filter_handle;</span><br><span class="line">  <span class="keyword">if</span> (!filter_handle.<span class="built_in">DecodeFrom</span>(&amp;v).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We might want to unify with ReadBlock() if we start</span></span><br><span class="line">  <span class="comment">// requiring checksum verification in Table::Open.</span></span><br><span class="line">  ReadOptions opt;</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;options.paranoid_checks) &#123;</span><br><span class="line">    opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  BlockContents block;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ReadBlock</span>(rep_-&gt;file, opt, filter_handle, &amp;block).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (block.heap_allocated) &#123;</span><br><span class="line">    rep_-&gt;filter_data = block.data.<span class="built_in">data</span>();  <span class="comment">// Will need to delete later</span></span><br><span class="line">  &#125;</span><br><span class="line">  rep_-&gt;filter = <span class="keyword">new</span> <span class="built_in">FilterBlockReader</span>(rep_-&gt;options.filter_policy, block.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Table::~<span class="built_in">Table</span>() &#123; <span class="keyword">delete</span> rep_; &#125;</span><br></pre></td></tr></table></figure>

<p>开始部分依然是熟悉的 <code>pImpl</code> 范式，毕竟 <code>Table</code> 是对外的接口，需要保持稳定。<code>Table::Open</code> 时，首先读取文件尾部的 <code>Footer</code>，根据 <code>Footer::index_handle()</code> 读取 <code>index_block</code> 到内存中，并按需读取 <code>meta_block</code> 和 <code>filter</code>；这些析构时也会做对应的删除。接着看迭代器部分的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteCachedBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value)</span> </span>&#123;</span><br><span class="line">  Block* block = <span class="keyword">reinterpret_cast</span>&lt;Block*&gt;(value);</span><br><span class="line">  <span class="keyword">delete</span> block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReleaseBlock</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">void</span>* h)</span> </span>&#123;</span><br><span class="line">  Cache* cache = <span class="keyword">reinterpret_cast</span>&lt;Cache*&gt;(arg);</span><br><span class="line">  Cache::Handle* handle = <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(h);</span><br><span class="line">  cache-&gt;<span class="built_in">Release</span>(handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert an index iterator value (i.e., an encoded BlockHandle)</span></span><br><span class="line"><span class="comment">// into an iterator over the contents of the corresponding block.</span></span><br><span class="line"><span class="function">Iterator* <span class="title">Table::BlockReader</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> Slice&amp; index_value)</span> </span>&#123;</span><br><span class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;Table*&gt;(arg);</span><br><span class="line">  Cache* block_cache = table-&gt;rep_-&gt;options.block_cache;</span><br><span class="line">  Block* block = <span class="literal">nullptr</span>;</span><br><span class="line">  Cache::Handle* cache_handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  BlockHandle handle;</span><br><span class="line">  Slice input = index_value;</span><br><span class="line">  Status s = handle.<span class="built_in">DecodeFrom</span>(&amp;input);</span><br><span class="line">  <span class="comment">// We intentionally allow extra stuff in index_value so that we</span></span><br><span class="line">  <span class="comment">// can add more features in the future.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    BlockContents contents;</span><br><span class="line">    <span class="keyword">if</span> (block_cache != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> cache_key_buffer[<span class="number">16</span>];</span><br><span class="line">      <span class="built_in">EncodeFixed64</span>(cache_key_buffer, table-&gt;rep_-&gt;cache_id);</span><br><span class="line">      <span class="built_in">EncodeFixed64</span>(cache_key_buffer + <span class="number">8</span>, handle.<span class="built_in">offset</span>());</span><br><span class="line">      <span class="function">Slice <span class="title">key</span><span class="params">(cache_key_buffer, <span class="keyword">sizeof</span>(cache_key_buffer))</span></span>;</span><br><span class="line">      cache_handle = block_cache-&gt;<span class="built_in">Lookup</span>(key);</span><br><span class="line">      <span class="keyword">if</span> (cache_handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        block = <span class="keyword">reinterpret_cast</span>&lt;Block*&gt;(block_cache-&gt;<span class="built_in">Value</span>(cache_handle));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = <span class="built_in">ReadBlock</span>(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          block = <span class="keyword">new</span> <span class="built_in">Block</span>(contents);</span><br><span class="line">          <span class="keyword">if</span> (contents.cachable &amp;&amp; options.fill_cache) &#123;</span><br><span class="line">            cache_handle = block_cache-&gt;<span class="built_in">Insert</span>(key, block, block-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                               &amp;DeleteCachedBlock);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = <span class="built_in">ReadBlock</span>(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        block = <span class="keyword">new</span> <span class="built_in">Block</span>(contents);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Iterator* iter;</span><br><span class="line">  <span class="keyword">if</span> (block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    iter = block-&gt;<span class="built_in">NewIterator</span>(table-&gt;rep_-&gt;options.comparator);</span><br><span class="line">    <span class="keyword">if</span> (cache_handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      iter-&gt;<span class="built_in">RegisterCleanup</span>(&amp;DeleteBlock, block, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iter-&gt;<span class="built_in">RegisterCleanup</span>(&amp;ReleaseBlock, block_cache, cache_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iter = <span class="built_in">NewErrorIterator</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">Table::NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NewTwoLevelIterator</span>(</span><br><span class="line">      rep_-&gt;index_block-&gt;<span class="built_in">NewIterator</span>(rep_-&gt;options.comparator),</span><br><span class="line">      &amp;Table::BlockReader, <span class="keyword">const_cast</span>&lt;Table*&gt;(<span class="keyword">this</span>), options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Table::NewIterator</code> 中会构造一个二级迭代器，第一级自然是 <code>index_block</code> 的迭代器，并且提供了第二级迭代器的创建函数 <code>Table::BlockReader</code>。该函数的第一个参数实际上为 <code>Table</code> 对象的指针，第三个参数是 <code>index_block</code> 键值对中的 <code>Value</code>，也就是对应的 Data Block Handle。如果不考虑缓存部分，代码还是很容易理解的：首先解析对应的 <code>BlockHandle</code>，据此读取 <code>block</code>，创建迭代器并且注册迭代器清理函数 <code>DeleteBlock</code>，当删除迭代器时删除对应的 <code>block</code>。当考虑缓存时，可以回忆下系列第一篇介绍的 <code>LRUCache</code> 再来看代码：使用 <code>cache_id</code> 和 <code>handle.offset</code> 构建一个缓存的 <code>Key</code>，将 <code>block</code> 作为缓存的 <code>Value</code>，后者的清理函数为 <code>DeleteCachedBlock</code>；当前使用 <code>block</code> 创建迭代器增加了 <code>block</code> 的引用计数，当迭代器析构时需要调用 <code>ReleaseBlock</code> 以减少缓存的 <code>block</code> 的引用计数。这样就非常合理且高效了。</p>
<h3 id="7-Table-Cache"><a href="#7-Table-Cache" class="headerlink" title="7. Table Cache"></a>7. Table Cache</h3><p>LevelDB 中会使用 <code>file_number</code> 给 Sorted Table 编号。为了提高读取性能、简化使用，LevelDB 提供了 <code>TableCache</code> 用以缓存 Sorted Table 及对应的 <code>.ldb</code> 文件，定义于 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/db/table_cache.h"><code>db/table_cache.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableCache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TableCache</span>(<span class="keyword">const</span> std::string&amp; dbname, <span class="keyword">const</span> Options&amp; options, <span class="keyword">int</span> entries);</span><br><span class="line">  ~<span class="built_in">TableCache</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an iterator for the specified file number (the corresponding</span></span><br><span class="line">  <span class="comment">// file length must be exactly &quot;file_size&quot; bytes).  If &quot;tableptr&quot; is</span></span><br><span class="line">  <span class="comment">// non-null, also sets &quot;*tableptr&quot; to point to the Table object</span></span><br><span class="line">  <span class="comment">// underlying the returned iterator, or to nullptr if no Table object</span></span><br><span class="line">  <span class="comment">// underlies the returned iterator.  The returned &quot;*tableptr&quot; object is owned</span></span><br><span class="line">  <span class="comment">// by the cache and should not be deleted, and is valid for as long as the</span></span><br><span class="line">  <span class="comment">// returned iterator is live.</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">uint64_t</span> file_size, Table** tableptr = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a seek to internal key &quot;k&quot; in specified file finds an entry,</span></span><br><span class="line">  <span class="comment">// call (*handle_result)(arg, found_key, found_value).</span></span><br><span class="line">  <span class="function">Status <span class="title">Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">uint64_t</span> file_size, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;, <span class="keyword">const</span> Slice&amp;))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Evict any entry for the specified file number</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Evict</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">Status <span class="title">FindTable</span><span class="params">(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size, Cache::Handle**)</span></span>;</span><br><span class="line"></span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> std::string dbname_;</span><br><span class="line">  <span class="keyword">const</span> Options&amp; options_;</span><br><span class="line">  Cache* cache_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>核心接口 <code>TableCache::NewIterator</code>，只需要提供 <code>file_number</code> 和 <code>file_size</code>，就可以返回对应的 Sorted Table 对象及其迭代器。TableCache 封装了缓存和清理的逻辑，其实现也非常简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TableAndFile</span> &#123;</span></span><br><span class="line">  RandomAccessFile* file;</span><br><span class="line">  Table* table;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteEntry</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value)</span> </span>&#123;</span><br><span class="line">  TableAndFile* tf = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(value);</span><br><span class="line">  <span class="keyword">delete</span> tf-&gt;table;</span><br><span class="line">  <span class="keyword">delete</span> tf-&gt;file;</span><br><span class="line">  <span class="keyword">delete</span> tf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnrefEntry</span><span class="params">(<span class="keyword">void</span>* arg1, <span class="keyword">void</span>* arg2)</span> </span>&#123;</span><br><span class="line">  Cache* cache = <span class="keyword">reinterpret_cast</span>&lt;Cache*&gt;(arg1);</span><br><span class="line">  Cache::Handle* h = <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(arg2);</span><br><span class="line">  cache-&gt;<span class="built_in">Release</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TableCache::<span class="built_in">TableCache</span>(<span class="keyword">const</span> std::string&amp; dbname, <span class="keyword">const</span> Options&amp; options,</span><br><span class="line">                       <span class="keyword">int</span> entries)</span><br><span class="line">    : <span class="built_in">env_</span>(options.env),</span><br><span class="line">      <span class="built_in">dbname_</span>(dbname),</span><br><span class="line">      <span class="built_in">options_</span>(options),</span><br><span class="line">      <span class="built_in">cache_</span>(<span class="built_in">NewLRUCache</span>(entries)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">TableCache::~<span class="built_in">TableCache</span>() &#123; <span class="keyword">delete</span> cache_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TableCache::FindTable</span><span class="params">(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Cache::Handle** handle)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="built_in"><span class="keyword">sizeof</span></span>(file_number)];</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(buf, file_number);</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">(buf, <span class="keyword">sizeof</span>(buf))</span></span>;</span><br><span class="line">  *handle = cache_-&gt;<span class="built_in">Lookup</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (*handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    std::string fname = <span class="built_in">TableFileName</span>(dbname_, file_number);</span><br><span class="line">    RandomAccessFile* file = <span class="literal">nullptr</span>;</span><br><span class="line">    Table* table = <span class="literal">nullptr</span>;</span><br><span class="line">    s = env_-&gt;<span class="built_in">NewRandomAccessFile</span>(fname, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      std::string old_fname = <span class="built_in">SSTTableFileName</span>(dbname_, file_number);</span><br><span class="line">      <span class="keyword">if</span> (env_-&gt;<span class="built_in">NewRandomAccessFile</span>(old_fname, &amp;file).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        s = Status::<span class="built_in">OK</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = Table::<span class="built_in">Open</span>(options_, file, file_size, &amp;table);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(table == <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">delete</span> file;</span><br><span class="line">      <span class="comment">// We do not cache error results so that if the error is transient,</span></span><br><span class="line">      <span class="comment">// or somebody repairs the file, we recover automatically.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TableAndFile* tf = <span class="keyword">new</span> TableAndFile;</span><br><span class="line">      tf-&gt;file = file;</span><br><span class="line">      tf-&gt;table = table;</span><br><span class="line">      *handle = cache_-&gt;<span class="built_in">Insert</span>(key, tf, <span class="number">1</span>, &amp;DeleteEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">TableCache::NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Table** tableptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *tableptr = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  Status s = <span class="built_in">FindTable</span>(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewErrorIterator</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;<span class="built_in">Value</span>(handle))-&gt;table;</span><br><span class="line">  Iterator* result = table-&gt;<span class="built_in">NewIterator</span>(options);</span><br><span class="line">  result-&gt;<span class="built_in">RegisterCleanup</span>(&amp;UnrefEntry, cache_, handle);</span><br><span class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *tableptr = table;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TableCache::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">uint64_t</span> file_size, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="keyword">const</span> Slice&amp;))</span> </span>&#123;</span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  Status s = <span class="built_in">FindTable</span>(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    Table* t = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;<span class="built_in">Value</span>(handle))-&gt;table;</span><br><span class="line">    s = t-&gt;<span class="built_in">InternalGet</span>(options, k, arg, handle_result);</span><br><span class="line">    cache_-&gt;<span class="built_in">Release</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableCache::Evict</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="built_in"><span class="keyword">sizeof</span></span>(file_number)];</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(buf, file_number);</span><br><span class="line">  cache_-&gt;<span class="built_in">Erase</span>(<span class="built_in">Slice</span>(buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TableCache::FindTable</code> 中会根据 <code>file_number</code> 构建缓存的 Key，首先尝试在缓存中查找，如果找不到则手动的打开文件、构造 Table。对应迭代器的实现也很简单，只需要设定好对应的清理函数 <code>DeleteEntry</code> 和 <code>UnrefEntry</code>，就可以放心使用了。每多加一层封装，就多屏蔽一分底层实现的细节，对使用者来说就更易用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前后两篇完成了对 Sorted Table 代码的阅读和分析。当数据位于内存时，查找过程中随机访问的时间微乎其微；但当数据保存到硬盘后，将 Sorted Table 载入内存的 IO 时间就非常可观了。Sorted Table 使用多级迭代器来缓和这个问题，首先完整地读取了 Index Block 到内存中；进行查找时首先在 Index Block 上二分，确定 Data Block 的位置后再进行必要的 IO 读取，并且通过缓存 Data Block 的方式提升读取的性能。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LevelDB/" rel="tag">LevelDB</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-LevelDB源码分析——6.Sorted String Table"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%946.Sorted%20String%20Table/"
    >LevelDB源码分析——6.Sorted String Table</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%946.Sorted%20String%20Table/" class="article-date">
  <time datetime="2022-02-10T05:30:30.000Z" itemprop="datePublished">2022-02-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/LevelDB/">LevelDB</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="六-Sorted-String-Table"><a href="#六-Sorted-String-Table" class="headerlink" title="六.Sorted String Table"></a>六.Sorted String Table</h2><p>本系列的上一篇介绍了内存数据库，并且提到了内存数据库的大小限制问题。当内存数据块占用的内存达到阈值时（LevelDB 默认 4MB），会将当前的内存数据库 <code>mem_</code> 转为不可修改的 <code>imm_</code>，并且为 <code>mem_</code> 赋值一个新的内存数据库。这使得内存数据库的大小始终保持在阈值以下，同时保持着超高的读写性能。而不可修改的 <code>imm_</code> 会经历Compaction 过程，转为 Sorted Table 存储到磁盘中。本篇将详细阐述该过程。</p> 
      <a class="article-more-link" href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%946.Sorted%20String%20Table/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LevelDB/" rel="tag">LevelDB</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-LevelDB源码分析——5.不同的主键Key类型"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%945.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%B8%BB%E9%94%AEKey%E7%B1%BB%E5%9E%8B/"
    >LevelDB源码分析——5.不同的主键Key类型</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%945.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%B8%BB%E9%94%AEKey%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time datetime="2022-02-10T02:30:30.000Z" itemprop="datePublished">2022-02-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/LevelDB/">LevelDB</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="五-不同的主键Key类型"><a href="#五-不同的主键Key类型" class="headerlink" title="五.不同的主键Key类型"></a>五.不同的主键Key类型</h2><p>本系列的前两篇介绍了LevelDB高性能写操作的核心：日志与内存数据库。</p>
<p>在阅读LevelDB的源码时，往往能看到这样的参数传递：<code>Slice key</code> ,<code>const char* key</code>,<code>Key key</code>等等</p>
<p>他们都有相同的参数名，但有时代表的key却不一定相同。</p>
<p>在skiplist.h中, 能看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Insert(const Key&amp; key); </span><br></pre></td></tr></table></figure>

<p>在memtable.h中，能看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Add(SequenceNumber seq,ValueType type, const Slice&amp; key, const Slice&amp; value); </span><br></pre></td></tr></table></figure>

<p>在block_builder.h中，能看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Add(const Slice&amp; key,const Slice&amp; value); </span><br></pre></td></tr></table></figure>

<p>在table_builder.h中，能看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Add(const Slice&amp; key,const Slice&amp; value); </span><br></pre></td></tr></table></figure>

<p>实际上，LevelDB中一共有五种key的概念，分别是UserKey、InternalKey、ParsedInternalKey、LookupKey、MemtableKey。</p>
<p>其中用户输入的key即为UserKey，在各个函数的传递过程中，经过各种各样的处理，很难弄清楚现在拿到的key是什么。通过梳理sstable的插入和查询过程中，key的变化过程，分析清楚各种key的作用。</p>
<p><img src="https://l1nfp.github.io/assets/img/posts/LevelDB5keys.png" alt="LevelDB5keys.png"></p>
<h3 id="UserKey"><a href="#UserKey" class="headerlink" title="UserKey"></a>UserKey</h3><p>从最简单的入手，我们先弄清楚UserKey</p>
<p>前面已经提到过用户输入的key即为UserKey，例如，用户输入k/v对，key1:value1 ,则key1即为UserKey ，在leveldb中，是以Slice类型传入</p>
<p>Slice user_key;</p>
<h3 id="InternalKey"><a href="#InternalKey" class="headerlink" title="InternalKey"></a>InternalKey</h3><p>InternalKey是将user_key按一定规则编码后得到的字符串</p>
<ul>
<li>Seq用于表示记录插入的顺序</li>
<li>Type用于表示记录的类型，目前取值只有两种kTypeDeletion表示记录被删除，kTypeValue表示记录有效</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ValueType</span> &#123;</span> kTypeDeletion = <span class="number">0x0</span>, kTypeValue = <span class="number">0x1</span> &#125;; </span><br></pre></td></tr></table></figure>

<p>Seq占7B，Type占1B通过下面的函数打包</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">PackSequenceAndType</span><span class="params">(<span class="keyword">uint64_t</span> seq, ValueType t)</span> </span>&#123;    </span><br><span class="line">	<span class="built_in">assert</span>(seq &lt;= kMaxSequenceNumber);    </span><br><span class="line">	<span class="built_in">assert</span>(t &lt;= kValueTypeForSeek);    </span><br><span class="line">	<span class="keyword">return</span> (seq &lt;&lt; <span class="number">8</span>) | t; </span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<p>打包后拼接到user_key_bytes后面即构成了InternalKey</p>
<h3 id="ParsedInternalKey"><a href="#ParsedInternalKey" class="headerlink" title="ParsedInternalKey"></a>ParsedInternalKey</h3><p>ParsedInternalKey将字符串InternalKey解析为一个结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ParsedInternalKey</span> &#123;</span>    </span><br><span class="line">	Slice user_key;    </span><br><span class="line">	SequenceNumber sequence&#123;&#125;;    </span><br><span class="line">	ValueType type;     </span><br><span class="line">	<span class="built_in">ParsedInternalKey</span>() = <span class="keyword">default</span>;  <span class="comment">// Intentionally left uninitialized (for speed)    </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ParsedInternalKey</span>(<span class="keyword">const</span> Slice&amp; u, <span class="keyword">const</span> SequenceNumber&amp; seq, ValueType t)  : <span class="built_in">user_key</span>(u), <span class="built_in">sequence</span>(seq), <span class="built_in">type</span>(t) &#123;&#125; &#125;; </span><br></pre></td></tr></table></figure>

<p>补上了ParsedInternalKey的概念后，就能看懂InternalKey的所有代码了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AppendInternalKey</span><span class="params">(std::string *result, <span class="keyword">const</span> ParsedInternalKey &amp;key)</span> </span>&#123;    </span><br><span class="line">	result-&gt;<span class="built_in">append</span>(key.user_key.<span class="built_in">data</span>(), key.user_key.<span class="built_in">size</span>());    </span><br><span class="line">	<span class="built_in">PutFixed64</span>(result, <span class="built_in">PackSequenceAndType</span>(key.sequence, key.type)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InternalKey</span> &#123;</span> </span><br><span class="line">	<span class="keyword">private</span>:    </span><br><span class="line">		std::string rep_; </span><br><span class="line">	<span class="keyword">public</span>:    </span><br><span class="line">		<span class="built_in">InternalKey</span>() = <span class="keyword">default</span>;  <span class="comment">// Leave rep_ as empty to indicate it is invalid    </span></span><br><span class="line">		<span class="built_in">InternalKey</span>(<span class="keyword">const</span> Slice&amp; user_key, SequenceNumber s, ValueType t) &#123;        </span><br><span class="line">			<span class="built_in">AppendInternalKey</span>(&amp;rep_, <span class="built_in">ParsedInternalKey</span>(user_key, s, t));    </span><br><span class="line">		&#125;     </span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">DecodeFrom</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123;        </span><br><span class="line">			rep_.<span class="built_in">assign</span>(s.<span class="built_in">data</span>(), s.<span class="built_in">size</span>());        </span><br><span class="line">			<span class="keyword">return</span> !rep_.<span class="built_in">empty</span>();    </span><br><span class="line">		&#125;     </span><br><span class="line">		<span class="function">Slice <span class="title">Encode</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;        </span><br><span class="line">			<span class="built_in">assert</span>(!rep_.<span class="built_in">empty</span>());        </span><br><span class="line">			<span class="keyword">return</span> rep_;    </span><br><span class="line">		&#125;     </span><br><span class="line">		<span class="function">Slice <span class="title">user_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">ExtractUserKey</span>(rep_); </span><br><span class="line">		&#125;     </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">SetFrom</span><span class="params">(<span class="keyword">const</span> ParsedInternalKey&amp; p)</span> </span>&#123;        </span><br><span class="line">			rep_.<span class="built_in">clear</span>();        </span><br><span class="line">			<span class="built_in">AppendInternalKey</span>(&amp;rep_, p);    </span><br><span class="line">		&#125;    </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123; rep_.<span class="built_in">clear</span>(); &#125; &#125;; </span><br></pre></td></tr></table></figure>

<h3 id="LookupKey-amp-amp-MemtableKey"><a href="#LookupKey-amp-amp-MemtableKey" class="headerlink" title="LookupKey&amp;&amp;MemtableKey"></a>LookupKey&amp;&amp;MemtableKey</h3><p>下面是源码中给出的注释</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemTable::Add</span><span class="params">(SequenceNumber s, ValueType type, <span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">// Format of an entry is concatenation of:  </span></span><br><span class="line">	<span class="comment">//  key_size     : varint32 of internal_key.size()  </span></span><br><span class="line">	<span class="comment">//  key bytes    : char[internal_key.size()]  </span></span><br><span class="line">	<span class="comment">//  value_size   : varint32 of value.size()  </span></span><br><span class="line">	<span class="comment">//  value bytes  : char[value.size()]  ...... &#125; </span></span><br></pre></td></tr></table></figure>

<p>我们可以看到：在InternalKey的头部拼接上InternalKey的长度，即构成MemtableKey。</p>
<p>LookupKey和MemtableKey格式一致，用于查找。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LevelDB/" rel="tag">LevelDB</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-LevelDB源码分析——4.内存数据库"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/09/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%944.%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"
    >LevelDB源码分析——4.内存数据库</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/09/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%944.%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time datetime="2022-02-09T13:30:30.000Z" itemprop="datePublished">2022-02-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/LevelDB/">LevelDB</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="四-内存数据库"><a href="#四-内存数据库" class="headerlink" title="四.内存数据库"></a>四.内存数据库</h2><p>本系列的上一篇介绍了 LevelDB 写操作中构造的 <code>WriteBatch</code>，以及写操作的第一步：追加日志。本篇将继续介绍写操作的第二步：插入内存数据库。</p> 
      <a class="article-more-link" href="/2022/02/09/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%944.%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LevelDB/" rel="tag">LevelDB</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-LevelDB源码分析——3.日志"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/09/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%943.%E6%97%A5%E5%BF%97/"
    >LevelDB源码分析——3.日志</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/09/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%943.%E6%97%A5%E5%BF%97/" class="article-date">
  <time datetime="2022-02-09T10:40:25.000Z" itemprop="datePublished">2022-02-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/LevelDB/">LevelDB</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="三-日志"><a href="#三-日志" class="headerlink" title="三.日志"></a>三.日志</h2><p>本系列的<a href="https://gasolly.github.io/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AD/">前两篇</a>介绍了 LevelDB 中使用的数据结构，并没有牵涉到 LevelDB 的核心实现。接下来的几篇将着重介绍 LevelDB 核心组件，包括日志、内存数据库、SortedTable、Compaction 和版本管理。本篇着重阐述高性能写操作的核心：日志和内存数据库。</p>
<p>怎样最快地把键值对存起来？不考虑查找的速度的话，追加地写入文件是最快的，查找时反向查找。举个例子🌰：</p> 
      <a class="article-more-link" href="/2022/02/09/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%943.%E6%97%A5%E5%BF%97/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LevelDB/" rel="tag">LevelDB</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-LevelDB源码分析——2.基本的数据结构续 (copy)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AD%20(copy)/"
    >LevelDB源码分析——2.基本的数据结构续</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AD%20(copy)/" class="article-date">
  <time datetime="2022-02-07T04:40:15.000Z" itemprop="datePublished">2022-02-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/LevelDB/">LevelDB</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="二-基本的数据结构续"><a href="#二-基本的数据结构续" class="headerlink" title="二.基本的数据结构续"></a>二.基本的数据结构续</h2><p>本系列的<a href="https://gasolly.github.io/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">上一篇</a>介绍了 <code>LevelDB</code> 中的 <code>Slice</code>、<code>Hash</code> 和 <code>LRUCache</code> 的实现，这一篇将继续分析布隆过滤器、内存池和跳表。</p> 
      <a class="article-more-link" href="/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AD%20(copy)/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LevelDB/" rel="tag">LevelDB</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-LevelDB源码分析——1.基本的数据结构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
    >LevelDB源码分析——1.基本的数据结构</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2022-02-07T04:08:41.000Z" itemprop="datePublished">2022-02-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/LevelDB/">LevelDB</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一．基本的数据结构"><a href="#一．基本的数据结构" class="headerlink" title="一．基本的数据结构"></a>一．基本的数据结构</h2><p>为了督促自己认真的阅读LevelDB源码，同时记录下相关的收获，避免阅后即忘，因此在Blog中记录下LevelDB源码分析的相关内容。</p>
<p>本文会介绍 LevelDB 中的基本数据结构，包括 <code>Slice</code>、<code>Hash</code>、<code>LRUCache</code>。</p> 
      <a class="article-more-link" href="/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LevelDB/" rel="tag">LevelDB</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2022
        <i class="ri-heart-fill heart_icon"></i> Xufei Pan
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://v1.cnzz.com/z_stat.php?id=1280023895&amp;web_id=1280023895'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Gasol"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">目录</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/photos/">图片</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2021/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯奶茶吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
</body>

</html>