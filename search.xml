<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2021/06/17/About-Me/</url>
    <content><![CDATA[<blockquote>
<p>Done is better than perfect.</p>
</blockquote>
<p>姓名：潘许飞 - Gasol</p>
<p>学习/工作：HUST - WNLO</p>
<p>邮箱：<a href="mailto:&#49;&#49;&#x34;&#x32;&#x38;&#49;&#50;&#53;&#x32;&#x35;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#109;">&#49;&#49;&#x34;&#x32;&#x38;&#49;&#50;&#53;&#x32;&#x35;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#109;</a></p>
<p><img src="https://pic.imgdb.cn/item/60cb0de4844ef46bb21f61a5.jpg"></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>SPDK调研</title>
    <url>/2021/06/17/SPDK%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="一．SPDK简介"><a href="#一．SPDK简介" class="headerlink" title="一．SPDK简介"></a>一．SPDK简介</h2><h3 id="1-SPDK的起源"><a href="#1-SPDK的起源" class="headerlink" title="1.SPDK的起源"></a>1.SPDK的起源</h3><p>固态存储设备正在取代数据中心。目前这一代的闪存存储，比起传统的磁盘设备，在性能（performance）、功耗（power consumption）和机架密度（rack density）上具有显著的优势。这些优势将会继续增大，使闪存存储作为下一代存储设备进入市场。</p>
<p>用户使用现在的固态设备，比如Intel® SSD DC P3700 Series Non-Volatile Memory Express（NVMe）驱动，面临一个主要的挑战：因为吞吐量和延迟性能比传统的磁盘好太多，现在总的处理时间中，存储软件占用了更大的比例。换句话说，存储软件栈的性能和效率在整个存储系统中越来越重要。随着存储设备继续发展，它将面临远远超过正在使用的软件体系结构的风险（即存储设备受制于相关软件的不足而不能发挥全部性能），在接下来的几年中，存储设备将会继续发展到一个令人难以置信的地步。</p>
<p>为了帮助存储OEM（设备代工厂）和ISV（独立软件开发商）整合硬件，Intel构造了一系列驱动，以及一个完善的、端对端的参考存储体系结构，被命名为Storage Performance Development Kit（SPDK）。SPDK的目标是通过同时使用Intel的网络技术，处理技术和存储技术来提高突出显著的效率和性能。通过运行为硬件设计的软件，SPDK已经证明很容易达到每秒钟数百万次I/O读取，通过使用许多处理器核心和许多NVMe驱动去存储，而不需要额外卸载硬件。Intel在BSD license许可协议下通过Github分发提供其全部的Linux参考架构的源代码。博客、邮件列表和额外文档可以在spdk.io中找到。</p>
<span id="more"></span>
<h3 id="2-SPDK的整体架构"><a href="#2-SPDK的整体架构" class="headerlink" title="2.SPDK的整体架构"></a>2.SPDK的整体架构</h3><p>下图为SPDK的整体架构图：</p>
<p><img src="https://pic.imgdb.cn/item/60cb0904844ef46bb2ee63d9.png" alt="SPDK架构图"></p>
<p>按照自底层向上层的顺序，分为：</p>
<ul>
<li><p>硬件驱动</p>
<blockquote>
<p>NVMe Driver：SPDK的基础组件，这个高优化无锁的驱动提供了高扩展性，高效性和高性能。</p>
</blockquote>
<blockquote>
<p>Inter QuickData Technology：也称为Intel I/O Acceleration Technology（Inter IOAT，英特尔I/O加速技术），这是一种基于Xeon处理器平台上的copy offload引擎。通过提供用户空间访问，减少了DMA数据移动的阈值，允许对小尺寸I/O或NTB的更好利用。</p>
</blockquote>
</li>
<li><p>后端块设备</p>
<blockquote>
<p>NVMe over Fabrics（NVMe-oF）initiator：从程序员的角度来看，本地SPDK NVMe驱动和NVMe-oF启动器共享一套共同的API命令。这意味着，本地/远程复制非常容易实现。</p>
</blockquote>
<blockquote>
<p>Ceph RADOS Block Device（RBD）：使Ceph成为SPDK的后端设备，比如这可能允许Ceph用作另一个存储层。</p>
</blockquote>
<blockquote>
<p>Blobstore Block Device：由SPDK Blobstore分配的块设备，是虚拟机或数据库可以与之交互的虚拟设备。这些设备享有SPDK基础架构的优势，这意味着零锁定和令人难以置信的可扩展性能。</p>
</blockquote>
<blockquote>
<p>Linux Asynchrounous I/O（AIO）：允许SPDK与内核设备（比如机械硬盘）交互。</p>
</blockquote>
</li>
<li><p>存储服务</p>
<blockquote>
<p>Block device abstration layer（bdev）：这种通用的块设备抽象是连接到各种不同设备驱动和块设备的存储协议的粘合剂。还在块层中提供灵活的API用于额外的用户功能（磁盘阵列，压缩，去冗等等）。</p>
</blockquote>
<blockquote>
<p>Blobstore：为SPDK实现一个高精简的文件式语义（非POSIX）。这可以为数据库，容器，虚拟机或其他不依赖于大部分POSIX文件系统功能集（比如用户访问控制）的工作负载提供高性能基础。</p>
</blockquote>
</li>
<li><p>存储协议</p>
<blockquote>
<p>iSCSI target：建立了通过以太网的块流量规范，大约是内核LIO效率的两倍。现在的版本默认使用内核TCP/IP协议栈。</p>
</blockquote>
<blockquote>
<p>NVMe-oF target：实现了新NVMe-oF规范。虽然这取决于RDMA硬件，NVMe-oF的目标可以为每个CPU核提供高达40Gbps的流量。</p>
</blockquote>
<blockquote>
<p>vhost-scsi target：KVM/QEMU的功能利用了SPDK NVMe驱动，使得访客虚拟机访问存储设备时延迟更低，使得I/O密集型工作负载的整体CPU负载减低。</p>
</blockquote>
</li>
</ul>
<h2 id="二、SPDK的主要优势与关键技术"><a href="#二、SPDK的主要优势与关键技术" class="headerlink" title="二、SPDK的主要优势与关键技术"></a>二、SPDK的主要优势与关键技术</h2><h3 id="1-SPDK的主要优势与关键技术"><a href="#1-SPDK的主要优势与关键技术" class="headerlink" title="1.SPDK的主要优势与关键技术"></a>1.SPDK的主要优势与关键技术</h3><p>SPDK具有的优势主要包括：</p>
<blockquote>
<p>高性能、高拓展性、零拷贝、高度并行的访问、可以从用户空间直接访问SSD。</p>
</blockquote>
<p>SPDK通过使用多种关键技术来实现高性能：</p>
<ul>
<li><p>将所有必要的驱动程序移到用户空间中，这避免了系统调用，并允许从应用程序进行零拷贝访问。</p>
</li>
<li><p>通过轮询硬件来完成而不是依赖中断，这可以降低总延迟和延迟差异。</p>
</li>
<li><p>避免所有在I / O路径中的锁，而是依靠消息传递。</p>
</li>
</ul>
<p>SPDK的基础是用户空间，轮询模式，异步，无锁的NVMe驱动程序。这提供了零拷贝，高度并行的访问，可从用户空间应用程序直接访问SSD。该驱动程序被编写为具有单个公共标头的C库。</p>
<p>SPDK还提供了完整的块堆栈作为用户空间库，该库执行与操作系统中的块堆栈相同的许多操作。这包括统一不同存储设备之间的接口，排队以处理诸如内存不足或I / O挂起之类的情况以及逻辑卷管理。</p>
<p>最后，SPDK在这些组件之上提供了NVMe-oF，iSCSI和虚拟主机服务器，这些服务器能够通过网络或其他进程为磁盘提供服务。用于NVMe-oF和iSCSI的标准Linux内核启动器可与这些目标以及具有vhost的QEMU进行交互。与其他实现相比，这些服务器的CPU效率最高可提高一个数量级。这些目标可以用作如何实现高性能存储目标的示例，也可以用作生产部署的基础。</p>
<p><img src="https://pic.imgdb.cn/item/60cb0920844ef46bb2ef7f97.png" alt="SPDK IO Stack"></p>
<h2 id="三．SPDK关键技术介绍"><a href="#三．SPDK关键技术介绍" class="headerlink" title="三．SPDK关键技术介绍"></a>三．SPDK关键技术介绍</h2><h3 id="1-NVMe-Driver"><a href="#1-NVMe-Driver" class="headerlink" title="1.NVMe Driver"></a>1.NVMe Driver</h3><p>（1）NVMe Driver整体情况介绍</p>
<p>NVMe驱动程序是一个C语言库，可以直接链接到一个应用程序中，该应用程序对外提供与NVMe SSD的直接的、零拷贝数据传输。它是完全被动的，这意味着它不产生任何线程，并且仅响应于来自应用程序本身的函数调用而执行操作。该库通过直接将PCI BAR映射到本地进程并执行MMIO来控制NVMe设备。I / O是通过队列对异步提交的。</p>
<p>最近，对该库进行了改进，使其还可以通过基于Fabric的NVMe连接到远程NVMe设备。用户现在既可以通过本地PCI总线也可以通过NVMe over Fabrics，调用spdk_nvme_probe（），发现设备。</p>
<p>NVMe Driver的公共接口声明于spdk/nvme.h中。主要包括如下命令：</p>
<p><img src="https://pic.imgdb.cn/item/60cb093d844ef46bb2f0a087.png" alt="SPDK NVMe API"></p>
<p>（2）NVMe Driver关于IO提交的设计</p>
<p>NVMe Driver使用nvme_ns_cmd_xxx命令将IO提交到NVMe命名空间。NVMe驱动程序在命令中指定的队列对上将I / O请求作为NVMe提交队列条目提交。函数会立即返回，在IO命令完成之前就已经返回。应用程序必须通过调用<code>spdk_nvme_qpair_process_completions()</code>函数轮询队列对，以接收完成回调。</p>
<p>（3）NVMe Driver对于拓展性的支持</p>
<p>NVMe队列对（结构spdk_nvme_qpair）为I / O提供并行提交路径。I / O可以同时从不同的线程在多个队列对上提交。队列对不包含锁或原子，因此，给定的队列对一次只能由单个线程使用。NVMe驱动程序不强制执行此要求（这样做将需要锁定），并且违反此要求将导致未定义的行为。</p>
<p>允许的队列对数由NVMe SSD本身决定。该规范可以支持数千个，但是大多数设备支持32至128个。该规范不能保证每个队列对的性能，但是实际上，仅使用一个队列对就几乎可以实现设备的全部性能。例如，如果设备声称能够在队列深度128的情况下，每秒达到450,000 I / O，那么实际上驱动程序使用的是4个队列对（每个队列深度为32）还是单个队列对（队列深度为） 128则无关紧要。</p>
<p>鉴于以上所述，使用SPDK的应用程序最简单的线程模型是在池中生成固定数量的线程，并将单个NVMe队列对专用于每个线程。进一步的改进是将每个线程固定到一个单独的CPU内核，并且SPDK文档通常会互换使用“ CPU内核”和“线程”，因为我们牢记了这种线程模型。</p>
<p>NVMe驱动程序不对I / O路径进行任何锁定，因此只要每个新线程专用一个队列对和CPU内核，它就可以根据每个线程的性能进行线性扩展。为了充分利用这种扩展，应用程序应考虑组织其内部数据结构，以便将数据专门分配给单个线程。所有需要数据的操作都应通过向拥有线程发送请求来完成。与锁定体系结构相比，这导致了消息传递体系结构，并且将导致跨CPU内核的出色扩展。</p>
<h2 id="四．参考资料"><a href="#四．参考资料" class="headerlink" title="四．参考资料"></a>四．参考资料</h2><blockquote>
<p>1.Intel官网：《Introduction to the Storage Performance Development Kit (SPDK)》；链接：<a href="https://software.intel.com/content/www/cn/zh/develop/articles/introduction-to-the-storage-performance-development-kit-spdk.html?wapkw=spdk">https://software.intel.com/content/www/cn/zh/develop/articles/introduction-to-the-storage-performance-development-kit-spdk.html?wapkw=spdk</a></p>
</blockquote>
<blockquote>
<p>2.SPDK文档；链接：<a href="https://spdk.io/doc/about.html">https://spdk.io/doc/about.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>SPDK</category>
      </categories>
      <tags>
        <tag>SPDK</tag>
        <tag>OCSSD</tag>
        <tag>用户态IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtual OCSSD 环境搭建</title>
    <url>/2021/06/17/Virtual-OCSSD-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="一、Virtual-OpenChannel-SSD-环境配置"><a href="#一、Virtual-OpenChannel-SSD-环境配置" class="headerlink" title="一、Virtual OpenChannel SSD 环境配置"></a>一、Virtual OpenChannel SSD 环境配置</h2><p>1.下载Qemu-nvme的源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/OpenChannelSSD/qemu-nvme</span><br></pre></td></tr></table></figure>

<p>2.进入qemu-nvme目录下，运行配置脚本，make编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> qemu-nvme</span><br><span class="line">./configure --target-list=x86_64-softmmu --prefix=<span class="variable">$HOME</span>/qemu-nvme</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>3.在完成上述步骤后，开始正式配置环境。首先，在物理机上创建一个ocssd格式的文件，例如ocssd.img。</p>
<blockquote>
<p>（若提示ocssd参数无效等报错，可能是因为实际使用的是物理机内置的qemu-img，而不是qemu-nvme make编译后生成的qemu-img。将下列命令的qemu-img更改为qemu-nvme/qemu-img代替即可。）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-img create -f ocssd -o num_grp=2,num_pu=4,num_chk=60 ocssd.img</span><br></pre></td></tr></table></figure>

<p>4.创建一个文件，作为模拟的磁盘，用来安装linux系统。</p>
<blockquote>
<p>（在物理机上运行qemu虚拟机，虚拟机内加载模拟磁盘的文件与模拟ocssd的文件。最终的实验环境是在qemu虚拟机内部的linux子系统上运行。）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo qemu-img create -f raw /home/gasol/qemu-nvme/ubuntu40.raw 40G</span><br></pre></td></tr></table></figure>

<p>5.下载ubuntu镜像，并在第4步建立的模拟磁盘的文件中，安装ubuntu系统。</p>
<blockquote>
<p>（此时可能会提示qemu-system-x86_64: warning: host doesn’t support requested feature: CPUID.80000001H:ECX.svm [bit 2]。这是正常的，忽略即可。正常情况下，在输出提示信息后，会弹出新的安装窗口，点击安装即可）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-x86_64 -cdrom /home/polarsparc/ubuntu-18.04.1-desktop-amd64.iso -drive format=raw,file=/home/polarsparc/Downloads/VMs/vm-disk-1.raw -enable-kvm -m 2G -name vm-ubuntu-1</span><br></pre></td></tr></table></figure>

<p>6.在物理机系统上，挂载ocssd,并启动虚拟机。</p>
<blockquote>
<p>(注意：使用路径qemu-nvme/bin/下的qemu-system-x86_64运行，而不是采用系统内置的qemu-system-x86_64 )</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./bin/qemu-system-x86_64 -m 8G -enable-kvm ubuntu40.raw -blockdev ocssd,node-name=nvme01,file.driver=file,file.filename=ocssd.img -device nvme,drive=nvme01,serial=deadbeef,id=lnvm -cpu host</span><br></pre></td></tr></table></figure>

<p>7.在第6步虚拟机启动的情况下，利用VNC viewer连接，弹出窗口显示虚拟机运行情况。</p>
<blockquote>
<p>（若提示无vncviewer，安装对应包即可）（命令中连接的IP和端口与第6步的提示IP和端口相同）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vncviewer 127.0.0.1:5900</span><br></pre></td></tr></table></figure>

<p>8.在虚拟机启动后，可以通过运行以下命令，查看是否成功挂载ocssd设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nvme lnvm list</span><br></pre></td></tr></table></figure>

<h2 id="二、SPDK安装配置"><a href="#二、SPDK安装配置" class="headerlink" title="二、SPDK安装配置"></a>二、SPDK安装配置</h2><p>0.参考文档：<a href="https://spdk.io/doc/getting_started.html">https://spdk.io/doc/getting_started.html</a></p>
<p>1.按参考文档Getting started部分运行，即可编译安装SPDK，并可以通过运行<code>build/examples/identify</code>脚本列出系统上有效的NVME设备。</p>
<blockquote>
<p>（通过该脚本可以验证SPDK是否成功识别挂载的虚拟OCSSD）</p>
</blockquote>
<h2 id="三、关于可能遇到的git-clone与git-submodule速度过慢问题的解决方案"><a href="#三、关于可能遇到的git-clone与git-submodule速度过慢问题的解决方案" class="headerlink" title="三、关于可能遇到的git clone与git submodule速度过慢问题的解决方案"></a>三、关于可能遇到的git clone与git submodule速度过慢问题的解决方案</h2><p>0.参考文档：<a href="https://www.cnblogs.com/zhuchengchao/p/12076153.html">https://www.cnblogs.com/zhuchengchao/p/12076153.html</a></p>
<p>1.按照文档中的介绍，通过国内的gitee.com网站进行git clone，可以大幅度提升git clone的速率。</p>
<p>2.对于git submodule速度过慢的问题:</p>
<blockquote>
<p>例如在git clone spdk的代码后，若需要git submodule，只需打开spdk/.gitmodules，将其中需要下载的库通过gitee.com下载到本地，并修改.gitmodules内部的路径即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>QEMU</category>
      </categories>
      <tags>
        <tag>OCSSD</tag>
        <tag>QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/06/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>LevelDB源码分析——1.基本的数据结构</title>
    <url>/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="一．基本的数据结构"><a href="#一．基本的数据结构" class="headerlink" title="一．基本的数据结构"></a>一．基本的数据结构</h2><p>为了督促自己认真的阅读LevelDB源码，同时记录下相关的收获，避免阅后即忘，因此在Blog中记录下LevelDB源码分析的相关内容。</p>
<p>本文会介绍 LevelDB 中的基本数据结构，包括 <code>Slice</code>、<code>Hash</code>、<code>LRUCache</code>。</p>
<span id="more"></span>

<h3 id="1-字符串封装-Slice"><a href="#1-字符串封装-Slice" class="headerlink" title="1. 字符串封装 Slice"></a>1. 字符串封装 Slice</h3><p>Slice 定义于 <a href="https://github.com/google/leveldb/blob/master/include/leveldb/slice.h"><code>include/leveldb/slice.h</code></a>，源码不过百行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Slice is a simple structure containing a pointer into some external</span></span><br><span class="line"><span class="comment">// storage and a size.  The user of a Slice must ensure that the slice</span></span><br><span class="line"><span class="comment">// is not used after the corresponding external storage has been</span></span><br><span class="line"><span class="comment">// deallocated.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Multiple threads can invoke const methods on a Slice without</span></span><br><span class="line"><span class="comment">// external synchronization, but if any of the threads may call a</span></span><br><span class="line"><span class="comment">// non-const method, all threads accessing the same Slice must use</span></span><br><span class="line"><span class="comment">// external synchronization.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STORAGE_LEVELDB_INCLUDE_SLICE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORAGE_LEVELDB_INCLUDE_SLICE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/export.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"><span class="comment">//字符串处理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Slice</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create an empty slice.</span></span><br><span class="line">  <span class="built_in">Slice</span>() : <span class="built_in">data_</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">size_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to d[0,n-1].</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> <span class="keyword">char</span>* d, <span class="keyword">size_t</span> n) : <span class="built_in">data_</span>(d), <span class="built_in">size_</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to the contents of &quot;s&quot;</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> std::string&amp; s) : <span class="built_in">data_</span>(s.<span class="built_in">data</span>()), <span class="built_in">size_</span>(s.<span class="built_in">size</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to s[0,strlen(s)-1]</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s) : <span class="built_in">data_</span>(s), <span class="built_in">size_</span>(<span class="built_in">strlen</span>(s)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Intentionally copyable.</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> Slice&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  Slice&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Slice&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a pointer to the beginning of the referenced data</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the length (in bytes) of the referenced data</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true iff the length of the referenced data is zero</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_ == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the ith byte in the referenced data.</span></span><br><span class="line">  <span class="comment">// REQUIRES: n &lt; size()</span></span><br><span class="line">  <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &lt; <span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> data_[n];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Change this slice to refer to an empty array</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    size_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//移除数据的前n位</span></span><br><span class="line">  <span class="comment">// Drop the first &quot;n&quot; bytes from this slice.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove_prefix</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &lt;= <span class="built_in">size</span>());</span><br><span class="line">    data_ += n;</span><br><span class="line">    size_ -= n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a string that contains the copy of the referenced data.</span></span><br><span class="line">  <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">string</span>(data_, size_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Three-way comparison.  Returns value:</span></span><br><span class="line">  <span class="comment">//   &lt;  0 iff &quot;*this&quot; &lt;  &quot;b&quot;,</span></span><br><span class="line">  <span class="comment">//   == 0 iff &quot;*this&quot; == &quot;b&quot;,</span></span><br><span class="line">  <span class="comment">//   &gt;  0 iff &quot;*this&quot; &gt;  &quot;b&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//判断参数x是否是该slice的前缀</span></span><br><span class="line">  <span class="comment">// Return true iff &quot;x&quot; is a prefix of &quot;*this&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">starts_with</span><span class="params">(<span class="keyword">const</span> Slice&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((size_ &gt;= x.size_) &amp;&amp; (<span class="built_in">memcmp</span>(data_, x.data_, x.size_) == <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//成员变量：data_存储数据地址;size_记录数据长度</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;</span><br><span class="line">  <span class="keyword">size_t</span> size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">return</span></span> ((x.<span class="built_in">size</span>() == y.<span class="built_in">size</span>()) &amp;&amp;</span><br><span class="line">          (<span class="built_in">memcmp</span>(x.<span class="built_in">data</span>(), y.<span class="built_in">data</span>(), x.<span class="built_in">size</span>()) == <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123; <span class="keyword">return</span> !(x == y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Slice::compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> min_len = (size_ &lt; b.size_) ? size_ : b.size_;</span><br><span class="line">  <span class="keyword">int</span> r = <span class="built_in">memcmp</span>(data_, b.data_, min_len);</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size_ &lt; b.size_)</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_ &gt; b.size_)</span><br><span class="line">      r = +<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// STORAGE_LEVELDB_INCLUDE_SLICE_H_</span></span></span><br></pre></td></tr></table></figure>

<p>没有外部依赖，代码也非常清晰易懂。整个定义可以分为四个部分：构造、获取、修改和比较。</p>
<p><strong>构造</strong>：默认构造为空字符串，字符串构造提供了带长度和不带长度，并且支持默认的复制构造函数和赋值操作符（毕竟只有 <code>data_</code> 和 <code>size_</code> 两个属性）。</p>
<p><strong>获取</strong>：获取 <code>Slice</code> 的基本信息，支持导出为 <code>std::string</code>。</p>
<p><strong>修改</strong>：支持 <code>clear</code> 操作字符串清空，也支持 <code>remove_prefix</code> 将指定长度的前缀去除。注意 <code>data_</code> 的类型为 <code>const char *</code>，对应的字符串内容是不可修改的，<code>Slice</code> 只能修改字符串的起始位置。</p>
<p><strong>比较</strong>：<code>Slice::compare</code> 实现了非常严谨的字符串比较，返回 0/1/-1。注意为了提高性能，<code>operator==</code> 并没有直接调用 <code>Slice::compare</code>。</p>
<p>值得注意的是，<code>Slice</code> 本身并没有任何内存管理，仅仅是 C 风格字符串及其长度的封装。</p>
<h3 id="2-哈希函数-Hash"><a href="#2-哈希函数-Hash" class="headerlink" title="2. 哈希函数 Hash"></a>2. 哈希函数 Hash</h3><p>哈希函数定义于 <a href="https://github.com/google/leveldb/blob/master/util/hash.cc"><code>util/hash.[h/cc]</code></a>，源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/hash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/coding.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The FALLTHROUGH_INTENDED macro can be used to annotate implicit fall-through</span></span><br><span class="line"><span class="comment">// between switch labels. The real definition should be provided externally.</span></span><br><span class="line"><span class="comment">// This one is a fallback version for unsupported compilers.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FALLTHROUGH_INTENDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALLTHROUGH_INTENDED \</span></span><br><span class="line"><span class="meta">  do &#123;                       \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次按照四字节长度读取字节流中的数据 w，并使用普通的哈希函数计算哈希值。</span></span><br><span class="line"><span class="comment"> * 计算过程中使用 uint32_t 的自然溢出特性。四字节读取则为了加速，最终可能剩下 3/2/1 个多余的字节，</span></span><br><span class="line"><span class="comment"> * 使用 switch 语句补充计算，以实现最好的性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> n, <span class="keyword">uint32_t</span> seed)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Similar to murmur hash</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> m = <span class="number">0xc6a4a793</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> r = <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* limit = data + n;</span><br><span class="line">  <span class="keyword">uint32_t</span> h = seed ^ (n * m);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick up four bytes at a time</span></span><br><span class="line">  <span class="keyword">while</span> (data + <span class="number">4</span> &lt;= limit) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> w = <span class="built_in">DecodeFixed32</span>(data);</span><br><span class="line">    data += <span class="number">4</span>;</span><br><span class="line">    h += w;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= (h &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick up remaining bytes</span></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (limit - data) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">      FALLTHROUGH_INTENDED;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">      FALLTHROUGH_INTENDED;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">0</span>]);</span><br><span class="line">      h *= m;</span><br><span class="line">      h ^= (h &gt;&gt; r);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p>每次按照四字节长度读取字节流中的数据 <code>w</code>，并使用普通的哈希函数计算哈希值。计算过程中使用 <code>uint32_t</code> 的自然溢出特性。四字节读取则为了加速，最终可能剩下 3/2/1 个多余的字节，使用 <code>switch</code> 语句补充计算，以实现最好的性能。</p>
<p>这里 <code>FALLTHROUGH_INTENDED</code> 宏并无实际作用，仅仅作为一种“我确定我这里想跳过”的标志。<code>do &#123;&#125; while(0)</code> 对代码无影响，这种写法也会出现在一些多行的宏定义里（见<a href="https://stackoverflow.com/questions/257418/do-while-0-what-is-it-good-for">链接</a>）。</p>
<p>LevelDB 中哈希表和布隆过滤器会使用到该哈希函数。</p>
<h3 id="3-缓存-LRUCache"><a href="#3-缓存-LRUCache" class="headerlink" title="3. 缓存 LRUCache"></a>3. 缓存 LRUCache</h3><p>LevelDB 中使用的是 Least Recently Used Cache，即最近最少使用缓存。缓存接口定义于 <a href="https://github.com/google/leveldb/blob/master/include/leveldb/cache.h"><code>include/leveldb/cache.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Cache is an interface that maps keys to values.  It has internal</span></span><br><span class="line"><span class="comment">// synchronization and may be safely accessed concurrently from</span></span><br><span class="line"><span class="comment">// multiple threads.  It may automatically evict entries to make room</span></span><br><span class="line"><span class="comment">// for new entries.  Values have a specified charge against the cache</span></span><br><span class="line"><span class="comment">// capacity.  For example, a cache where the values are variable</span></span><br><span class="line"><span class="comment">// length strings, may use the length of the string as the charge for</span></span><br><span class="line"><span class="comment">// the string.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A builtin cache implementation with a least-recently-used eviction</span></span><br><span class="line"><span class="comment">// policy is provided.  Clients may use their own implementations if</span></span><br><span class="line"><span class="comment">// they want something more sophisticated (like scan-resistance, a</span></span><br><span class="line"><span class="comment">// custom eviction policy, variable cache sizing, etc.)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STORAGE_LEVELDB_INCLUDE_CACHE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORAGE_LEVELDB_INCLUDE_CACHE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/export.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/slice.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//仅依赖Slice</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Cache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new cache with a fixed size capacity.  This implementation</span></span><br><span class="line"><span class="comment">// of Cache uses a least-recently-used eviction policy.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认采用LRU替换策略</span></span><br><span class="line"><span class="function">LEVELDB_EXPORT Cache* <span class="title">NewLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Cache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cache</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//=delete表示编译器不生成默认构造函数。作用是，避免以下2个函数被调用，避免拷贝</span></span><br><span class="line">  <span class="built_in">Cache</span>(<span class="keyword">const</span> Cache&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Cache&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Cache&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Destroys all existing entries by calling the &quot;deleter&quot;</span></span><br><span class="line">  <span class="comment">// function that was passed to the constructor.</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Cache</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Opaque handle to an entry stored in the cache.</span></span><br><span class="line">  <span class="comment">//定义的 Handle 仅作为指针类型使用，实际上使用 void * 也并无区别，Handle 增加语意而已</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Handle</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert a mapping from key-&gt;value into the cache and assign it</span></span><br><span class="line">  <span class="comment">// the specified charge against the total cache capacity.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Returns a handle that corresponds to the mapping.  The caller</span></span><br><span class="line">  <span class="comment">// must call this-&gt;Release(handle) when the returned mapping is no</span></span><br><span class="line">  <span class="comment">// longer needed.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// When the inserted entry is no longer needed, the key and</span></span><br><span class="line">  <span class="comment">// value will be passed to &quot;deleter&quot;.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the cache has no mapping for &quot;key&quot;, returns nullptr.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Else return a handle that corresponds to the mapping.  The caller</span></span><br><span class="line">  <span class="comment">// must call this-&gt;Release(handle) when the returned mapping is no</span></span><br><span class="line">  <span class="comment">// longer needed.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release a mapping returned by a previous Lookup().</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must not have been released yet.</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must have been returned by a method on *this.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Release</span><span class="params">(Handle* handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the value encapsulated in a handle returned by a</span></span><br><span class="line">  <span class="comment">// successful Lookup().</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must not have been released yet.</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must have been returned by a method on *this.</span></span><br><span class="line">  <span class="comment">// 获取lookup()操作成功返回的Handle指向的表项中的Value</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">Value</span><span class="params">(Handle* handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the cache contains entry for key, erase it.  Note that the</span></span><br><span class="line">  <span class="comment">// underlying entry will be kept around until all existing handles</span></span><br><span class="line">  <span class="comment">// to it have been released.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a new numeric id.  May be used by multiple clients who are</span></span><br><span class="line">  <span class="comment">// sharing the same cache to partition the key space.  Typically the</span></span><br><span class="line">  <span class="comment">// client will allocate a new id at startup and prepend the id to</span></span><br><span class="line">  <span class="comment">// its cache keys.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span> <span class="title">NewId</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove all cache entries that are not actively in use.  Memory-constrained</span></span><br><span class="line">  <span class="comment">// applications may wish to call this method to reduce memory usage.</span></span><br><span class="line">  <span class="comment">// Default implementation of Prune() does nothing.  Subclasses are strongly</span></span><br><span class="line">  <span class="comment">// encouraged to override the default implementation.  A future release of</span></span><br><span class="line">  <span class="comment">// leveldb may change Prune() to a pure abstract method.</span></span><br><span class="line">  <span class="comment">// 修建所有不活跃的表项。适合对内存有限制的应用</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an estimate of the combined charges of all elements stored in the</span></span><br><span class="line">  <span class="comment">// cache.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// STORAGE_LEVELDB_INCLUDE_CACHE_H_</span></span></span><br></pre></td></tr></table></figure>

<p>接口仅依赖 <code>Slice</code>，接口也很容易看懂。<code>Cache</code> 中定义的 <code>Handle</code> 仅作为指针类型使用，实际上使用 <code>void *</code> 也并无区别，<code>Handle</code> 增加语意而已。</p>
<p><code>NewLRUCache</code> 作为工厂函数，可以生产一个 <code>LRUCache</code>，其定义于 <a href="https://github.com/google/leveldb/blob/master/util/cache.cc"><code>util/cache.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cache* <span class="title">NewLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ShardedLRUCache</span>(capacity); &#125;</span><br></pre></td></tr></table></figure>

<p><code>LRUCahce</code> 的实现依靠双向环形链表和哈希表。其中双向环形链表维护 <code>Recently</code> 属性，哈希表维护 <code>Used</code> 属性。双向环形链表和哈希表的节点信息都存储于 <code>LRUHandle</code> 结构中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUHandle</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>* value;</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*deleter)(<span class="keyword">const</span> Slice&amp;, <span class="keyword">void</span>* value);</span><br><span class="line">  LRUHandle* next_hash;</span><br><span class="line">  LRUHandle* next;</span><br><span class="line">  LRUHandle* prev;</span><br><span class="line">  <span class="keyword">size_t</span> charge;  <span class="comment">// TODO(opt): Only allow uint32_t?</span></span><br><span class="line">  <span class="keyword">size_t</span> key_length;</span><br><span class="line">  <span class="keyword">bool</span> in_cache;     <span class="comment">// Whether entry is in the cache.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> refs;     <span class="comment">// References, including cache reference, if present.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hash;     <span class="comment">// Hash of key(); used for fast sharding and comparisons</span></span><br><span class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next_ is only equal to this if the LRU handle is the list head of an</span></span><br><span class="line">    <span class="comment">// empty list. List heads never have meaningful keys.</span></span><br><span class="line">    <span class="built_in">assert</span>(next != <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>依次解释每一项属性：</p>
<ol>
<li><code>value</code> 为缓存存储的数据，类型无关；</li>
<li><code>deleter</code> 为键值对的析构函数指针；</li>
<li><code>next_hash</code> 为开放式哈希表中同一个桶下存储链表时使用的指针；</li>
<li><code>next</code> 和 <code>prev</code> 自然是双向环形链接的前后指针；</li>
<li><code>charge</code> 为当前节点的缓存费用，比如一个字符串的费用可能就是它的长度；</li>
<li><code>key_length</code> 为 <code>key</code> 的长度；</li>
<li><code>in_cache</code> 为节点是否在缓存里的标志；</li>
<li><code>refs</code> 为引用计数，当计数为 0 时则可以用 <code>deleter</code> 清理掉；</li>
<li><code>hash</code> 为 <code>key</code> 的哈希值；</li>
<li><code>key_data</code> 为变长的 <code>key</code> 数据，最小长度为 1，<code>malloc</code> 时动态指定长度。</li>
</ol>
<p>接着看哈希表的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">HandleTable</span>() : <span class="built_in">length_</span>(<span class="number">0</span>), <span class="built_in">elems_</span>(<span class="number">0</span>), <span class="built_in">list_</span>(<span class="literal">nullptr</span>) &#123; <span class="built_in">Resize</span>(); &#125;</span><br><span class="line">  ~<span class="built_in">HandleTable</span>() &#123; <span class="keyword">delete</span>[] list_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = <span class="built_in">FindPointer</span>(h-&gt;<span class="built_in">key</span>(), h-&gt;hash);</span><br><span class="line">    LRUHandle* old = *ptr;</span><br><span class="line">    h-&gt;next_hash = (old == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;next_hash);</span><br><span class="line">    *ptr = h;</span><br><span class="line">    <span class="keyword">if</span> (old == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      ++elems_;</span><br><span class="line">      <span class="keyword">if</span> (elems_ &gt; length_) &#123;</span><br><span class="line">        <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">        <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">        <span class="built_in">Resize</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = <span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">    LRUHandle* result = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      *ptr = result-&gt;next_hash;</span><br><span class="line">      --elems_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The table consists of an array of buckets where each bucket is</span></span><br><span class="line">  <span class="comment">// a linked list of cache entries that hash into the bucket.</span></span><br><span class="line">  <span class="comment">// 这个表由一个存储桶数组组成，每个存储桶是一个散列到存储桶中的缓存条目的链表。</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length_;   <span class="comment">//存储桶的数量</span></span><br><span class="line">  <span class="keyword">uint32_t</span> elems_;    <span class="comment">//当前哈希表的实际元素个数</span></span><br><span class="line">  LRUHandle** list_;  <span class="comment">//桶数组。实际存储的数据内容，底层结构</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a pointer to slot that points to a cache entry that</span></span><br><span class="line">  <span class="comment">// matches key/hash.  If there is no such cache entry, return a</span></span><br><span class="line">  <span class="comment">// pointer to the trailing slot in the corresponding linked list.</span></span><br><span class="line">  <span class="comment">// 根据指定的key与hash，返回对应的双重指针。</span></span><br><span class="line">  <span class="comment">// (先根据Hash值与存储桶数目length_，找到list_中对应的桶，然后再根据hash与key寻找，避免hash冲突)</span></span><br><span class="line">  <span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="literal">nullptr</span> &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;<span class="built_in">key</span>())) &#123;</span><br><span class="line">      ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Resize 则根据存储的节点数，对哈希表进行缩放。</span></span><br><span class="line"><span class="comment">   * 如果不缩放，这样的结构会退化到链表的复杂度。</span></span><br><span class="line"><span class="comment">   * 使用 2 的幂可以规避掉哈希值的模除，同样可以加速。</span></span><br><span class="line"><span class="comment">   * Resize时会遍历节点，将其从原位置取出，重新计算哈希值放到新位置，</span></span><br><span class="line"><span class="comment">   * 每次会加到桶中链表的头部。Resize 过程中链表需要拒绝其他请求。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 值得注意的是：新的桶的数目（新的length_）是根据 现有的存储的实际数据的个数 来决定的。</span></span><br><span class="line"><span class="comment">   * 使得new_length &gt;= 实际元素个数。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> new_length = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (new_length &lt; elems_) &#123;</span><br><span class="line">      new_length *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LRUHandle** new_list = <span class="keyword">new</span> LRUHandle*[new_length];</span><br><span class="line">    <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) &#123;</span><br><span class="line">      LRUHandle* h = list_[i];</span><br><span class="line">      <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        LRUHandle* next = h-&gt;next_hash;</span><br><span class="line">        <span class="keyword">uint32_t</span> hash = h-&gt;hash;</span><br><span class="line">        LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)];</span><br><span class="line">        h-&gt;next_hash = *ptr;</span><br><span class="line">        *ptr = h;</span><br><span class="line">        h = next;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(elems_ == count);</span><br><span class="line">    <span class="keyword">delete</span>[] list_;</span><br><span class="line">    list_ = new_list;</span><br><span class="line">    length_ = new_length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个标准的开放式哈希实现。属性中 <code>length_</code> 存储桶的数量，<code>elems_</code> 存储哈希表中节点数，<code>list_</code> 则为桶数组。每一个桶里存储 <code>hash</code> 值相同的一系列节点，这些节点构成一个链表，通过 <code>next_hash</code> 属性连接。</p>
<p><code>FindPointer</code> 函数返回一个二级指针。无论是 <code>list_[i]</code> 还是 <code>entry-&gt;next_hash</code>，均为 <code>LRUHandle *</code>，那么一个节点总会有一个正确的 <code>LRUHandle *</code> 变量指向它，该函数就返回这个变量的指针。说起来有点绕，仔细看懂就好。</p>
<p>看懂后，理解 <code>Insert</code> 和 <code>Remove</code> 都不难。<code>Resize</code> 则根据存储的节点数，对哈希表进行缩放。如果不缩放，这样的结构会退化到链表的复杂度。使用 2 的幂可以规避掉哈希值的模除，同样可以加速。<code>Resize</code> 时会遍历每一个节点，将其从原位置取出，重新计算哈希值放到新位置，每次会加到桶中链表的头部。<code>Resize</code> 过程中链表需要拒绝其他请求。</p>
<p>最后看 <code>LRUCache</code> 的实现就很简单了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A single shard of sharded cache.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LRUCache</span>();</span><br><span class="line">  ~<span class="built_in">LRUCache</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Separate from constructor so caller can easily make an array of LRUCache</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetCapacity</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> </span>&#123; capacity_ = capacity; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Like Cache methods, but with an extra &quot;hash&quot; parameter.</span></span><br><span class="line">  <span class="function">Cache::Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span></span>;</span><br><span class="line">  <span class="function">Cache::Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Cache::Handle* handle)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> usage_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Remove</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Append</span><span class="params">(LRUHandle* list, LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">FinishErase</span><span class="params">(LRUHandle* e)</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialized before use.</span></span><br><span class="line">  <span class="comment">// 初始化的容量</span></span><br><span class="line">  <span class="keyword">size_t</span> capacity_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mutex_ protects the following state.</span></span><br><span class="line">  <span class="comment">// 锁,用来保护下列的状态</span></span><br><span class="line">  <span class="keyword">mutable</span> port::Mutex mutex_;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> usage_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * LRUCache 中存储了两条链表，lru_ 和 in_use_，</span></span><br><span class="line"><span class="comment">   * 分别记录普通节点和外部正在使用中的节点。外部正在使用中的节点是不可删除的，</span></span><br><span class="line"><span class="comment">   * 将二者区分开也方便做对应的清理。Ref 和 Unref 分别增删引用计数，</span></span><br><span class="line"><span class="comment">   * 并完成节点在 lru_ 和 in_use_ 的交换，以及计数为 0 时做最后的删除。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 双向链表，会将最新使用的节点放到链表的末端。这样在容量超标时，</span></span><br><span class="line"><span class="comment">   * 删除链表头部的、长时间未用的节点即可。该逻辑实现于 Insert 函数的结尾。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dummy head of LRU list.</span></span><br><span class="line">  <span class="comment">// lru.prev is newest entry, lru.next is oldest entry.</span></span><br><span class="line">  <span class="comment">// Entries have refs==1 and in_cache==true.</span></span><br><span class="line">  <span class="function">LRUHandle lru_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dummy head of in-use list.</span></span><br><span class="line">  <span class="comment">// Entries are in use by clients, and have refs &gt;= 2 and in_cache==true.</span></span><br><span class="line">  <span class="function">LRUHandle in_use_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">HandleTable table_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache::<span class="built_in">LRUCache</span>() : <span class="built_in">capacity_</span>(<span class="number">0</span>), <span class="built_in">usage_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Make empty circular linked lists.</span></span><br><span class="line">  lru_.next = &amp;lru_;</span><br><span class="line">  lru_.prev = &amp;lru_;</span><br><span class="line">  in_use_.next = &amp;in_use_;</span><br><span class="line">  in_use_.prev = &amp;in_use_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRUCache::~<span class="built_in">LRUCache</span>() &#123;</span><br><span class="line">  <span class="built_in">assert</span>(in_use_.next == &amp;in_use_);  <span class="comment">// Error if caller has an unreleased handle</span></span><br><span class="line">  <span class="keyword">for</span> (LRUHandle* e = lru_.next; e != &amp;lru_;) &#123;</span><br><span class="line">    LRUHandle* next = e-&gt;next;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;in_cache);</span><br><span class="line">    e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;refs == <span class="number">1</span>);  <span class="comment">// Invariant of lru_ list.</span></span><br><span class="line">    <span class="built_in">Unref</span>(e);</span><br><span class="line">    e = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加引用计数。</span></span><br><span class="line"><span class="comment">// 若引用计数为1且in_cache==true，则将其从原链表中移除，添加到in_use链表的末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Ref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">1</span> &amp;&amp; e-&gt;in_cache) &#123;  <span class="comment">// If on lru_ list, move to in_use_ list.</span></span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;in_use_, e);</span><br><span class="line">  &#125;</span><br><span class="line">  e-&gt;refs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少引用计数。</span></span><br><span class="line"><span class="comment">// 若减少后引用计数为0，则删除对应空间。否则，将其从原链表中移除，添加到lru_链表的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Unref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(e-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">  e-&gt;refs--;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">0</span>) &#123;  <span class="comment">// Deallocate.</span></span><br><span class="line">    <span class="built_in">assert</span>(!e-&gt;in_cache);</span><br><span class="line">    (*e-&gt;deleter)(e-&gt;<span class="built_in">key</span>(), e-&gt;value);</span><br><span class="line">    <span class="built_in">free</span>(e);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;in_cache &amp;&amp; e-&gt;refs == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// No longer in use; move to lru_ list.</span></span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;lru_, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Remove</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  e-&gt;next-&gt;prev = e-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Append</span><span class="params">(LRUHandle* list, LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make &quot;e&quot; newest entry by inserting just before *list</span></span><br><span class="line">  e-&gt;next = list;</span><br><span class="line">  e-&gt;prev = list-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e;</span><br><span class="line">  e-&gt;next-&gt;prev = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过HandleTable哈希表查询，并添加引用计数</span></span><br><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  LRUHandle* e = table_.<span class="built_in">Lookup</span>(key, hash);</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">Ref</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减少引用计数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Release</span><span class="params">(Cache::Handle* handle)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">Unref</span>(<span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">void</span>* value))</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  LRUHandle* e =</span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  e-&gt;deleter = deleter;</span><br><span class="line">  e-&gt;charge = charge;</span><br><span class="line">  e-&gt;key_length = key.<span class="built_in">size</span>();</span><br><span class="line">  e-&gt;hash = hash;</span><br><span class="line">  e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">  e-&gt;refs = <span class="number">1</span>;  <span class="comment">// for the returned handle.</span></span><br><span class="line">  std::<span class="built_in">memcpy</span>(e-&gt;key_data, key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (capacity_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    e-&gt;refs++;  <span class="comment">// for the cache&#x27;s reference.</span></span><br><span class="line">    e-&gt;in_cache = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;in_use_, e);</span><br><span class="line">    usage_ += charge;</span><br><span class="line">    <span class="comment">//在哈希表HandleTable中插入新节点，同时在链表中删除 table_.Insert()返回的旧节点</span></span><br><span class="line">    <span class="built_in">FinishErase</span>(table_.<span class="built_in">Insert</span>(e));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// don&#x27;t cache. (capacity_==0 is supported and turns off caching.)</span></span><br><span class="line">    <span class="comment">// next is read by key() in an assert, so it must be initialized</span></span><br><span class="line">    e-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 双向链表，会将最新使用的节点放到链表的末端。</span></span><br><span class="line">  <span class="comment">// 这样在容量超标时，删除链表头部的、长时间未用的节点即可。</span></span><br><span class="line">  <span class="keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123;</span><br><span class="line">    LRUHandle* old = lru_.next;</span><br><span class="line">    <span class="built_in">assert</span>(old-&gt;refs == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//若容量超标，在哈希表与链表中都删除对应的节点</span></span><br><span class="line">    <span class="keyword">bool</span> erased = <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(old-&gt;<span class="built_in">key</span>(), old-&gt;hash));</span><br><span class="line">    <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">      <span class="built_in">assert</span>(erased);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If e != nullptr, finish removing *e from the cache; it has already been</span></span><br><span class="line"><span class="comment">// removed from the hash table.  Return whether e != nullptr.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LRUCache::FinishErase</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;in_cache);</span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">    usage_ -= e-&gt;charge;</span><br><span class="line">    <span class="built_in">Unref</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> e != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(key, hash));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Prune</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (lru_.next != &amp;lru_) &#123;</span><br><span class="line">    LRUHandle* e = lru_.next;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;refs == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> erased = <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(e-&gt;<span class="built_in">key</span>(), e-&gt;hash));</span><br><span class="line">    <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">      <span class="built_in">assert</span>(erased);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LRUCache</code> 中存储了两条链表，<code>lru_</code> 和 <code>in_use_</code>，分别记录普通节点和外部正在使用中的节点。外部正在使用中的节点是不可删除的，将二者区分开也方便做对应的清理。<code>Ref</code> 和 <code>Unref</code> 分别增删引用计数，并完成节点在 <code>lru_</code> 和 <code>in_use_</code> 的交换，以及计数为 0 时做最后的删除。</p>
<p>双向链表，会将最新使用的节点放到链表的末端。这样在容量超标时，删除链表头部的、长时间未用的节点即可。该逻辑实现于 <code>Insert</code> 函数的结尾。</p>
<p><code>LRUCache</code> 中在添删查操作中均使用互斥锁完成额外同步。<code>LevelDB</code> 中的锁将在后续文章中详细介绍。</p>
<p>最后看分片 <code>ShardedLRUCache</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShardBits = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShards = <span class="number">1</span> &lt;&lt; kNumShardBits;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分片LRUCache</span></span><br><span class="line"><span class="comment">// LevelDB 默认将 LRUCache 分为2^4块，取哈希值的高 4 位作为分片的位置。</span></span><br><span class="line"><span class="comment">// 分片可以提高查询和插入的速度，减少锁的压力，是提高缓存性能的常用方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//LRUCache的数组，包含2^4=16个LRUCache</span></span><br><span class="line">  LRUCache shard_[kNumShards];</span><br><span class="line">  port::Mutex id_mutex_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_id_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对Slice进行Hash操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">HashSlice</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Hash</span>(s.<span class="built_in">data</span>(), s.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对hash值进行右移，仅保留高4位作为分片的位置</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">Shard</span><span class="params">(<span class="keyword">uint32_t</span> hash)</span> </span>&#123; <span class="keyword">return</span> hash &gt;&gt; (<span class="number">32</span> - kNumShardBits); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ShardedLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> : last_id_(<span class="number">0</span>) &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> per_shard = (capacity + (kNumShards - <span class="number">1</span>)) / kNumShards;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].<span class="built_in">SetCapacity</span>(per_shard);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">ShardedLRUCache</span>() <span class="keyword">override</span> &#123;&#125;</span><br><span class="line">  <span class="function">Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">    <span class="keyword">return</span> shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Insert</span>(key, hash, value, charge, deleter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">    <span class="keyword">return</span> shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Lookup</span>(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Handle* handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    LRUHandle* h = <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle);</span><br><span class="line">    shard_[<span class="built_in">Shard</span>(h-&gt;hash)].<span class="built_in">Release</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">    shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Erase</span>(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">Value</span><span class="params">(Handle* handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle)-&gt;value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">NewId</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;id_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ++(last_id_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].<span class="built_in">Prune</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      total += shard_[s].<span class="built_in">TotalCharge</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>LevelDB</code> 默认将 <code>LRUCache</code> 分为 2^424 块，取哈希值的高 4 位作为分片的位置。分片可以提高查询和插入的速度，减少锁的压力，是提高缓存性能的常用方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文简单介绍了 <code>LevelDB</code> 中的 <code>Slice</code>、<code>Hash</code> 和 <code>LRUCache</code> 的实现。慢慢会觉得代码中的每个细节都是有意义的，不可忽略。<code>LevelDB</code> 源代码不超过 2万行，非常推荐学习 C++ 的同学阅读。建议可以先读 <code>util</code> 部分，这里是通用的数据结构，没有太多依赖。</p>
<p>下一篇会继续介绍 <code>LevelDB</code> 中的其他数据结构，包括布隆过滤器、内存池和跳表。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码分析——2.基本的数据结构续</title>
    <url>/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AD/</url>
    <content><![CDATA[<h2 id="二-基本的数据结构续"><a href="#二-基本的数据结构续" class="headerlink" title="二.基本的数据结构续"></a>二.基本的数据结构续</h2><p>本系列的<a href="https://gasolly.github.io/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">上一篇</a>介绍了 <code>LevelDB</code> 中的 <code>Slice</code>、<code>Hash</code> 和 <code>LRUCache</code> 的实现，这一篇将继续分析布隆过滤器、内存池和跳表。</p>
<span id="more"></span>

<h3 id="4-布隆过滤器-BloomFilter"><a href="#4-布隆过滤器-BloomFilter" class="headerlink" title="4. 布隆过滤器 BloomFilter"></a>4. 布隆过滤器 BloomFilter</h3><p>在介绍布隆过滤器之前，先介绍下 <code>LevelDB</code> 中的过滤器策略 <code>FilterPolicy</code>。考虑一个场景：在 <code>LevelDB</code> 中查询某个指定 <code>key = query</code> 对应的 <code>value</code>，如果我们事先知道了所有的 <code>key</code> 里都找不到这个 <code>query</code>，那也就不需要进一步的读取磁盘、精确查找了，可以有效地减少磁盘访问数量。</p>
<p><code>FilterPolicy</code> 就负责这件事情：它可以根据一组 <code>key</code> 创建一个小的过滤器 <code>filter</code>，并且可以将该过滤器和键值对存储在磁盘中，在查询时快速判断 <code>query</code> 是否在 <code>filter</code> 中。默认使用的 <code>FilterPolicy</code> 即为布隆过滤器。<code>FilterPolicy</code> 定义于 <a href="https://github.com/google/leveldb/blob/master/include/leveldb/filter_policy.h"><code>include/leveldb/filter_policy.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/export.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slice</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**过滤器，用于快速判断 查找的Key是否存在。默认采用布隆过滤器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 暴露的接口除了 FilterPolicy 接口类，还有 NewBloomFilterPolicy 函数，</span></span><br><span class="line"><span class="comment"> * 其他代码中均使用 FilterPolicy。</span></span><br><span class="line"><span class="comment"> * 这样的设计可以保证使用者可以自行定义策略类、方便地替换原有的布隆过滤器。</span></span><br><span class="line"><span class="comment"> * 这种设计也称之为策略模式，将策略单独设计为一个类或接口，</span></span><br><span class="line"><span class="comment"> * 不同的子类对应不同的策略方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">FilterPolicy</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">FilterPolicy</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the name of this policy.  Note that if the filter encoding</span></span><br><span class="line">  <span class="comment">// changes in an incompatible way, the name returned by this method</span></span><br><span class="line">  <span class="comment">// must be changed.  Otherwise, old incompatible filters may be</span></span><br><span class="line">  <span class="comment">// passed to methods of this type.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keys[0,n-1] contains a list of keys (potentially with duplicates)</span></span><br><span class="line">  <span class="comment">// that are ordered according to the user supplied comparator.</span></span><br><span class="line">  <span class="comment">// Append a filter that summarizes keys[0,n-1] to *dst.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Warning: do not change the initial contents of *dst.  Instead,</span></span><br><span class="line">  <span class="comment">// append the newly constructed filter to *dst.</span></span><br><span class="line">  <span class="comment">// 根据给定的keys创建Filter</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::string* dst)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &quot;filter&quot; contains the data appended by a preceding call to</span></span><br><span class="line">  <span class="comment">// CreateFilter() on this class.  This method must return true if</span></span><br><span class="line">  <span class="comment">// the key was in the list of keys passed to CreateFilter().</span></span><br><span class="line">  <span class="comment">// This method may return true or false if the key was not on the</span></span><br><span class="line">  <span class="comment">// list, but it should aim to return false with a high probability.</span></span><br><span class="line">  <span class="comment">// 注意函数名称的May，即存在 false positive的可能。</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; filter)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return a new filter policy that uses a bloom filter with approximately</span></span><br><span class="line"><span class="comment">// the specified number of bits per key.  A good value for bits_per_key</span></span><br><span class="line"><span class="comment">// is 10, which yields a filter with ~ 1% false positive rate.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Callers must delete the result after any database that is using the</span></span><br><span class="line"><span class="comment">// result has been closed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note: if you are using a custom comparator that ignores some parts</span></span><br><span class="line"><span class="comment">// of the keys being compared, you must not use NewBloomFilterPolicy()</span></span><br><span class="line"><span class="comment">// and must provide your own FilterPolicy that also ignores the</span></span><br><span class="line"><span class="comment">// corresponding parts of the keys.  For example, if the comparator</span></span><br><span class="line"><span class="comment">// ignores trailing spaces, it would be incorrect to use a</span></span><br><span class="line"><span class="comment">// FilterPolicy (like NewBloomFilterPolicy) that does not ignore</span></span><br><span class="line"><span class="comment">// trailing spaces in keys.</span></span><br><span class="line"><span class="comment">// 默认采用bloom过滤器，推荐的bits_per_key参数为10，此时false positive rate约等于1%</span></span><br><span class="line"><span class="function">LEVELDB_EXPORT <span class="keyword">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// STORAGE_LEVELDB_INCLUDE_FILTER_POLICY_H_</span></span></span><br></pre></td></tr></table></figure>

<p><code>FilterPolicy</code> 中，<code>CreateFilter</code> 负责创建 <code>filter</code>，<code>KeyMayMatch</code> 负责判断 <code>key</code> 是否在 <code>filter</code> 中。注意这个 <code>May</code>，即这里 <code>Match</code> 判断可能会出错，也允许会出错。对于布隆过滤器，如果 <code>Key</code> 在 <code>filter</code> 里，那么一定会 <code>Match</code> 上；反之如果不在，那么有小概率也会 <code>Match</code> 上，进而会多做一些磁盘访问，只要这个概率足够小也无伤大雅。这也刚好符合 <code>KeyMayMatch</code> 函数的需求。</p>
<p>暴露的接口除了 <code>FilterPolicy</code> 接口类，还有 <code>NewBloomFilterPolicy</code> 函数，其他代码中均使用 <code>FilterPolicy</code>。这样的设计可以保证使用者可以自行定义策略类、方便地替换原有的布隆过滤器。这种设计也称之为<a href="https://en.wikipedia.org/wiki/Strategy_pattern">策略模式</a>，将策略单独设计为一个类或接口，不同的子类对应不同的策略方法。继续看布隆过滤器的实现 <a href="https://github.com/google/leveldb/blob/master/util/bloom.cc"><code>util/bloom.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/filter_policy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/slice.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/hash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="comment">//对key进行哈希操作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">BloomHash</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Hash</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>(), <span class="number">0xbc9f1d34</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilterPolicy</span> :</span> <span class="keyword">public</span> FilterPolicy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> : bits_per_key_(bits_per_key) &#123;</span></span><br><span class="line">    <span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line">    <span class="comment">// 哈希函数的数目为 bits_per_key * ln2 ，上下限分别为30与1</span></span><br><span class="line">    k_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>);  <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line">    <span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回过滤策略的名称</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;leveldb.BuiltinBloomFilter2&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, std::string* dst)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line">    <span class="comment">// 根据 keys的数量n 与 每个key需要的比特位数，计算bloom filter的总体大小</span></span><br><span class="line">    <span class="keyword">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For small n, we can see a very high false positive rate.  Fix it</span></span><br><span class="line">    <span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line">    <span class="comment">// Bloom filter的容量过小时，很容易false positive，因此最小容量设置为64</span></span><br><span class="line">    <span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Bloom filter容量大小按字节大小向上取整，即为8bits的倍数</span></span><br><span class="line">    <span class="keyword">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">    bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> init_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">    dst-&gt;<span class="built_in">resize</span>(init_size + bytes, <span class="number">0</span>);</span><br><span class="line">    dst-&gt;<span class="built_in">push_back</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(k_));  <span class="comment">// Remember # of probes in filter</span></span><br><span class="line">    <span class="keyword">char</span>* array = &amp;(*dst)[init_size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line">      <span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line">      <span class="keyword">uint32_t</span> h = <span class="built_in">BloomHash</span>(keys[i]);</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">        array[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line">        h += delta;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; bloom_filter)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> len = bloom_filter.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* array = bloom_filter.<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the encoded k so that we can read filters generated by</span></span><br><span class="line">    <span class="comment">// bloom filters created using different parameters.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> k = array[len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k &gt; <span class="number">30</span>) &#123;</span><br><span class="line">      <span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></span><br><span class="line">      <span class="comment">// Consider it a match.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> h = <span class="built_in">BloomHash</span>(key);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">      <span class="keyword">if</span> ((array[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      h += delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">size_t</span> bits_per_key_; <span class="comment">//每一个key需要的bits位数，用于计算过滤器的容量</span></span><br><span class="line">  <span class="keyword">size_t</span> k_;            <span class="comment">//表示Bloom Filter中哈希函数的数目</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BloomFilterPolicy</span>(bits_per_key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p><code>BloomFilterPolicy</code> 构造时需要提供 <code>bits_per_key</code>，后再根据 <code>key</code> 的数量 n一起计算出所需要的 <code>bits</code> 数 m。而代码中的 <code>k_</code> 即为布隆过滤器中哈希函数的数目 k，这里 k=m*/<em>n</em>ln2，详细介绍可以参考<a href="https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions">维基百科</a>。</p>
<p>而后，依次计算 n个 <code>key</code> 的 k个哈希结果。这里使用了 <a href="https://en.wikipedia.org/wiki/Double_hashing">Double Hash</a>。</p>
<p>Double Hash 一般用于开放寻址哈希的优化。这里直接取连续的 k个哈希结果作为布隆过滤器需要的 k个哈希函数结果，一切为了速度。</p>
<h3 id="5-内存池-Arena"><a href="#5-内存池-Arena" class="headerlink" title="5. 内存池 Arena"></a>5. 内存池 Arena</h3><p><code>LevelDB</code> 中实现了一个简单的内存池组建 Arena，位于 <a href="https://github.com/google/leveldb/blob/master/util/arena.h"><code>util/arena.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LevelDB的内存池</span></span><br><span class="line"><span class="comment"> * 申请内存时，将申请到的内存块放入std::vector blocks_中，</span></span><br><span class="line"><span class="comment"> * 在Arena的生命周期结束后，统一释放掉所有申请到的内存</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 每次会申请一个大的 block，默认大小为 4KB。</span></span><br><span class="line"><span class="comment"> * 而后申请 bytes 长度的空间时，</span></span><br><span class="line"><span class="comment"> * 如果当前 block 的剩余大小足够分配，则返回分配的内存地址并更新余下的起始位置和大小；</span></span><br><span class="line"><span class="comment"> * 否则将会直接申请新的 block。析构时会删除所有 block。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当前空间不足时有一个优化，如果申请的空间大于 kBlockSize / 4 也就是 1KB 时，</span></span><br><span class="line"><span class="comment"> * 会直接申请对应长度的 block 返回，不更新当前剩余 block 的起始位置和大小，</span></span><br><span class="line"><span class="comment"> * 这样下次申请小空间时依然可以使用当前余下的空间；</span></span><br><span class="line"><span class="comment"> * 否则将放弃当前剩余空间，重新申请一块 4KB 的 block 再分配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arena</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Arena</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Arena</span>(<span class="keyword">const</span> Arena&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Arena&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Arena&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Arena</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接分配内存</span></span><br><span class="line">  <span class="comment">// Return a pointer to a newly allocated memory block of &quot;bytes&quot; bytes.</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">Allocate</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请对齐的内存空间</span></span><br><span class="line">  <span class="comment">// Allocate memory with the normal alignment guarantees provided by malloc.</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an estimate of the total memory usage of data allocated</span></span><br><span class="line">  <span class="comment">// by the arena.</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">MemoryUsage</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> memory_usage_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateFallback</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateNewBlock</span><span class="params">(<span class="keyword">size_t</span> block_bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocation state</span></span><br><span class="line">  <span class="comment">// alloc_ptr_标记1个4KB block内部分配内存的起始地址</span></span><br><span class="line">  <span class="keyword">char</span>* alloc_ptr_;</span><br><span class="line">  <span class="comment">//alloc_bytes_remaining_记录1个4KB block内部剩余可用的内存字节数</span></span><br><span class="line">  <span class="keyword">size_t</span> alloc_bytes_remaining_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Array of new[] allocated memory blocks</span></span><br><span class="line">  <span class="comment">// blocks_存储多个4KB block</span></span><br><span class="line">  std::vector&lt;<span class="keyword">char</span>*&gt; blocks_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Total memory usage of the arena.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// TODO(costan): This member is accessed via atomics, but the others are</span></span><br><span class="line">  <span class="comment">//               accessed without any locking. Is this OK?</span></span><br><span class="line">  std::atomic&lt;<span class="keyword">size_t</span>&gt; memory_usage_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">Arena::Allocate</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The semantics of what to return are a bit messy if we allow</span></span><br><span class="line">  <span class="comment">// 0-byte allocations, so we disallow them here (we don&#x27;t need</span></span><br><span class="line">  <span class="comment">// them for our internal use).</span></span><br><span class="line">  <span class="built_in">assert</span>(bytes &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    <span class="keyword">char</span>* result = alloc_ptr_;</span><br><span class="line">    alloc_ptr_ += bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p><code>Arena</code> 提供三个接口，<code>Allocate</code>、<code>AllocateAligned</code> 和 <code>MemoryUsage</code>，分别实现申请指定大小内存、申请对齐的指定大小内存和查询内存使用。具体的函数实现在 <a href="https://github.com/google/leveldb/blob/master/util/arena.cc"><code>util/arena.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/arena.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kBlockSize = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">Arena::<span class="built_in">Arena</span>()</span><br><span class="line">    : <span class="built_in">alloc_ptr_</span>(<span class="literal">nullptr</span>), <span class="built_in">alloc_bytes_remaining_</span>(<span class="number">0</span>), <span class="built_in">memory_usage_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Arena::~<span class="built_in">Arena</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; blocks_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] blocks_[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateFallback</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当申请的内存大小 大于 kBlockSize/4，即1KB时，会直接申请对应需要长度的block返回</span></span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// Object is more than a quarter of our block size.  Allocate it separately</span></span><br><span class="line">    <span class="comment">// to avoid wasting too much space in leftover bytes.</span></span><br><span class="line">    <span class="keyword">char</span>* result = <span class="built_in">AllocateNewBlock</span>(bytes);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当申请的内存大小小于1KB时，直接分配4KB block，并更新剩余block的起始位置和大小</span></span><br><span class="line">  <span class="comment">// We waste the remaining space in the current block.</span></span><br><span class="line">  alloc_ptr_ = <span class="built_in">AllocateNewBlock</span>(kBlockSize);</span><br><span class="line">  alloc_bytes_remaining_ = kBlockSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* result = alloc_ptr_;</span><br><span class="line">  alloc_ptr_ += bytes;</span><br><span class="line">  alloc_bytes_remaining_ -= bytes;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateAligned</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> align = (<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*) &gt; <span class="number">8</span>) ? <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*) : <span class="number">8</span>;</span><br><span class="line">  <span class="built_in"><span class="keyword">static_assert</span></span>((align &amp; (align - <span class="number">1</span>)) == <span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;Pointer size should be a power of 2&quot;</span>);</span><br><span class="line">  <span class="keyword">size_t</span> current_mod = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(alloc_ptr_) &amp; (align - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">size_t</span> slop = (current_mod == <span class="number">0</span> ? <span class="number">0</span> : align - current_mod);</span><br><span class="line">  <span class="keyword">size_t</span> needed = bytes + slop;</span><br><span class="line">  <span class="keyword">char</span>* result;</span><br><span class="line">  <span class="keyword">if</span> (needed &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    result = alloc_ptr_ + slop;</span><br><span class="line">    alloc_ptr_ += needed;</span><br><span class="line">    alloc_bytes_remaining_ -= needed;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// AllocateFallback always returned aligned memory</span></span><br><span class="line">    result = <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>((<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(result) &amp; (align - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="keyword">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span>[block_bytes];</span><br><span class="line">  blocks_.<span class="built_in">push_back</span>(result);</span><br><span class="line">  memory_usage_.<span class="built_in">fetch_add</span>(block_bytes + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>*),</span><br><span class="line">                          std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p>代码也很容易看懂。每次会申请一个大的 block，默认大小为 4KB。而后申请 <code>bytes</code> 长度的空间时，如果当前 block 的剩余大小足够分配，则返回分配的内存地址并更新余下的起始位置和大小；否则将会直接申请新的 block。析构时会删除所有 block。</p>
<p>当前空间不足时有一个优化，如果申请的空间大于 <code>kBlockSize / 4</code> 也就是 1KB 时，会直接申请对应长度的 block 返回，不更新当前剩余 block 的起始位置和大小，这样下次申请小空间时依然可以使用当前余下的空间；否则将放弃当前剩余空间，重新申请一块 4KB 的 block 再分配。</p>
<p>当频繁申请小内存时，内存池可以规避掉大部分的系统级申请。接下来的介绍的跳表、以及后续文章介绍的 <code>MemTable</code> 中均会使用到该内存池。</p>
<h3 id="6-跳表-SkipList"><a href="#6-跳表-SkipList" class="headerlink" title="6. 跳表 SkipList"></a>6. 跳表 SkipList</h3><p>跳表是在传统链表上加入跳跃连接的有序链表。因为有序，所以可以根据顺序关系，快速跳过无关元素。查询和插入的平均复杂度均为 \mathcal O(\log n)O(log<em>n</em>)。<a href="https://en.wikipedia.org/wiki/Skip_list">维基百科上有一副经典图</a>：</p>
<p><a href="https://sf-zhou.github.io/images/3c325892dba645fe90dd7a06f0c479c0.gif"><img src="https://sf-zhou.github.io/images/3c325892dba645fe90dd7a06f0c479c0.gif" alt="img"></a></p>
<p>LevelDB 中实现的跳表位于 <a href="https://github.com/google/leveldb/blob/master/db/skiplist.h"><code>db/skiplist.h</code></a>，所有实现均在该头文件里。仔细看图，对照代码，就很容易理解了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/arena.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/random.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳表的实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipList</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a new SkipList object that will use &quot;cmp&quot; for comparing keys,</span></span><br><span class="line">  <span class="comment">// and will allocate memory using &quot;*arena&quot;.  Objects allocated in the arena</span></span><br><span class="line">  <span class="comment">// must remain allocated for the lifetime of the skiplist object.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SkipList</span><span class="params">(Comparator cmp, Arena* arena)</span></span>;</span><br><span class="line">  <span class="comment">// 不允许拷贝构造</span></span><br><span class="line">  <span class="built_in">SkipList</span>(<span class="keyword">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  SkipList&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert key into the list.</span></span><br><span class="line">  <span class="comment">// REQUIRES: nothing that compares equal to key is currently in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff an entry that compares equal to key is in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Contains</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iteration over the contents of a skip list</span></span><br><span class="line">  <span class="comment">// 定义迭代器类，用于对跳表进行操作，包含SkipList*与Node*,2个成员变量</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Initialize an iterator over the specified list.</span></span><br><span class="line">    <span class="comment">// The returned iterator is not valid.</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(<span class="keyword">const</span> SkipList* list)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true iff the iterator is positioned at a valid node.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the key at the current position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advances to the next position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advances to the previous position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Key&amp; target)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the first entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the last entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> SkipList* list_;</span><br><span class="line">    Node* node_;</span><br><span class="line">    <span class="comment">// Intentionally copyable</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//记录SkipList最大的高度</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> kMaxHeight = <span class="number">12</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetMaxHeight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max_height_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Node* <span class="title">NewNode</span><span class="params">(<span class="keyword">const</span> Key&amp; key, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">RandomHeight</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Equal</span><span class="params">(<span class="keyword">const</span> Key&amp; a, <span class="keyword">const</span> Key&amp; b)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">compare_</span>(a, b) == <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if key is greater than the data stored in &quot;n&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">KeyIsAfterNode</span><span class="params">(<span class="keyword">const</span> Key&amp; key, Node* n)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the earliest node that comes at or after key.</span></span><br><span class="line">  <span class="comment">// Return nullptr if there is no such node.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If prev is non-null, fills prev[level] with pointer to previous</span></span><br><span class="line">  <span class="comment">// node at &quot;level&quot; for every level in [0..max_height_-1].</span></span><br><span class="line">  <span class="function">Node* <span class="title">FindGreaterOrEqual</span><span class="params">(<span class="keyword">const</span> Key&amp; key, Node** prev)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the latest node with a key &lt; key.</span></span><br><span class="line">  <span class="comment">// Return head_ if there is no such node.</span></span><br><span class="line">  <span class="function">Node* <span class="title">FindLessThan</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the last node in the list.</span></span><br><span class="line">  <span class="comment">// Return head_ if list is empty.</span></span><br><span class="line">  <span class="function">Node* <span class="title">FindLast</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Immutable after construction</span></span><br><span class="line">  <span class="comment">// 比较器</span></span><br><span class="line">  Comparator <span class="keyword">const</span> compare_;</span><br><span class="line">  <span class="comment">// 跳表的内存池</span></span><br><span class="line">  Arena* <span class="keyword">const</span> arena_;  <span class="comment">// Arena used for allocations of nodes</span></span><br><span class="line">  <span class="comment">// SkipList 的前置哨兵节点</span></span><br><span class="line">  Node* <span class="keyword">const</span> head_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modified only by Insert().  Read racily by readers, but stale</span></span><br><span class="line">  <span class="comment">// values are ok.</span></span><br><span class="line">  <span class="comment">// 最大高度</span></span><br><span class="line">  std::atomic&lt;<span class="keyword">int</span>&gt; max_height_;  <span class="comment">// Height of the entire list</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read/written only by Insert().</span></span><br><span class="line">  <span class="comment">// 随机数生成器</span></span><br><span class="line">  Random rnd_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation details follow</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SkipList</span>&lt;</span>Key, Comparator&gt;::Node &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Node</span><span class="params">(<span class="keyword">const</span> Key&amp; k)</span> : key(k) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储主键Key</span></span><br><span class="line">  Key <span class="keyword">const</span> key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Accessors/mutators for links.  Wrapped in methods so we can</span></span><br><span class="line">  <span class="comment">// add the appropriate barriers as necessary.</span></span><br><span class="line">  <span class="comment">// 获取当前节点在指定level的下一个节点</span></span><br><span class="line">  <span class="function">Node* <span class="title">Next</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span></span><br><span class="line">    <span class="comment">// version of the returned Node.</span></span><br><span class="line">    <span class="keyword">return</span> next_[n].<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将当前节点在指定level的下一个节点设置为x</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetNext</span><span class="params">(<span class="keyword">int</span> n, Node* x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use a &#x27;release store&#x27; so that anybody who reads through this</span></span><br><span class="line">    <span class="comment">// pointer observes a fully initialized version of the inserted node.</span></span><br><span class="line">    next_[n].<span class="built_in">store</span>(x, std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无内存障碍版本的实现</span></span><br><span class="line">  <span class="comment">// No-barrier variants that can be safely used in a few locations.</span></span><br><span class="line">  <span class="function">Node* <span class="title">NoBarrier_Next</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> next_[n].<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NoBarrier_SetNext</span><span class="params">(<span class="keyword">int</span> n, Node* x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    next_[n].<span class="built_in">store</span>(x, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Array of length equal to the node height.  next_[0] is lowest level link.</span></span><br><span class="line">  <span class="comment">//1.这里提前使用声明分配1个对象的内存，是因为，第0层数据肯定是都有的，而且，是全部数据</span></span><br><span class="line">  <span class="comment">//2.使用数组方式，那么后续分配的内存就是连续的，cache-friend</span></span><br><span class="line">  std::atomic&lt;Node*&gt; next_[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::<span class="built_in">NewNode</span>(</span><br><span class="line">    <span class="keyword">const</span> Key&amp; key, <span class="keyword">int</span> height) &#123;</span><br><span class="line">  <span class="comment">//因为Node中的成员变量已定义1个Node*，所以此处只需height-1</span></span><br><span class="line">  <span class="keyword">char</span>* <span class="keyword">const</span> node_memory = arena_-&gt;<span class="built_in">AllocateAligned</span>(</span><br><span class="line">      <span class="built_in"><span class="keyword">sizeof</span></span>(Node) + <span class="built_in"><span class="keyword">sizeof</span></span>(std::atomic&lt;Node*&gt;) * (height - <span class="number">1</span>));</span><br><span class="line">  <span class="comment">// 定位new ，空间换时间，从LevelDB的内存池Arena中开辟的node_memory中，new Node(key)</span></span><br><span class="line">  <span class="comment">// 与常规new相比，不需要申请空间，仅需调用构造函数，优化CPU缓存</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in"><span class="keyword">new</span></span> (node_memory) <span class="built_in">Node</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Iterator</span>(<span class="keyword">const</span> SkipList* list) &#123;</span><br><span class="line">  list_ = list;</span><br><span class="line">  node_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Valid</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> node_ != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Key&amp; SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">key</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">  <span class="keyword">return</span> node_-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Next</span>() &#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">  node_ = node_-&gt;<span class="built_in">Next</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Prev</span>() &#123;</span><br><span class="line">  <span class="comment">// Instead of using explicit &quot;prev&quot; links, we just search for the</span></span><br><span class="line">  <span class="comment">// last node that falls before key.</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">  node_ = list_-&gt;<span class="built_in">FindLessThan</span>(node_-&gt;key);</span><br><span class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class="line">    node_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Seek</span>(<span class="keyword">const</span> Key&amp; target) &#123;</span><br><span class="line">  node_ = list_-&gt;<span class="built_in">FindGreaterOrEqual</span>(target, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">SeekToFirst</span>() &#123;</span><br><span class="line">  node_ = list_-&gt;head_-&gt;<span class="built_in">Next</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">SeekToLast</span>() &#123;</span><br><span class="line">  node_ = list_-&gt;<span class="built_in">FindLast</span>();</span><br><span class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class="line">    node_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SkipList&lt;Key, Comparator&gt;::<span class="built_in">RandomHeight</span>() &#123;</span><br><span class="line">  <span class="comment">// Increase height with probability 1 in kBranching</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> kBranching = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> height = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (height &lt; kMaxHeight &amp;&amp; rnd_.<span class="built_in">OneIn</span>(kBranching)) &#123;</span><br><span class="line">    height++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(height &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">assert</span>(height &lt;= kMaxHeight);</span><br><span class="line">  <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> SkipList&lt;Key, Comparator&gt;::<span class="built_in">KeyIsAfterNode</span>(<span class="keyword">const</span> Key&amp; key, Node* n) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// null n is considered infinite</span></span><br><span class="line">  <span class="keyword">return</span> (n != <span class="literal">nullptr</span>) &amp;&amp; (<span class="built_in">compare_</span>(n-&gt;key, key) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::<span class="built_in">FindGreaterOrEqual</span>(<span class="keyword">const</span> Key&amp; key,</span><br><span class="line">                                              Node** prev) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="comment">// level从0开始编码，0 —— MaxHeight-1</span></span><br><span class="line">  <span class="keyword">int</span> level = <span class="built_in">GetMaxHeight</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 从最高层level开始查找</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 定位到当前level的下一个节点</span></span><br><span class="line">    Node* next = x-&gt;<span class="built_in">Next</span>(level);</span><br><span class="line">    <span class="comment">// key 大于next的key，说明不在当前区间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">KeyIsAfterNode</span>(key, next)) &#123;</span><br><span class="line">      <span class="comment">// Keep searching in this list</span></span><br><span class="line">      x = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// key在当前区间段内，则向更低的level中继续查找</span></span><br><span class="line">      <span class="comment">// 在查找的同时，对传入的参数prev进行设置，设置prev节点</span></span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">nullptr</span>) prev[level] = x;</span><br><span class="line">      <span class="comment">// 在最底层的level中找到相应位置</span></span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::<span class="built_in">FindLessThan</span>(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="built_in">GetMaxHeight</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(x == head_ || <span class="built_in">compare_</span>(x-&gt;key, key) &lt; <span class="number">0</span>);</span><br><span class="line">    Node* next = x-&gt;<span class="built_in">Next</span>(level);</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">nullptr</span> || <span class="built_in">compare_</span>(next-&gt;key, key) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::<span class="built_in">FindLast</span>()</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="built_in">GetMaxHeight</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Node* next = x-&gt;<span class="built_in">Next</span>(level);</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">SkipList&lt;Key, Comparator&gt;::<span class="built_in">SkipList</span>(Comparator cmp, Arena* arena)</span><br><span class="line">    : <span class="built_in">compare_</span>(cmp),</span><br><span class="line">      <span class="built_in">arena_</span>(arena),</span><br><span class="line">      <span class="built_in">head_</span>(<span class="built_in">NewNode</span>(<span class="number">0</span> <span class="comment">/* any key will do */</span>, kMaxHeight)),</span><br><span class="line">      <span class="built_in">max_height_</span>(<span class="number">1</span>),</span><br><span class="line">      <span class="built_in">rnd_</span>(<span class="number">0xdeadbeef</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kMaxHeight; i++) &#123;</span><br><span class="line">    head_-&gt;<span class="built_in">SetNext</span>(i, <span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SkipList&lt;Key, Comparator&gt;::<span class="built_in">Insert</span>(<span class="keyword">const</span> Key&amp; key) &#123;</span><br><span class="line">  <span class="comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></span><br><span class="line">  <span class="comment">// here since Insert() is externally synchronized.</span></span><br><span class="line">  <span class="comment">// 声明prev节点数组，代表插入位置的前一个节点</span></span><br><span class="line">  Node* prev[kMaxHeight];</span><br><span class="line">  <span class="comment">//使用FindGreaterOrEqual函数，找到第一个大于等于插入key的位置</span></span><br><span class="line">  Node* x = <span class="built_in">FindGreaterOrEqual</span>(key, prev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Our data structure does not allow duplicate insertion</span></span><br><span class="line">  <span class="built_in">assert</span>(x == <span class="literal">nullptr</span> || !<span class="built_in">Equal</span>(key, x-&gt;key));</span><br><span class="line">  <span class="comment">// 使用随机数获取该节点的插入高度</span></span><br><span class="line">  <span class="keyword">int</span> height = <span class="built_in">RandomHeight</span>();</span><br><span class="line">  <span class="keyword">if</span> (height &gt; <span class="built_in">GetMaxHeight</span>()) &#123;</span><br><span class="line">    <span class="comment">// 大于当前SkipList的最高高度的话，将多出来的高度的prev设置为哨兵节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">GetMaxHeight</span>(); i &lt; height; i++) &#123;</span><br><span class="line">      prev[i] = head_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// It is ok to mutate max_height_ without any synchronization</span></span><br><span class="line">    <span class="comment">// with concurrent readers.  A concurrent reader that observes</span></span><br><span class="line">    <span class="comment">// the new value of max_height_ will see either the old value of</span></span><br><span class="line">    <span class="comment">// new level pointers from head_ (nullptr), or a new value set in</span></span><br><span class="line">    <span class="comment">// the loop below.  In the former case the reader will</span></span><br><span class="line">    <span class="comment">// immediately drop to the next level since nullptr sorts after all</span></span><br><span class="line">    <span class="comment">// keys.  In the latter case the reader will use the new node.</span></span><br><span class="line">    <span class="comment">// 更新max_height_</span></span><br><span class="line">    max_height_.<span class="built_in">store</span>(height, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建要插入的节点对象x</span></span><br><span class="line">  x = <span class="built_in">NewNode</span>(key, height);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">    <span class="comment">// we publish a pointer to &quot;x&quot; in prev[i].</span></span><br><span class="line">    <span class="comment">// 首先将x的next指向prev的下一个节点</span></span><br><span class="line">    x-&gt;<span class="built_in">NoBarrier_SetNext</span>(i, prev[i]-&gt;<span class="built_in">NoBarrier_Next</span>(i));</span><br><span class="line">    <span class="comment">// 将prev指向x</span></span><br><span class="line">    prev[i]-&gt;<span class="built_in">SetNext</span>(i, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> SkipList&lt;Key, Comparator&gt;::<span class="built_in">Contains</span>(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = <span class="built_in">FindGreaterOrEqual</span>(key, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">nullptr</span> &amp;&amp; <span class="built_in">Equal</span>(key, x-&gt;key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本的数据结构主要介绍的是局部细节，没有过多的代码依赖，容易看懂。而真正困难的部分，是梳理清楚整体的流程和结构。这时自上而下就要容易很多，比如看看文档、架构图、流程图等，不至于在庞杂的代码细节中迷失。</p>
<p>下一篇会开始介绍 <code>LevelDB</code> 中的核心组件。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
</search>
