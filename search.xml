<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2021/06/17/About-Me/</url>
    <content><![CDATA[<blockquote>
<p>Done is better than perfect.</p>
</blockquote>
<p>姓名：潘许飞 - Gasol</p>
<p>学习/工作：HUST - WNLO</p>
<p>邮箱：<a href="mailto:&#49;&#49;&#x34;&#x32;&#x38;&#49;&#50;&#53;&#x32;&#x35;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#109;">&#49;&#49;&#x34;&#x32;&#x38;&#49;&#50;&#53;&#x32;&#x35;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#109;</a></p>
<p><img src="https://pic.imgdb.cn/item/60cb0de4844ef46bb21f61a5.jpg"></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>SPDK调研</title>
    <url>/2021/06/17/SPDK%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="一．SPDK简介"><a href="#一．SPDK简介" class="headerlink" title="一．SPDK简介"></a>一．SPDK简介</h2><h3 id="1-SPDK的起源"><a href="#1-SPDK的起源" class="headerlink" title="1.SPDK的起源"></a>1.SPDK的起源</h3><p>固态存储设备正在取代数据中心。目前这一代的闪存存储，比起传统的磁盘设备，在性能（performance）、功耗（power consumption）和机架密度（rack density）上具有显著的优势。这些优势将会继续增大，使闪存存储作为下一代存储设备进入市场。</p>
<p>用户使用现在的固态设备，比如Intel® SSD DC P3700 Series Non-Volatile Memory Express（NVMe）驱动，面临一个主要的挑战：因为吞吐量和延迟性能比传统的磁盘好太多，现在总的处理时间中，存储软件占用了更大的比例。换句话说，存储软件栈的性能和效率在整个存储系统中越来越重要。随着存储设备继续发展，它将面临远远超过正在使用的软件体系结构的风险（即存储设备受制于相关软件的不足而不能发挥全部性能），在接下来的几年中，存储设备将会继续发展到一个令人难以置信的地步。</p>
<p>为了帮助存储OEM（设备代工厂）和ISV（独立软件开发商）整合硬件，Intel构造了一系列驱动，以及一个完善的、端对端的参考存储体系结构，被命名为Storage Performance Development Kit（SPDK）。SPDK的目标是通过同时使用Intel的网络技术，处理技术和存储技术来提高突出显著的效率和性能。通过运行为硬件设计的软件，SPDK已经证明很容易达到每秒钟数百万次I/O读取，通过使用许多处理器核心和许多NVMe驱动去存储，而不需要额外卸载硬件。Intel在BSD license许可协议下通过Github分发提供其全部的Linux参考架构的源代码。博客、邮件列表和额外文档可以在spdk.io中找到。</p>
<span id="more"></span>
<h3 id="2-SPDK的整体架构"><a href="#2-SPDK的整体架构" class="headerlink" title="2.SPDK的整体架构"></a>2.SPDK的整体架构</h3><p>下图为SPDK的整体架构图：</p>
<p><img src="https://pic.imgdb.cn/item/60cb0904844ef46bb2ee63d9.png" alt="SPDK架构图"></p>
<p>按照自底层向上层的顺序，分为：</p>
<ul>
<li><p>硬件驱动</p>
<blockquote>
<p>NVMe Driver：SPDK的基础组件，这个高优化无锁的驱动提供了高扩展性，高效性和高性能。</p>
</blockquote>
<blockquote>
<p>Inter QuickData Technology：也称为Intel I/O Acceleration Technology（Inter IOAT，英特尔I/O加速技术），这是一种基于Xeon处理器平台上的copy offload引擎。通过提供用户空间访问，减少了DMA数据移动的阈值，允许对小尺寸I/O或NTB的更好利用。</p>
</blockquote>
</li>
<li><p>后端块设备</p>
<blockquote>
<p>NVMe over Fabrics（NVMe-oF）initiator：从程序员的角度来看，本地SPDK NVMe驱动和NVMe-oF启动器共享一套共同的API命令。这意味着，本地/远程复制非常容易实现。</p>
</blockquote>
<blockquote>
<p>Ceph RADOS Block Device（RBD）：使Ceph成为SPDK的后端设备，比如这可能允许Ceph用作另一个存储层。</p>
</blockquote>
<blockquote>
<p>Blobstore Block Device：由SPDK Blobstore分配的块设备，是虚拟机或数据库可以与之交互的虚拟设备。这些设备享有SPDK基础架构的优势，这意味着零锁定和令人难以置信的可扩展性能。</p>
</blockquote>
<blockquote>
<p>Linux Asynchrounous I/O（AIO）：允许SPDK与内核设备（比如机械硬盘）交互。</p>
</blockquote>
</li>
<li><p>存储服务</p>
<blockquote>
<p>Block device abstration layer（bdev）：这种通用的块设备抽象是连接到各种不同设备驱动和块设备的存储协议的粘合剂。还在块层中提供灵活的API用于额外的用户功能（磁盘阵列，压缩，去冗等等）。</p>
</blockquote>
<blockquote>
<p>Blobstore：为SPDK实现一个高精简的文件式语义（非POSIX）。这可以为数据库，容器，虚拟机或其他不依赖于大部分POSIX文件系统功能集（比如用户访问控制）的工作负载提供高性能基础。</p>
</blockquote>
</li>
<li><p>存储协议</p>
<blockquote>
<p>iSCSI target：建立了通过以太网的块流量规范，大约是内核LIO效率的两倍。现在的版本默认使用内核TCP/IP协议栈。</p>
</blockquote>
<blockquote>
<p>NVMe-oF target：实现了新NVMe-oF规范。虽然这取决于RDMA硬件，NVMe-oF的目标可以为每个CPU核提供高达40Gbps的流量。</p>
</blockquote>
<blockquote>
<p>vhost-scsi target：KVM/QEMU的功能利用了SPDK NVMe驱动，使得访客虚拟机访问存储设备时延迟更低，使得I/O密集型工作负载的整体CPU负载减低。</p>
</blockquote>
</li>
</ul>
<h2 id="二、SPDK的主要优势与关键技术"><a href="#二、SPDK的主要优势与关键技术" class="headerlink" title="二、SPDK的主要优势与关键技术"></a>二、SPDK的主要优势与关键技术</h2><h3 id="1-SPDK的主要优势与关键技术"><a href="#1-SPDK的主要优势与关键技术" class="headerlink" title="1.SPDK的主要优势与关键技术"></a>1.SPDK的主要优势与关键技术</h3><p>SPDK具有的优势主要包括：</p>
<blockquote>
<p>高性能、高拓展性、零拷贝、高度并行的访问、可以从用户空间直接访问SSD。</p>
</blockquote>
<p>SPDK通过使用多种关键技术来实现高性能：</p>
<ul>
<li><p>将所有必要的驱动程序移到用户空间中，这避免了系统调用，并允许从应用程序进行零拷贝访问。</p>
</li>
<li><p>通过轮询硬件来完成而不是依赖中断，这可以降低总延迟和延迟差异。</p>
</li>
<li><p>避免所有在I / O路径中的锁，而是依靠消息传递。</p>
</li>
</ul>
<p>SPDK的基础是用户空间，轮询模式，异步，无锁的NVMe驱动程序。这提供了零拷贝，高度并行的访问，可从用户空间应用程序直接访问SSD。该驱动程序被编写为具有单个公共标头的C库。</p>
<p>SPDK还提供了完整的块堆栈作为用户空间库，该库执行与操作系统中的块堆栈相同的许多操作。这包括统一不同存储设备之间的接口，排队以处理诸如内存不足或I / O挂起之类的情况以及逻辑卷管理。</p>
<p>最后，SPDK在这些组件之上提供了NVMe-oF，iSCSI和虚拟主机服务器，这些服务器能够通过网络或其他进程为磁盘提供服务。用于NVMe-oF和iSCSI的标准Linux内核启动器可与这些目标以及具有vhost的QEMU进行交互。与其他实现相比，这些服务器的CPU效率最高可提高一个数量级。这些目标可以用作如何实现高性能存储目标的示例，也可以用作生产部署的基础。</p>
<p><img src="https://pic.imgdb.cn/item/60cb0920844ef46bb2ef7f97.png" alt="SPDK IO Stack"></p>
<h2 id="三．SPDK关键技术介绍"><a href="#三．SPDK关键技术介绍" class="headerlink" title="三．SPDK关键技术介绍"></a>三．SPDK关键技术介绍</h2><h3 id="1-NVMe-Driver"><a href="#1-NVMe-Driver" class="headerlink" title="1.NVMe Driver"></a>1.NVMe Driver</h3><p>（1）NVMe Driver整体情况介绍</p>
<p>NVMe驱动程序是一个C语言库，可以直接链接到一个应用程序中，该应用程序对外提供与NVMe SSD的直接的、零拷贝数据传输。它是完全被动的，这意味着它不产生任何线程，并且仅响应于来自应用程序本身的函数调用而执行操作。该库通过直接将PCI BAR映射到本地进程并执行MMIO来控制NVMe设备。I / O是通过队列对异步提交的。</p>
<p>最近，对该库进行了改进，使其还可以通过基于Fabric的NVMe连接到远程NVMe设备。用户现在既可以通过本地PCI总线也可以通过NVMe over Fabrics，调用spdk_nvme_probe（），发现设备。</p>
<p>NVMe Driver的公共接口声明于spdk/nvme.h中。主要包括如下命令：</p>
<p><img src="https://pic.imgdb.cn/item/60cb093d844ef46bb2f0a087.png" alt="SPDK NVMe API"></p>
<p>（2）NVMe Driver关于IO提交的设计</p>
<p>NVMe Driver使用nvme_ns_cmd_xxx命令将IO提交到NVMe命名空间。NVMe驱动程序在命令中指定的队列对上将I / O请求作为NVMe提交队列条目提交。函数会立即返回，在IO命令完成之前就已经返回。应用程序必须通过调用<code>spdk_nvme_qpair_process_completions()</code>函数轮询队列对，以接收完成回调。</p>
<p>（3）NVMe Driver对于拓展性的支持</p>
<p>NVMe队列对（结构spdk_nvme_qpair）为I / O提供并行提交路径。I / O可以同时从不同的线程在多个队列对上提交。队列对不包含锁或原子，因此，给定的队列对一次只能由单个线程使用。NVMe驱动程序不强制执行此要求（这样做将需要锁定），并且违反此要求将导致未定义的行为。</p>
<p>允许的队列对数由NVMe SSD本身决定。该规范可以支持数千个，但是大多数设备支持32至128个。该规范不能保证每个队列对的性能，但是实际上，仅使用一个队列对就几乎可以实现设备的全部性能。例如，如果设备声称能够在队列深度128的情况下，每秒达到450,000 I / O，那么实际上驱动程序使用的是4个队列对（每个队列深度为32）还是单个队列对（队列深度为） 128则无关紧要。</p>
<p>鉴于以上所述，使用SPDK的应用程序最简单的线程模型是在池中生成固定数量的线程，并将单个NVMe队列对专用于每个线程。进一步的改进是将每个线程固定到一个单独的CPU内核，并且SPDK文档通常会互换使用“ CPU内核”和“线程”，因为我们牢记了这种线程模型。</p>
<p>NVMe驱动程序不对I / O路径进行任何锁定，因此只要每个新线程专用一个队列对和CPU内核，它就可以根据每个线程的性能进行线性扩展。为了充分利用这种扩展，应用程序应考虑组织其内部数据结构，以便将数据专门分配给单个线程。所有需要数据的操作都应通过向拥有线程发送请求来完成。与锁定体系结构相比，这导致了消息传递体系结构，并且将导致跨CPU内核的出色扩展。</p>
<h2 id="四．参考资料"><a href="#四．参考资料" class="headerlink" title="四．参考资料"></a>四．参考资料</h2><blockquote>
<p>1.Intel官网：《Introduction to the Storage Performance Development Kit (SPDK)》；链接：<a href="https://software.intel.com/content/www/cn/zh/develop/articles/introduction-to-the-storage-performance-development-kit-spdk.html?wapkw=spdk">https://software.intel.com/content/www/cn/zh/develop/articles/introduction-to-the-storage-performance-development-kit-spdk.html?wapkw=spdk</a></p>
</blockquote>
<blockquote>
<p>2.SPDK文档；链接：<a href="https://spdk.io/doc/about.html">https://spdk.io/doc/about.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>SPDK</category>
      </categories>
      <tags>
        <tag>SPDK</tag>
        <tag>OCSSD</tag>
        <tag>用户态IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtual OCSSD 环境搭建</title>
    <url>/2021/06/17/Virtual-OCSSD-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="一、Virtual-OpenChannel-SSD-环境配置"><a href="#一、Virtual-OpenChannel-SSD-环境配置" class="headerlink" title="一、Virtual OpenChannel SSD 环境配置"></a>一、Virtual OpenChannel SSD 环境配置</h2><p>1.下载Qemu-nvme的源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/OpenChannelSSD/qemu-nvme</span><br></pre></td></tr></table></figure>

<p>2.进入qemu-nvme目录下，运行配置脚本，make编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> qemu-nvme</span><br><span class="line">./configure --target-list=x86_64-softmmu --prefix=<span class="variable">$HOME</span>/qemu-nvme</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>3.在完成上述步骤后，开始正式配置环境。首先，在物理机上创建一个ocssd格式的文件，例如ocssd.img。</p>
<blockquote>
<p>（若提示ocssd参数无效等报错，可能是因为实际使用的是物理机内置的qemu-img，而不是qemu-nvme make编译后生成的qemu-img。将下列命令的qemu-img更改为qemu-nvme/qemu-img代替即可。）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-img create -f ocssd -o num_grp=2,num_pu=4,num_chk=60 ocssd.img</span><br></pre></td></tr></table></figure>

<p>4.创建一个文件，作为模拟的磁盘，用来安装linux系统。</p>
<blockquote>
<p>（在物理机上运行qemu虚拟机，虚拟机内加载模拟磁盘的文件与模拟ocssd的文件。最终的实验环境是在qemu虚拟机内部的linux子系统上运行。）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo qemu-img create -f raw /home/gasol/qemu-nvme/ubuntu40.raw 40G</span><br></pre></td></tr></table></figure>

<p>5.下载ubuntu镜像，并在第4步建立的模拟磁盘的文件中，安装ubuntu系统。</p>
<blockquote>
<p>（此时可能会提示qemu-system-x86_64: warning: host doesn’t support requested feature: CPUID.80000001H:ECX.svm [bit 2]。这是正常的，忽略即可。正常情况下，在输出提示信息后，会弹出新的安装窗口，点击安装即可）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-x86_64 -cdrom /home/polarsparc/ubuntu-18.04.1-desktop-amd64.iso -drive format=raw,file=/home/polarsparc/Downloads/VMs/vm-disk-1.raw -enable-kvm -m 2G -name vm-ubuntu-1</span><br></pre></td></tr></table></figure>

<p>6.在物理机系统上，挂载ocssd,并启动虚拟机。</p>
<blockquote>
<p>(注意：使用路径qemu-nvme/bin/下的qemu-system-x86_64运行，而不是采用系统内置的qemu-system-x86_64 )</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./bin/qemu-system-x86_64 -m 8G -enable-kvm ubuntu40.raw -blockdev ocssd,node-name=nvme01,file.driver=file,file.filename=ocssd.img -device nvme,drive=nvme01,serial=deadbeef,id=lnvm -cpu host</span><br></pre></td></tr></table></figure>

<p>7.在第6步虚拟机启动的情况下，利用VNC viewer连接，弹出窗口显示虚拟机运行情况。</p>
<blockquote>
<p>（若提示无vncviewer，安装对应包即可）（命令中连接的IP和端口与第6步的提示IP和端口相同）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vncviewer 127.0.0.1:5900</span><br></pre></td></tr></table></figure>

<p>8.在虚拟机启动后，可以通过运行以下命令，查看是否成功挂载ocssd设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nvme lnvm list</span><br></pre></td></tr></table></figure>

<h2 id="二、SPDK安装配置"><a href="#二、SPDK安装配置" class="headerlink" title="二、SPDK安装配置"></a>二、SPDK安装配置</h2><p>0.参考文档：<a href="https://spdk.io/doc/getting_started.html">https://spdk.io/doc/getting_started.html</a></p>
<p>1.按参考文档Getting started部分运行，即可编译安装SPDK，并可以通过运行<code>build/examples/identify</code>脚本列出系统上有效的NVME设备。</p>
<blockquote>
<p>（通过该脚本可以验证SPDK是否成功识别挂载的虚拟OCSSD）</p>
</blockquote>
<h2 id="三、关于可能遇到的git-clone与git-submodule速度过慢问题的解决方案"><a href="#三、关于可能遇到的git-clone与git-submodule速度过慢问题的解决方案" class="headerlink" title="三、关于可能遇到的git clone与git submodule速度过慢问题的解决方案"></a>三、关于可能遇到的git clone与git submodule速度过慢问题的解决方案</h2><p>0.参考文档：<a href="https://www.cnblogs.com/zhuchengchao/p/12076153.html">https://www.cnblogs.com/zhuchengchao/p/12076153.html</a></p>
<p>1.按照文档中的介绍，通过国内的gitee.com网站进行git clone，可以大幅度提升git clone的速率。</p>
<p>2.对于git submodule速度过慢的问题:</p>
<blockquote>
<p>例如在git clone spdk的代码后，若需要git submodule，只需打开spdk/.gitmodules，将其中需要下载的库通过gitee.com下载到本地，并修改.gitmodules内部的路径即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>QEMU</category>
      </categories>
      <tags>
        <tag>OCSSD</tag>
        <tag>QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/06/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>LevelDB源码分析——1.基本的数据结构</title>
    <url>/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="一．基本的数据结构"><a href="#一．基本的数据结构" class="headerlink" title="一．基本的数据结构"></a>一．基本的数据结构</h2><p>为了督促自己认真的阅读LevelDB源码，同时记录下相关的收获，避免阅后即忘，因此在Blog中记录下LevelDB源码分析的相关内容。</p>
<p>本文会介绍 LevelDB 中的基本数据结构，包括 <code>Slice</code>、<code>Hash</code>、<code>LRUCache</code>。</p>
<span id="more"></span>

<h3 id="1-字符串封装-Slice"><a href="#1-字符串封装-Slice" class="headerlink" title="1. 字符串封装 Slice"></a>1. 字符串封装 Slice</h3><p>Slice 定义于 <a href="https://github.com/google/leveldb/blob/master/include/leveldb/slice.h"><code>include/leveldb/slice.h</code></a>，源码不过百行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Slice is a simple structure containing a pointer into some external</span></span><br><span class="line"><span class="comment">// storage and a size.  The user of a Slice must ensure that the slice</span></span><br><span class="line"><span class="comment">// is not used after the corresponding external storage has been</span></span><br><span class="line"><span class="comment">// deallocated.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Multiple threads can invoke const methods on a Slice without</span></span><br><span class="line"><span class="comment">// external synchronization, but if any of the threads may call a</span></span><br><span class="line"><span class="comment">// non-const method, all threads accessing the same Slice must use</span></span><br><span class="line"><span class="comment">// external synchronization.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STORAGE_LEVELDB_INCLUDE_SLICE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORAGE_LEVELDB_INCLUDE_SLICE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/export.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"><span class="comment">//字符串处理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Slice</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create an empty slice.</span></span><br><span class="line">  <span class="built_in">Slice</span>() : <span class="built_in">data_</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">size_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to d[0,n-1].</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> <span class="keyword">char</span>* d, <span class="keyword">size_t</span> n) : <span class="built_in">data_</span>(d), <span class="built_in">size_</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to the contents of &quot;s&quot;</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> std::string&amp; s) : <span class="built_in">data_</span>(s.<span class="built_in">data</span>()), <span class="built_in">size_</span>(s.<span class="built_in">size</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to s[0,strlen(s)-1]</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s) : <span class="built_in">data_</span>(s), <span class="built_in">size_</span>(<span class="built_in">strlen</span>(s)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Intentionally copyable.</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> Slice&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  Slice&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Slice&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a pointer to the beginning of the referenced data</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the length (in bytes) of the referenced data</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true iff the length of the referenced data is zero</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_ == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the ith byte in the referenced data.</span></span><br><span class="line">  <span class="comment">// REQUIRES: n &lt; size()</span></span><br><span class="line">  <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &lt; <span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> data_[n];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Change this slice to refer to an empty array</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    size_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//移除数据的前n位</span></span><br><span class="line">  <span class="comment">// Drop the first &quot;n&quot; bytes from this slice.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove_prefix</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &lt;= <span class="built_in">size</span>());</span><br><span class="line">    data_ += n;</span><br><span class="line">    size_ -= n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a string that contains the copy of the referenced data.</span></span><br><span class="line">  <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">string</span>(data_, size_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Three-way comparison.  Returns value:</span></span><br><span class="line">  <span class="comment">//   &lt;  0 iff &quot;*this&quot; &lt;  &quot;b&quot;,</span></span><br><span class="line">  <span class="comment">//   == 0 iff &quot;*this&quot; == &quot;b&quot;,</span></span><br><span class="line">  <span class="comment">//   &gt;  0 iff &quot;*this&quot; &gt;  &quot;b&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//判断参数x是否是该slice的前缀</span></span><br><span class="line">  <span class="comment">// Return true iff &quot;x&quot; is a prefix of &quot;*this&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">starts_with</span><span class="params">(<span class="keyword">const</span> Slice&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((size_ &gt;= x.size_) &amp;&amp; (<span class="built_in">memcmp</span>(data_, x.data_, x.size_) == <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//成员变量：data_存储数据地址;size_记录数据长度</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;</span><br><span class="line">  <span class="keyword">size_t</span> size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">return</span></span> ((x.<span class="built_in">size</span>() == y.<span class="built_in">size</span>()) &amp;&amp;</span><br><span class="line">          (<span class="built_in">memcmp</span>(x.<span class="built_in">data</span>(), y.<span class="built_in">data</span>(), x.<span class="built_in">size</span>()) == <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123; <span class="keyword">return</span> !(x == y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Slice::compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> min_len = (size_ &lt; b.size_) ? size_ : b.size_;</span><br><span class="line">  <span class="keyword">int</span> r = <span class="built_in">memcmp</span>(data_, b.data_, min_len);</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size_ &lt; b.size_)</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_ &gt; b.size_)</span><br><span class="line">      r = +<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// STORAGE_LEVELDB_INCLUDE_SLICE_H_</span></span></span><br></pre></td></tr></table></figure>

<p>没有外部依赖，代码也非常清晰易懂。整个定义可以分为四个部分：构造、获取、修改和比较。</p>
<p><strong>构造</strong>：默认构造为空字符串，字符串构造提供了带长度和不带长度，并且支持默认的复制构造函数和赋值操作符（毕竟只有 <code>data_</code> 和 <code>size_</code> 两个属性）。</p>
<p><strong>获取</strong>：获取 <code>Slice</code> 的基本信息，支持导出为 <code>std::string</code>。</p>
<p><strong>修改</strong>：支持 <code>clear</code> 操作字符串清空，也支持 <code>remove_prefix</code> 将指定长度的前缀去除。注意 <code>data_</code> 的类型为 <code>const char *</code>，对应的字符串内容是不可修改的，<code>Slice</code> 只能修改字符串的起始位置。</p>
<p><strong>比较</strong>：<code>Slice::compare</code> 实现了非常严谨的字符串比较，返回 0/1/-1。注意为了提高性能，<code>operator==</code> 并没有直接调用 <code>Slice::compare</code>。</p>
<p>值得注意的是，<code>Slice</code> 本身并没有任何内存管理，仅仅是 C 风格字符串及其长度的封装。</p>
<h3 id="2-哈希函数-Hash"><a href="#2-哈希函数-Hash" class="headerlink" title="2. 哈希函数 Hash"></a>2. 哈希函数 Hash</h3><p>哈希函数定义于 <a href="https://github.com/google/leveldb/blob/master/util/hash.cc"><code>util/hash.[h/cc]</code></a>，源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/hash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/coding.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The FALLTHROUGH_INTENDED macro can be used to annotate implicit fall-through</span></span><br><span class="line"><span class="comment">// between switch labels. The real definition should be provided externally.</span></span><br><span class="line"><span class="comment">// This one is a fallback version for unsupported compilers.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FALLTHROUGH_INTENDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALLTHROUGH_INTENDED \</span></span><br><span class="line"><span class="meta">  do &#123;                       \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次按照四字节长度读取字节流中的数据 w，并使用普通的哈希函数计算哈希值。</span></span><br><span class="line"><span class="comment"> * 计算过程中使用 uint32_t 的自然溢出特性。四字节读取则为了加速，最终可能剩下 3/2/1 个多余的字节，</span></span><br><span class="line"><span class="comment"> * 使用 switch 语句补充计算，以实现最好的性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> n, <span class="keyword">uint32_t</span> seed)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Similar to murmur hash</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> m = <span class="number">0xc6a4a793</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> r = <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* limit = data + n;</span><br><span class="line">  <span class="keyword">uint32_t</span> h = seed ^ (n * m);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick up four bytes at a time</span></span><br><span class="line">  <span class="keyword">while</span> (data + <span class="number">4</span> &lt;= limit) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> w = <span class="built_in">DecodeFixed32</span>(data);</span><br><span class="line">    data += <span class="number">4</span>;</span><br><span class="line">    h += w;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= (h &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick up remaining bytes</span></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (limit - data) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">      FALLTHROUGH_INTENDED;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">      FALLTHROUGH_INTENDED;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">0</span>]);</span><br><span class="line">      h *= m;</span><br><span class="line">      h ^= (h &gt;&gt; r);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p>每次按照四字节长度读取字节流中的数据 <code>w</code>，并使用普通的哈希函数计算哈希值。计算过程中使用 <code>uint32_t</code> 的自然溢出特性。四字节读取则为了加速，最终可能剩下 3/2/1 个多余的字节，使用 <code>switch</code> 语句补充计算，以实现最好的性能。</p>
<p>这里 <code>FALLTHROUGH_INTENDED</code> 宏并无实际作用，仅仅作为一种“我确定我这里想跳过”的标志。<code>do &#123;&#125; while(0)</code> 对代码无影响，这种写法也会出现在一些多行的宏定义里（见<a href="https://stackoverflow.com/questions/257418/do-while-0-what-is-it-good-for">链接</a>）。</p>
<p>LevelDB 中哈希表和布隆过滤器会使用到该哈希函数。</p>
<h3 id="3-缓存-LRUCache"><a href="#3-缓存-LRUCache" class="headerlink" title="3. 缓存 LRUCache"></a>3. 缓存 LRUCache</h3><p>LevelDB 中使用的是 Least Recently Used Cache，即最近最少使用缓存。缓存接口定义于 <a href="https://github.com/google/leveldb/blob/master/include/leveldb/cache.h"><code>include/leveldb/cache.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Cache is an interface that maps keys to values.  It has internal</span></span><br><span class="line"><span class="comment">// synchronization and may be safely accessed concurrently from</span></span><br><span class="line"><span class="comment">// multiple threads.  It may automatically evict entries to make room</span></span><br><span class="line"><span class="comment">// for new entries.  Values have a specified charge against the cache</span></span><br><span class="line"><span class="comment">// capacity.  For example, a cache where the values are variable</span></span><br><span class="line"><span class="comment">// length strings, may use the length of the string as the charge for</span></span><br><span class="line"><span class="comment">// the string.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A builtin cache implementation with a least-recently-used eviction</span></span><br><span class="line"><span class="comment">// policy is provided.  Clients may use their own implementations if</span></span><br><span class="line"><span class="comment">// they want something more sophisticated (like scan-resistance, a</span></span><br><span class="line"><span class="comment">// custom eviction policy, variable cache sizing, etc.)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STORAGE_LEVELDB_INCLUDE_CACHE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORAGE_LEVELDB_INCLUDE_CACHE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/export.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/slice.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//仅依赖Slice</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Cache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new cache with a fixed size capacity.  This implementation</span></span><br><span class="line"><span class="comment">// of Cache uses a least-recently-used eviction policy.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认采用LRU替换策略</span></span><br><span class="line"><span class="function">LEVELDB_EXPORT Cache* <span class="title">NewLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Cache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cache</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//=delete表示编译器不生成默认构造函数。作用是，避免以下2个函数被调用，避免拷贝</span></span><br><span class="line">  <span class="built_in">Cache</span>(<span class="keyword">const</span> Cache&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Cache&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Cache&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Destroys all existing entries by calling the &quot;deleter&quot;</span></span><br><span class="line">  <span class="comment">// function that was passed to the constructor.</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Cache</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Opaque handle to an entry stored in the cache.</span></span><br><span class="line">  <span class="comment">//定义的 Handle 仅作为指针类型使用，实际上使用 void * 也并无区别，Handle 增加语意而已</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Handle</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert a mapping from key-&gt;value into the cache and assign it</span></span><br><span class="line">  <span class="comment">// the specified charge against the total cache capacity.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Returns a handle that corresponds to the mapping.  The caller</span></span><br><span class="line">  <span class="comment">// must call this-&gt;Release(handle) when the returned mapping is no</span></span><br><span class="line">  <span class="comment">// longer needed.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// When the inserted entry is no longer needed, the key and</span></span><br><span class="line">  <span class="comment">// value will be passed to &quot;deleter&quot;.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the cache has no mapping for &quot;key&quot;, returns nullptr.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Else return a handle that corresponds to the mapping.  The caller</span></span><br><span class="line">  <span class="comment">// must call this-&gt;Release(handle) when the returned mapping is no</span></span><br><span class="line">  <span class="comment">// longer needed.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release a mapping returned by a previous Lookup().</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must not have been released yet.</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must have been returned by a method on *this.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Release</span><span class="params">(Handle* handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the value encapsulated in a handle returned by a</span></span><br><span class="line">  <span class="comment">// successful Lookup().</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must not have been released yet.</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must have been returned by a method on *this.</span></span><br><span class="line">  <span class="comment">// 获取lookup()操作成功返回的Handle指向的表项中的Value</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">Value</span><span class="params">(Handle* handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the cache contains entry for key, erase it.  Note that the</span></span><br><span class="line">  <span class="comment">// underlying entry will be kept around until all existing handles</span></span><br><span class="line">  <span class="comment">// to it have been released.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a new numeric id.  May be used by multiple clients who are</span></span><br><span class="line">  <span class="comment">// sharing the same cache to partition the key space.  Typically the</span></span><br><span class="line">  <span class="comment">// client will allocate a new id at startup and prepend the id to</span></span><br><span class="line">  <span class="comment">// its cache keys.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span> <span class="title">NewId</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove all cache entries that are not actively in use.  Memory-constrained</span></span><br><span class="line">  <span class="comment">// applications may wish to call this method to reduce memory usage.</span></span><br><span class="line">  <span class="comment">// Default implementation of Prune() does nothing.  Subclasses are strongly</span></span><br><span class="line">  <span class="comment">// encouraged to override the default implementation.  A future release of</span></span><br><span class="line">  <span class="comment">// leveldb may change Prune() to a pure abstract method.</span></span><br><span class="line">  <span class="comment">// 修建所有不活跃的表项。适合对内存有限制的应用</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an estimate of the combined charges of all elements stored in the</span></span><br><span class="line">  <span class="comment">// cache.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// STORAGE_LEVELDB_INCLUDE_CACHE_H_</span></span></span><br></pre></td></tr></table></figure>

<p>接口仅依赖 <code>Slice</code>，接口也很容易看懂。<code>Cache</code> 中定义的 <code>Handle</code> 仅作为指针类型使用，实际上使用 <code>void *</code> 也并无区别，<code>Handle</code> 增加语意而已。</p>
<p><code>NewLRUCache</code> 作为工厂函数，可以生产一个 <code>LRUCache</code>，其定义于 <a href="https://github.com/google/leveldb/blob/master/util/cache.cc"><code>util/cache.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cache* <span class="title">NewLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ShardedLRUCache</span>(capacity); &#125;</span><br></pre></td></tr></table></figure>

<p><code>LRUCahce</code> 的实现依靠双向环形链表和哈希表。其中双向环形链表维护 <code>Recently</code> 属性，哈希表维护 <code>Used</code> 属性。双向环形链表和哈希表的节点信息都存储于 <code>LRUHandle</code> 结构中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUHandle</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>* value;</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*deleter)(<span class="keyword">const</span> Slice&amp;, <span class="keyword">void</span>* value);</span><br><span class="line">  LRUHandle* next_hash;</span><br><span class="line">  LRUHandle* next;</span><br><span class="line">  LRUHandle* prev;</span><br><span class="line">  <span class="keyword">size_t</span> charge;  <span class="comment">// TODO(opt): Only allow uint32_t?</span></span><br><span class="line">  <span class="keyword">size_t</span> key_length;</span><br><span class="line">  <span class="keyword">bool</span> in_cache;     <span class="comment">// Whether entry is in the cache.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> refs;     <span class="comment">// References, including cache reference, if present.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hash;     <span class="comment">// Hash of key(); used for fast sharding and comparisons</span></span><br><span class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next_ is only equal to this if the LRU handle is the list head of an</span></span><br><span class="line">    <span class="comment">// empty list. List heads never have meaningful keys.</span></span><br><span class="line">    <span class="built_in">assert</span>(next != <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>依次解释每一项属性：</p>
<ol>
<li><code>value</code> 为缓存存储的数据，类型无关；</li>
<li><code>deleter</code> 为键值对的析构函数指针；</li>
<li><code>next_hash</code> 为开放式哈希表中同一个桶下存储链表时使用的指针；</li>
<li><code>next</code> 和 <code>prev</code> 自然是双向环形链接的前后指针；</li>
<li><code>charge</code> 为当前节点的缓存费用，比如一个字符串的费用可能就是它的长度；</li>
<li><code>key_length</code> 为 <code>key</code> 的长度；</li>
<li><code>in_cache</code> 为节点是否在缓存里的标志；</li>
<li><code>refs</code> 为引用计数，当计数为 0 时则可以用 <code>deleter</code> 清理掉；</li>
<li><code>hash</code> 为 <code>key</code> 的哈希值；</li>
<li><code>key_data</code> 为变长的 <code>key</code> 数据，最小长度为 1，<code>malloc</code> 时动态指定长度。</li>
</ol>
<p>接着看哈希表的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">HandleTable</span>() : <span class="built_in">length_</span>(<span class="number">0</span>), <span class="built_in">elems_</span>(<span class="number">0</span>), <span class="built_in">list_</span>(<span class="literal">nullptr</span>) &#123; <span class="built_in">Resize</span>(); &#125;</span><br><span class="line">  ~<span class="built_in">HandleTable</span>() &#123; <span class="keyword">delete</span>[] list_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = <span class="built_in">FindPointer</span>(h-&gt;<span class="built_in">key</span>(), h-&gt;hash);</span><br><span class="line">    LRUHandle* old = *ptr;</span><br><span class="line">    h-&gt;next_hash = (old == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;next_hash);</span><br><span class="line">    *ptr = h;</span><br><span class="line">    <span class="keyword">if</span> (old == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      ++elems_;</span><br><span class="line">      <span class="keyword">if</span> (elems_ &gt; length_) &#123;</span><br><span class="line">        <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">        <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">        <span class="built_in">Resize</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = <span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">    LRUHandle* result = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      *ptr = result-&gt;next_hash;</span><br><span class="line">      --elems_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The table consists of an array of buckets where each bucket is</span></span><br><span class="line">  <span class="comment">// a linked list of cache entries that hash into the bucket.</span></span><br><span class="line">  <span class="comment">// 这个表由一个存储桶数组组成，每个存储桶是一个散列到存储桶中的缓存条目的链表。</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length_;   <span class="comment">//存储桶的数量</span></span><br><span class="line">  <span class="keyword">uint32_t</span> elems_;    <span class="comment">//当前哈希表的实际元素个数</span></span><br><span class="line">  LRUHandle** list_;  <span class="comment">//桶数组。实际存储的数据内容，底层结构</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a pointer to slot that points to a cache entry that</span></span><br><span class="line">  <span class="comment">// matches key/hash.  If there is no such cache entry, return a</span></span><br><span class="line">  <span class="comment">// pointer to the trailing slot in the corresponding linked list.</span></span><br><span class="line">  <span class="comment">// 根据指定的key与hash，返回对应的双重指针。</span></span><br><span class="line">  <span class="comment">// (先根据Hash值与存储桶数目length_，找到list_中对应的桶，然后再根据hash与key寻找，避免hash冲突)</span></span><br><span class="line">  <span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="literal">nullptr</span> &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;<span class="built_in">key</span>())) &#123;</span><br><span class="line">      ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Resize 则根据存储的节点数，对哈希表进行缩放。</span></span><br><span class="line"><span class="comment">   * 如果不缩放，这样的结构会退化到链表的复杂度。</span></span><br><span class="line"><span class="comment">   * 使用 2 的幂可以规避掉哈希值的模除，同样可以加速。</span></span><br><span class="line"><span class="comment">   * Resize时会遍历节点，将其从原位置取出，重新计算哈希值放到新位置，</span></span><br><span class="line"><span class="comment">   * 每次会加到桶中链表的头部。Resize 过程中链表需要拒绝其他请求。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 值得注意的是：新的桶的数目（新的length_）是根据 现有的存储的实际数据的个数 来决定的。</span></span><br><span class="line"><span class="comment">   * 使得new_length &gt;= 实际元素个数。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> new_length = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (new_length &lt; elems_) &#123;</span><br><span class="line">      new_length *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LRUHandle** new_list = <span class="keyword">new</span> LRUHandle*[new_length];</span><br><span class="line">    <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) &#123;</span><br><span class="line">      LRUHandle* h = list_[i];</span><br><span class="line">      <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        LRUHandle* next = h-&gt;next_hash;</span><br><span class="line">        <span class="keyword">uint32_t</span> hash = h-&gt;hash;</span><br><span class="line">        LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)];</span><br><span class="line">        h-&gt;next_hash = *ptr;</span><br><span class="line">        *ptr = h;</span><br><span class="line">        h = next;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(elems_ == count);</span><br><span class="line">    <span class="keyword">delete</span>[] list_;</span><br><span class="line">    list_ = new_list;</span><br><span class="line">    length_ = new_length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个标准的开放式哈希实现。属性中 <code>length_</code> 存储桶的数量，<code>elems_</code> 存储哈希表中节点数，<code>list_</code> 则为桶数组。每一个桶里存储 <code>hash</code> 值相同的一系列节点，这些节点构成一个链表，通过 <code>next_hash</code> 属性连接。</p>
<p><code>FindPointer</code> 函数返回一个二级指针。无论是 <code>list_[i]</code> 还是 <code>entry-&gt;next_hash</code>，均为 <code>LRUHandle *</code>，那么一个节点总会有一个正确的 <code>LRUHandle *</code> 变量指向它，该函数就返回这个变量的指针。说起来有点绕，仔细看懂就好。</p>
<p>看懂后，理解 <code>Insert</code> 和 <code>Remove</code> 都不难。<code>Resize</code> 则根据存储的节点数，对哈希表进行缩放。如果不缩放，这样的结构会退化到链表的复杂度。使用 2 的幂可以规避掉哈希值的模除，同样可以加速。<code>Resize</code> 时会遍历每一个节点，将其从原位置取出，重新计算哈希值放到新位置，每次会加到桶中链表的头部。<code>Resize</code> 过程中链表需要拒绝其他请求。</p>
<p>最后看 <code>LRUCache</code> 的实现就很简单了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A single shard of sharded cache.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LRUCache</span>();</span><br><span class="line">  ~<span class="built_in">LRUCache</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Separate from constructor so caller can easily make an array of LRUCache</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetCapacity</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> </span>&#123; capacity_ = capacity; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Like Cache methods, but with an extra &quot;hash&quot; parameter.</span></span><br><span class="line">  <span class="function">Cache::Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span></span>;</span><br><span class="line">  <span class="function">Cache::Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Cache::Handle* handle)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> usage_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Remove</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Append</span><span class="params">(LRUHandle* list, LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">FinishErase</span><span class="params">(LRUHandle* e)</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialized before use.</span></span><br><span class="line">  <span class="comment">// 初始化的容量</span></span><br><span class="line">  <span class="keyword">size_t</span> capacity_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mutex_ protects the following state.</span></span><br><span class="line">  <span class="comment">// 锁,用来保护下列的状态</span></span><br><span class="line">  <span class="keyword">mutable</span> port::Mutex mutex_;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> usage_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * LRUCache 中存储了两条链表，lru_ 和 in_use_，</span></span><br><span class="line"><span class="comment">   * 分别记录普通节点和外部正在使用中的节点。外部正在使用中的节点是不可删除的，</span></span><br><span class="line"><span class="comment">   * 将二者区分开也方便做对应的清理。Ref 和 Unref 分别增删引用计数，</span></span><br><span class="line"><span class="comment">   * 并完成节点在 lru_ 和 in_use_ 的交换，以及计数为 0 时做最后的删除。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 双向链表，会将最新使用的节点放到链表的末端。这样在容量超标时，</span></span><br><span class="line"><span class="comment">   * 删除链表头部的、长时间未用的节点即可。该逻辑实现于 Insert 函数的结尾。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dummy head of LRU list.</span></span><br><span class="line">  <span class="comment">// lru.prev is newest entry, lru.next is oldest entry.</span></span><br><span class="line">  <span class="comment">// Entries have refs==1 and in_cache==true.</span></span><br><span class="line">  <span class="function">LRUHandle lru_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dummy head of in-use list.</span></span><br><span class="line">  <span class="comment">// Entries are in use by clients, and have refs &gt;= 2 and in_cache==true.</span></span><br><span class="line">  <span class="function">LRUHandle in_use_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">HandleTable table_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache::<span class="built_in">LRUCache</span>() : <span class="built_in">capacity_</span>(<span class="number">0</span>), <span class="built_in">usage_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Make empty circular linked lists.</span></span><br><span class="line">  lru_.next = &amp;lru_;</span><br><span class="line">  lru_.prev = &amp;lru_;</span><br><span class="line">  in_use_.next = &amp;in_use_;</span><br><span class="line">  in_use_.prev = &amp;in_use_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRUCache::~<span class="built_in">LRUCache</span>() &#123;</span><br><span class="line">  <span class="built_in">assert</span>(in_use_.next == &amp;in_use_);  <span class="comment">// Error if caller has an unreleased handle</span></span><br><span class="line">  <span class="keyword">for</span> (LRUHandle* e = lru_.next; e != &amp;lru_;) &#123;</span><br><span class="line">    LRUHandle* next = e-&gt;next;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;in_cache);</span><br><span class="line">    e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;refs == <span class="number">1</span>);  <span class="comment">// Invariant of lru_ list.</span></span><br><span class="line">    <span class="built_in">Unref</span>(e);</span><br><span class="line">    e = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加引用计数。</span></span><br><span class="line"><span class="comment">// 若引用计数为1且in_cache==true，则将其从原链表中移除，添加到in_use链表的末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Ref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">1</span> &amp;&amp; e-&gt;in_cache) &#123;  <span class="comment">// If on lru_ list, move to in_use_ list.</span></span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;in_use_, e);</span><br><span class="line">  &#125;</span><br><span class="line">  e-&gt;refs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少引用计数。</span></span><br><span class="line"><span class="comment">// 若减少后引用计数为0，则删除对应空间。否则，将其从原链表中移除，添加到lru_链表的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Unref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(e-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">  e-&gt;refs--;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">0</span>) &#123;  <span class="comment">// Deallocate.</span></span><br><span class="line">    <span class="built_in">assert</span>(!e-&gt;in_cache);</span><br><span class="line">    (*e-&gt;deleter)(e-&gt;<span class="built_in">key</span>(), e-&gt;value);</span><br><span class="line">    <span class="built_in">free</span>(e);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;in_cache &amp;&amp; e-&gt;refs == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// No longer in use; move to lru_ list.</span></span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;lru_, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Remove</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  e-&gt;next-&gt;prev = e-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Append</span><span class="params">(LRUHandle* list, LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make &quot;e&quot; newest entry by inserting just before *list</span></span><br><span class="line">  e-&gt;next = list;</span><br><span class="line">  e-&gt;prev = list-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e;</span><br><span class="line">  e-&gt;next-&gt;prev = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过HandleTable哈希表查询，并添加引用计数</span></span><br><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  LRUHandle* e = table_.<span class="built_in">Lookup</span>(key, hash);</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">Ref</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减少引用计数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Release</span><span class="params">(Cache::Handle* handle)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">Unref</span>(<span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">void</span>* value))</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  LRUHandle* e =</span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  e-&gt;deleter = deleter;</span><br><span class="line">  e-&gt;charge = charge;</span><br><span class="line">  e-&gt;key_length = key.<span class="built_in">size</span>();</span><br><span class="line">  e-&gt;hash = hash;</span><br><span class="line">  e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">  e-&gt;refs = <span class="number">1</span>;  <span class="comment">// for the returned handle.</span></span><br><span class="line">  std::<span class="built_in">memcpy</span>(e-&gt;key_data, key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (capacity_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    e-&gt;refs++;  <span class="comment">// for the cache&#x27;s reference.</span></span><br><span class="line">    e-&gt;in_cache = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;in_use_, e);</span><br><span class="line">    usage_ += charge;</span><br><span class="line">    <span class="comment">//在哈希表HandleTable中插入新节点，同时在链表中删除 table_.Insert()返回的旧节点</span></span><br><span class="line">    <span class="built_in">FinishErase</span>(table_.<span class="built_in">Insert</span>(e));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// don&#x27;t cache. (capacity_==0 is supported and turns off caching.)</span></span><br><span class="line">    <span class="comment">// next is read by key() in an assert, so it must be initialized</span></span><br><span class="line">    e-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 双向链表，会将最新使用的节点放到链表的末端。</span></span><br><span class="line">  <span class="comment">// 这样在容量超标时，删除链表头部的、长时间未用的节点即可。</span></span><br><span class="line">  <span class="keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123;</span><br><span class="line">    LRUHandle* old = lru_.next;</span><br><span class="line">    <span class="built_in">assert</span>(old-&gt;refs == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//若容量超标，在哈希表与链表中都删除对应的节点</span></span><br><span class="line">    <span class="keyword">bool</span> erased = <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(old-&gt;<span class="built_in">key</span>(), old-&gt;hash));</span><br><span class="line">    <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">      <span class="built_in">assert</span>(erased);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If e != nullptr, finish removing *e from the cache; it has already been</span></span><br><span class="line"><span class="comment">// removed from the hash table.  Return whether e != nullptr.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LRUCache::FinishErase</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;in_cache);</span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">    usage_ -= e-&gt;charge;</span><br><span class="line">    <span class="built_in">Unref</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> e != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(key, hash));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Prune</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (lru_.next != &amp;lru_) &#123;</span><br><span class="line">    LRUHandle* e = lru_.next;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;refs == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> erased = <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(e-&gt;<span class="built_in">key</span>(), e-&gt;hash));</span><br><span class="line">    <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">      <span class="built_in">assert</span>(erased);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LRUCache</code> 中存储了两条链表，<code>lru_</code> 和 <code>in_use_</code>，分别记录普通节点和外部正在使用中的节点。外部正在使用中的节点是不可删除的，将二者区分开也方便做对应的清理。<code>Ref</code> 和 <code>Unref</code> 分别增删引用计数，并完成节点在 <code>lru_</code> 和 <code>in_use_</code> 的交换，以及计数为 0 时做最后的删除。</p>
<p>双向链表，会将最新使用的节点放到链表的末端。这样在容量超标时，删除链表头部的、长时间未用的节点即可。该逻辑实现于 <code>Insert</code> 函数的结尾。</p>
<p><code>LRUCache</code> 中在添删查操作中均使用互斥锁完成额外同步。<code>LevelDB</code> 中的锁将在后续文章中详细介绍。</p>
<p>最后看分片 <code>ShardedLRUCache</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShardBits = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShards = <span class="number">1</span> &lt;&lt; kNumShardBits;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分片LRUCache</span></span><br><span class="line"><span class="comment">// LevelDB 默认将 LRUCache 分为2^4块，取哈希值的高 4 位作为分片的位置。</span></span><br><span class="line"><span class="comment">// 分片可以提高查询和插入的速度，减少锁的压力，是提高缓存性能的常用方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//LRUCache的数组，包含2^4=16个LRUCache</span></span><br><span class="line">  LRUCache shard_[kNumShards];</span><br><span class="line">  port::Mutex id_mutex_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_id_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对Slice进行Hash操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">HashSlice</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Hash</span>(s.<span class="built_in">data</span>(), s.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对hash值进行右移，仅保留高4位作为分片的位置</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">Shard</span><span class="params">(<span class="keyword">uint32_t</span> hash)</span> </span>&#123; <span class="keyword">return</span> hash &gt;&gt; (<span class="number">32</span> - kNumShardBits); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ShardedLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> : last_id_(<span class="number">0</span>) &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> per_shard = (capacity + (kNumShards - <span class="number">1</span>)) / kNumShards;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].<span class="built_in">SetCapacity</span>(per_shard);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">ShardedLRUCache</span>() <span class="keyword">override</span> &#123;&#125;</span><br><span class="line">  <span class="function">Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">    <span class="keyword">return</span> shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Insert</span>(key, hash, value, charge, deleter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">    <span class="keyword">return</span> shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Lookup</span>(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Handle* handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    LRUHandle* h = <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle);</span><br><span class="line">    shard_[<span class="built_in">Shard</span>(h-&gt;hash)].<span class="built_in">Release</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">    shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Erase</span>(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">Value</span><span class="params">(Handle* handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle)-&gt;value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">NewId</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;id_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ++(last_id_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].<span class="built_in">Prune</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      total += shard_[s].<span class="built_in">TotalCharge</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>LevelDB</code> 默认将 <code>LRUCache</code> 分为 2^424 块，取哈希值的高 4 位作为分片的位置。分片可以提高查询和插入的速度，减少锁的压力，是提高缓存性能的常用方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文简单介绍了 <code>LevelDB</code> 中的 <code>Slice</code>、<code>Hash</code> 和 <code>LRUCache</code> 的实现。慢慢会觉得代码中的每个细节都是有意义的，不可忽略。<code>LevelDB</code> 源代码不超过 2万行，非常推荐学习 C++ 的同学阅读。建议可以先读 <code>util</code> 部分，这里是通用的数据结构，没有太多依赖。</p>
<p>下一篇会继续介绍 <code>LevelDB</code> 中的其他数据结构，包括布隆过滤器、内存池和跳表。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码分析——0.前置知识</title>
    <url>/2022/02/05/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%940.%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="零．前置知识"><a href="#零．前置知识" class="headerlink" title="零．前置知识"></a>零．前置知识</h2><p>本节为LevelDB源码分析的第0章，主要介绍LevelDB相关的前置知识。包括：<code>LSM Tree</code>、<code>Bloom Filter</code>。</p>
<span id="more"></span>

<h3 id="1-LSM-Tree"><a href="#1-LSM-Tree" class="headerlink" title="1. LSM Tree"></a>1. LSM Tree</h3><p>LSM-Tree(Log-Structured Merged-tree) 现如今已经被广泛应用在了各个NoSQL 存储系统中，如BigTable, Dynamo, HBase, Cassandra, LevelDB, RocksDB 和 AsterixDB。</p>
<p>相比于传统的in-place updates(就地更新) 索引结构，LSM-tree 第一次写入都缓存到内存中，并通过后台的flush来顺序追加到磁盘中，也就是out-of-place updates。 LSM-tree这样的实现方式有非常多的优点，包括<strong>写性能的提升、较高的空间利用率、简单的并发控制和异常恢复</strong>等。这些优点使LSM树可以服务于多种场景，如Facebook开发的基于LSM-Tree的存储引擎 RocksDB， 被广泛应用在实时数据处理/图数据处理/流式数据处理以及 OLTP(on line transaction processing) 等多种workload。</p>
<h4 id="1-1-LSM-Tree的历史"><a href="#1-1-LSM-Tree的历史" class="headerlink" title="1.1 LSM Tree的历史"></a>1.1 LSM Tree的历史</h4><p>通常，索引结构可以选择两种策略来处理更新，即就地更新和非就地更新。 就地更新结构（例如B +树）直接覆盖旧记录以存储新更新。 例如，在图1a中，为了将与键k1相关的值从v1更新到v4，直接修改索引条目（k1，v1）以应用此更新。 </p>
<p><img src="https://hardcore.feishu.cn/space/api/box/stream/download/asynccode/?code=YWNjNDQ2OWIwZTMyNTQ2YmRhMDRjOWU5MzhlZDBiYWRfY2R1TTBaeXI4MXZvd3dpUFE0aEVSTEt5QWw3NVlzVnpfVG9rZW46Ym94Y25tRWJrcUVmV0FQcXNqd0k5TXZlMXhlXzE2NDQ0OTIyMTU6MTY0NDQ5NTgxNV9WNA" alt="img"></p>
<p>由于仅存储每个记录的最新版本，因此通常对这些结构可以进行读取优化。 但是，这种设计会牺牲写入性能，因为更新会导致随机I / O。 而且，索引页通过更新和删除操作会产生分段，从而降低了空间利用率。</p>
<p><img src="https://hardcore.feishu.cn/space/api/box/stream/download/asynccode/?code=NzU0M2VmNjI1NTlhNjcwMWNkNTY3OWY3YzY2ODMwM2JfR3JVdTdqN0E5OW10SEdrU1RxdVlubXVpZ0xuSnlpMEhfVG9rZW46Ym94Y25lQXFqMlpoQ29uSlpqRjdYblR6MjZnXzE2NDQ0OTIyMTU6MTY0NDQ5NTgxNV9WNA" alt="img"></p>
<p><img src="https://hardcore.feishu.cn/space/api/box/stream/download/asynccode/?code=NGI0ZmZjZDczNmM0NGU3NTA5YWFkYzJiZmFhNDM5ODFfTjNER3ZvT0VTMEdrNUd5TXl2OGlQNFdlSk1IQVdBenNfVG9rZW46Ym94Y25tR3lzM05tRzVCTzBKUm14OUZpMWxlXzE2NDQ0OTIyMTU6MTY0NDQ5NTgxNV9WNA" alt="img"></p>
<p>相反，out-of-update结构（例如LSM树）始终将更新变化存储到新位置，而不是覆盖旧条目。 例如，在图1b中，更新（k1，v4）被存储到一个新位置，而不是直接更新旧条目（k1，v1）。 该设计可以利用顺序I / O来处理写操作，因此可以提高写性能。 通过不覆盖旧数据，它也可以简化恢复过程。 但是，该设计的主要问题是，由于记录可能存储在多个位置中的任何一个位置，因此牺牲了读取性能。 此外，这些结构通常需要单独的数据重组过程以不断提高存储和查询效率。</p>
<p>顺序进行out-of-places更新的想法并不新鲜； </p>
<ul>
<li>自1970年代以来，它已成功地应用于数据库系统。 差异文件于1976年提出，是out-of-places更新结构的早期示例。 在这种设计中，所有更新都首先应用于差异文件，该文件定期与主文件合并。 </li>
<li>在1980年代，Postgres项目开创了日志结构数据库存储的想法。 Postgres将所有写入追加到顺序日志中，从而实现快速恢复和基于时间戳的查询。 它使用称为vacuum cleaner的后台进程连续从日志中收集并去除过时的记录——垃圾收集。 文件系统社区采用了类似的想法来充分利用磁盘写带宽，例如在日志结构文件系统（LFS）中。</li>
</ul>
<p>在LSM树之前，用于日志结构化存储的方法存在几个关键问题。 </p>
<ul>
<li>首先，将数据存储到仅追加日志中会导致查询性能下降，因为相关记录分散在整个日志中。</li>
<li>另一个问题是由于尚未删除的过时记录而导致空间利用率低。 即使设计了各种数据重组过程，也没有统一标准的成本模型来分析写入/读取成本和空间利用率之间的折衷，这使得早期日志结构化存储难以优化。 </li>
<li>数据重组很容易成为性能瓶颈。</li>
</ul>
<p> 1996年提出的LSM树通过设计一种集成到结构本身中的合并操作来解决上述问题，提供较高的写入吞吐、基于范围的高效查找 、友好的空间利用率。</p>
<ul>
<li>原始的LSM树设计包含一系列组件C0，C1，…，Ck，如图2所示。每个组件都被构造为B+树。 C0驻留在内存中并处理传入的写操作，而所有其余组件C1，Ck都驻留在磁盘上。 Ci满时，将触发滚动合并过程，以将一系列范围从Ci的叶子页面合并为Ci + 1</li>
<li>如今，这种设计被引用到多层合并策略中。但是，正如我们稍后将要看到的那样，由于其实现复杂性，现今基于LSM的存储系统并未使用最初提出的滚动合并过程。关于LSM树的原始论文进一步表明，在稳定的workload下，层级数量保持不变，当所有相邻组件之间的大小比率Ti = ｜Ci+1｜/｜Ci｜相同时，写性能能得到优化。该原则影响了LSM树的所有后续实现和改进。</li>
</ul>
<p><img src="https://hardcore.feishu.cn/space/api/box/stream/download/asynccode/?code=YjNhZmEyOTZkNjlkZjc0M2RiMjUxMWI0ZGZjNTBhMTVfVmMyMnBKUmFuRVdUMU5aNGE3WnAxZUMwQVlBUE5UZU9fVG9rZW46Ym94Y25qUUE5R1Q5c2c2NkZtNkYxa0VqVnJjXzE2NDQ0OTIyMTU6MTY0NDQ5NTgxNV9WNA" alt="img"></p>
<p>与LSM树并行，Jagadish等人。 提出了一种stepped-merge逐步合并策略的结构，可以实现更好的写入性能。 它将组件组织到各个级别中，并且当级别L充满T组件时，这些T组件将合并在一起成为级别L + 1的新组件。 该策略成为当今LSM树实施中使用的分层合并策略。</p>
<h4 id="1-2-今天的LSM-Tree"><a href="#1-2-今天的LSM-Tree" class="headerlink" title="1.2 今天的LSM Tree"></a>1.2 今天的LSM Tree</h4><p>今天的LSM-tree架构仍然以out-of-place updates 为主 通过顺序I/O来提升写性能。所有的写入，都会追加到内存中的组件，不论是更新还是插入还是删除，都会以一个新的记录添加到内存中。</p>
<p>在内部，可以使用任何索引结构来实现LSM树组件。 当今的LSM树实现通常使用并发数据结构（如skip-list或B +树）来组织其内存组件，而它们使用B +树或排序字符串表（SSTables）来组织其磁盘组件。 SSTable包含一个数据块列表和一个索引块； 数据块存储按键排序的键值对，而索引块存储所有数据块的键范围。</p>
<p><img src="https://hardcore.feishu.cn/space/api/box/stream/download/asynccode/?code=NDlhZTc1MzgwMzFlNTBjNTY5MDdiNzVmYzg4Mjc2OTJfWXB3YnU2bGZpYnhsamJZT2pmQkc4eWtaalhjMXJHWFZfVG9rZW46Ym94Y25MSzJBU1JwT0RpdGdwSmNVM1RLQ2pJXzE2NDQ0OTIzODU6MTY0NDQ5NTk4NV9WNA" alt="img"></p>
<p><img src="https://hardcore.feishu.cn/space/api/box/stream/download/asynccode/?code=MTAwNjliYWMzYzU1YWMyMjhkMDlkM2Y2ZTNmZDk3NTFfdGtZVkp1WEx1S0RCeEhRQWxob3JZR3VnMVg0dE5FdnZfVG9rZW46Ym94Y25iVE9wMW1tRTVSRENMSUw5RnBXcDFkXzE2NDQ0OTIzODU6MTY0NDQ5NTk4NV9WNA" alt="img"></p>
<p>在LSM树上的查询必须搜索多个组件，即查找每个key的最新版本。 点查询查询可获取特定键的值，可以简单地一个接一个地搜索所有组件，从最新到最旧，并在找到第一个匹配项后立即停止。 范围查询可以同时搜索所有组件，将搜索结果输入优先级队列以此获取最新数据。</p>
<p>磁盘组件随着时间的推移而逐渐变多，由于必须查询更多组件，因此LSM树的查询性能趋于下降。为了解决这个问题，磁盘组件逐渐合并以减少总数。</p>
<p>在实践中通常使用两种类型的合并策略。如图3所示，两个策略都将磁盘组件组织为层，并由大小比T控制。每个组件在图中均标有其相关的key范围。</p>
<p>在层合并策略（图3a）中，每个级别仅维护一个组件，但是级别L的组件比级别L-1的组件大T倍。因此，级别L的组件将与级别L-1的传入组件多次合并，直到其被填满，然后将其合并为级别L + 1。</p>
<p>例如，在图中，级别0的组件与级别1的组件合并，这将导致级别1的组件更大。相反，分层合并策略（图3b）在每个级别可能维护T个组件。当级别L已满时，这些组件将合并在一起成为级别L + 1的新组件。在图中，级别0的两个组件将合并在一起形成级别1的新组件。值得注意的是如果级别L已经是配置的最大级别时，则结果组件将保持在级别L。实际上，对于稳定的workload（插入量等于删除量），级别总数保持不变。通常，由于LSM树中要搜索的组件较少，因此层合并策略针对查询性能进行了优化。分层合并策略由于降低了合并频率而对写入进行了更多的优化。</p>
<p><img src="https://hardcore.feishu.cn/space/api/box/stream/download/asynccode/?code=MTViNDM5MDM3Zjk3YjkxODRiOGFhZDI4YzRhNzNiMzVfd05KRXY3T01nS2tTdUR4eFRLUHJ1TmpoRzFnUzBFcDJfVG9rZW46Ym94Y25UOHRHUFRmNGx2WkdVV0lqeDE0QXdjXzE2NDQ0OTIzODU6MTY0NDQ5NTk4NV9WNA" alt="img"></p>
<h3 id="2-Bloom-Filter"><a href="#2-Bloom-Filter" class="headerlink" title="2.Bloom Filter"></a>2.Bloom Filter</h3><p>Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。</p>
<p>Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。</p>
<h4 id="2-1集合表示和元素查询"><a href="#2-1集合表示和元素查询" class="headerlink" title="2.1集合表示和元素查询"></a>2.1集合表示和元素查询</h4><p>下面我们具体来看Bloom Filter是如何用位数组表示集合的。初始状态时，Bloom Filter是一个包含m位的位数组，每一位都置为0。</p>
<p><img src="https://p-blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf1.jpg" alt="img"></p>
<p>为了表达S={x1, x2,…,xn}这样一个n个元素的集合，Bloom Filter使用k个相互独立的哈希函数（Hash Function），它们分别将集合中的每个元素映射到{1,…,m}的范围中。对任意一个元素x，第i个哈希函数映射的位置hi(x)就会被置为1（1≤i≤k）。注意，如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果。在下图中，k=3，且有两个哈希函数选中同一个位置（从左边数第五位）。   </p>
<p> <img src="https://p-blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf2.jpg" alt="img"></p>
<p>在判断y是否属于这个集合时，我们对y应用k次哈希函数，如果所有hi(y)的位置都是1（1≤i≤k），那么我们就认为y是集合中的元素，否则就认为y不是集合中的元素。下图中y1就不是集合中的元素。y2或者属于这个集合，或者刚好是一个false positive。</p>
<p><img src="https://p-blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf3.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码分析——5.不同的主键Key类型</title>
    <url>/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%945.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%B8%BB%E9%94%AEKey%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="五-不同的主键Key类型"><a href="#五-不同的主键Key类型" class="headerlink" title="五.不同的主键Key类型"></a>五.不同的主键Key类型</h2><p>本系列的前两篇介绍了LevelDB高性能写操作的核心：日志与内存数据库。</p>
<p>在阅读LevelDB的源码时，往往能看到这样的参数传递：<code>Slice key</code> ,<code>const char* key</code>,<code>Key key</code>等等</p>
<p>他们都有相同的参数名，但有时代表的key却不一定相同。</p>
<p>在skiplist.h中, 能看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Insert(const Key&amp; key); </span><br></pre></td></tr></table></figure>

<p>在memtable.h中，能看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Add(SequenceNumber seq,ValueType type, const Slice&amp; key, const Slice&amp; value); </span><br></pre></td></tr></table></figure>

<p>在block_builder.h中，能看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Add(const Slice&amp; key,const Slice&amp; value); </span><br></pre></td></tr></table></figure>

<p>在table_builder.h中，能看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Add(const Slice&amp; key,const Slice&amp; value); </span><br></pre></td></tr></table></figure>

<p>实际上，LevelDB中一共有五种key的概念，分别是UserKey、InternalKey、ParsedInternalKey、LookupKey、MemtableKey。</p>
<p>其中用户输入的key即为UserKey，在各个函数的传递过程中，经过各种各样的处理，很难弄清楚现在拿到的key是什么。通过梳理sstable的插入和查询过程中，key的变化过程，分析清楚各种key的作用。</p>
<p><img src="https://l1nfp.github.io/assets/img/posts/LevelDB5keys.png" alt="LevelDB5keys.png"></p>
<h3 id="UserKey"><a href="#UserKey" class="headerlink" title="UserKey"></a>UserKey</h3><p>从最简单的入手，我们先弄清楚UserKey</p>
<p>前面已经提到过用户输入的key即为UserKey，例如，用户输入k/v对，key1:value1 ,则key1即为UserKey ，在leveldb中，是以Slice类型传入</p>
<p>Slice user_key;</p>
<h3 id="InternalKey"><a href="#InternalKey" class="headerlink" title="InternalKey"></a>InternalKey</h3><p>InternalKey是将user_key按一定规则编码后得到的字符串</p>
<ul>
<li>Seq用于表示记录插入的顺序</li>
<li>Type用于表示记录的类型，目前取值只有两种kTypeDeletion表示记录被删除，kTypeValue表示记录有效</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ValueType</span> &#123;</span> kTypeDeletion = <span class="number">0x0</span>, kTypeValue = <span class="number">0x1</span> &#125;; </span><br></pre></td></tr></table></figure>

<p>Seq占7B，Type占1B通过下面的函数打包</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">PackSequenceAndType</span><span class="params">(<span class="keyword">uint64_t</span> seq, ValueType t)</span> </span>&#123;    </span><br><span class="line">	<span class="built_in">assert</span>(seq &lt;= kMaxSequenceNumber);    </span><br><span class="line">	<span class="built_in">assert</span>(t &lt;= kValueTypeForSeek);    </span><br><span class="line">	<span class="keyword">return</span> (seq &lt;&lt; <span class="number">8</span>) | t; </span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<p>打包后拼接到user_key_bytes后面即构成了InternalKey</p>
<h3 id="ParsedInternalKey"><a href="#ParsedInternalKey" class="headerlink" title="ParsedInternalKey"></a>ParsedInternalKey</h3><p>ParsedInternalKey将字符串InternalKey解析为一个结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ParsedInternalKey</span> &#123;</span>    </span><br><span class="line">	Slice user_key;    </span><br><span class="line">	SequenceNumber sequence&#123;&#125;;    </span><br><span class="line">	ValueType type;     </span><br><span class="line">	<span class="built_in">ParsedInternalKey</span>() = <span class="keyword">default</span>;  <span class="comment">// Intentionally left uninitialized (for speed)    </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ParsedInternalKey</span>(<span class="keyword">const</span> Slice&amp; u, <span class="keyword">const</span> SequenceNumber&amp; seq, ValueType t)  : <span class="built_in">user_key</span>(u), <span class="built_in">sequence</span>(seq), <span class="built_in">type</span>(t) &#123;&#125; &#125;; </span><br></pre></td></tr></table></figure>

<p>补上了ParsedInternalKey的概念后，就能看懂InternalKey的所有代码了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AppendInternalKey</span><span class="params">(std::string *result, <span class="keyword">const</span> ParsedInternalKey &amp;key)</span> </span>&#123;    </span><br><span class="line">	result-&gt;<span class="built_in">append</span>(key.user_key.<span class="built_in">data</span>(), key.user_key.<span class="built_in">size</span>());    </span><br><span class="line">	<span class="built_in">PutFixed64</span>(result, <span class="built_in">PackSequenceAndType</span>(key.sequence, key.type)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InternalKey</span> &#123;</span> </span><br><span class="line">	<span class="keyword">private</span>:    </span><br><span class="line">		std::string rep_; </span><br><span class="line">	<span class="keyword">public</span>:    </span><br><span class="line">		<span class="built_in">InternalKey</span>() = <span class="keyword">default</span>;  <span class="comment">// Leave rep_ as empty to indicate it is invalid    </span></span><br><span class="line">		<span class="built_in">InternalKey</span>(<span class="keyword">const</span> Slice&amp; user_key, SequenceNumber s, ValueType t) &#123;        </span><br><span class="line">			<span class="built_in">AppendInternalKey</span>(&amp;rep_, <span class="built_in">ParsedInternalKey</span>(user_key, s, t));    </span><br><span class="line">		&#125;     </span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">DecodeFrom</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123;        </span><br><span class="line">			rep_.<span class="built_in">assign</span>(s.<span class="built_in">data</span>(), s.<span class="built_in">size</span>());        </span><br><span class="line">			<span class="keyword">return</span> !rep_.<span class="built_in">empty</span>();    </span><br><span class="line">		&#125;     </span><br><span class="line">		<span class="function">Slice <span class="title">Encode</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;        </span><br><span class="line">			<span class="built_in">assert</span>(!rep_.<span class="built_in">empty</span>());        </span><br><span class="line">			<span class="keyword">return</span> rep_;    </span><br><span class="line">		&#125;     </span><br><span class="line">		<span class="function">Slice <span class="title">user_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">ExtractUserKey</span>(rep_); </span><br><span class="line">		&#125;     </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">SetFrom</span><span class="params">(<span class="keyword">const</span> ParsedInternalKey&amp; p)</span> </span>&#123;        </span><br><span class="line">			rep_.<span class="built_in">clear</span>();        </span><br><span class="line">			<span class="built_in">AppendInternalKey</span>(&amp;rep_, p);    </span><br><span class="line">		&#125;    </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123; rep_.<span class="built_in">clear</span>(); &#125; &#125;; </span><br></pre></td></tr></table></figure>

<h3 id="LookupKey-amp-amp-MemtableKey"><a href="#LookupKey-amp-amp-MemtableKey" class="headerlink" title="LookupKey&amp;&amp;MemtableKey"></a>LookupKey&amp;&amp;MemtableKey</h3><p>下面是源码中给出的注释</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemTable::Add</span><span class="params">(SequenceNumber s, ValueType type, <span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">// Format of an entry is concatenation of:  </span></span><br><span class="line">	<span class="comment">//  key_size     : varint32 of internal_key.size()  </span></span><br><span class="line">	<span class="comment">//  key bytes    : char[internal_key.size()]  </span></span><br><span class="line">	<span class="comment">//  value_size   : varint32 of value.size()  </span></span><br><span class="line">	<span class="comment">//  value bytes  : char[value.size()]  ...... &#125; </span></span><br></pre></td></tr></table></figure>

<p>我们可以看到：在InternalKey的头部拼接上InternalKey的长度，即构成MemtableKey。</p>
<p>LookupKey和MemtableKey格式一致，用于查找。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码分析——10.Compaction操作</title>
    <url>/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%9410.Compaction%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="十-Compaction操作"><a href="#十-Compaction操作" class="headerlink" title="十.Compaction操作"></a>十.Compaction操作</h2><p>LevelDB 源码分析系列也步入尾声，本篇将分析 LevelDB 中至关重要的 Compaction 过程，依然从代码的角度出发。建议大家 了解 Compaction 的作用和过程。</p>
<h3 id="1-触发-Compaction"><a href="#1-触发-Compaction" class="headerlink" title="1. 触发 Compaction"></a>1. 触发 Compaction</h3><p>本系列第三篇中描述了内存数据库转为 Sorted Table 的过程，其中会执行 <code>DBImpl::BackgroundCompaction</code> 这一后台任务：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">CompactMemTable</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">bool</span> is_manual = (manual_compaction_ != <span class="literal">nullptr</span>);</span><br><span class="line">  InternalKey manual_end;</span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = versions_-&gt;<span class="built_in">PickCompaction</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在假设 <code>imm_</code> 为空，并且不考虑手动 Compaction，那么这里会执行 <code>versions_-&gt;PickCompaction</code> 去选择一个 Compaction，其实现位于 <a href="https://github.com/google/leveldb/blob/master/db/version_set.cc"><code>db/version_set.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Compaction* <span class="title">VersionSet::PickCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line">  <span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会有两种需要 Compaction 的情况，一种是某一 Level 的分数超过了 1，一种是某一个文件的无效查询次数超过阈值。分数的计算位于版本更新之后的 <code>VersionSet::Finalize</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(config::kL0_CompactionTrigger);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = <span class="built_in">TotalFileSize</span>(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / <span class="built_in">MaxBytesForLevel</span>(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 0 层文件，当文件数量超过阈值（默认 4）时触发 Compaction；对于其他层的文件，当文件的总大小超过阈值时触发 Compaction。而一个文件的的查询次数阈值定义于 <code>VersionSet::Builder::Apply</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// We arrange to automatically compact this file after</span></span><br><span class="line"><span class="comment">// a certain number of seeks.  Let&#x27;s assume:</span></span><br><span class="line"><span class="comment">//   (1) One seek costs 10ms</span></span><br><span class="line"><span class="comment">//   (2) Writing or reading 1MB costs 10ms (100MB/s)</span></span><br><span class="line"><span class="comment">//   (3) A compaction of 1MB does 25MB of IO:</span></span><br><span class="line"><span class="comment">//         1MB read from this level</span></span><br><span class="line"><span class="comment">//         10-12MB read from next level (boundaries may be misaligned)</span></span><br><span class="line"><span class="comment">//         10-12MB written to next level</span></span><br><span class="line"><span class="comment">// This implies that 25 seeks cost the same as the compaction</span></span><br><span class="line"><span class="comment">// of 1MB of data.  I.e., one seek costs approximately the</span></span><br><span class="line"><span class="comment">// same as the compaction of 40KB of data.  We are a little</span></span><br><span class="line"><span class="comment">// conservative and allow approximately one seek for every 16KB</span></span><br><span class="line"><span class="comment">// of data before triggering a compaction.</span></span><br><span class="line">f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>));</span><br><span class="line"><span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>英文注释写得十分详细。首先假设：</p>
<ol>
<li>一次查询耗时 10ms；</li>
<li>读/写 1MB 耗时 10ms （假设速度 100MB/s）；</li>
<li>1MB 的 Compaction 需要做 25 MB 的 IO<ol>
<li>本层读 1MB；</li>
<li>下一层读 10-12 MB</li>
<li>Compaction 后写 10-12 MB</li>
</ol>
</li>
</ol>
<p>整体来看，1MB 的数据做 25 次查询和 Compaction 的时间差不多，1 次查询就相当于做 40KB 数据的 Compaction。LevelDB 将其设为更保守的 16KB，进而一个文件的查询次数阈值设定为 <code>FileSize / 16KB</code>。当一次查询中读取了多个文件，则将第一个文件的查询次数 +1，直到其超过阈值、触发 Compaction。继续看 <code>VersionSet::PickCompaction</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Compaction* <span class="title">VersionSet::PickCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size_compaction) &#123;</span><br><span class="line">    level = current_-&gt;compaction_level_;</span><br><span class="line">    <span class="built_in">assert</span>(level &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(level + <span class="number">1</span> &lt; config::kNumLevels);</span><br><span class="line">    c = <span class="keyword">new</span> <span class="built_in">Compaction</span>(options_, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">      <span class="keyword">if</span> (compact_pointer_[level].<span class="built_in">empty</span>() ||</span><br><span class="line">          icmp_.<span class="built_in">Compare</span>(f-&gt;largest.<span class="built_in">Encode</span>(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">push_back</span>(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">push_back</span>(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction) &#123;</span><br><span class="line">    level = current_-&gt;file_to_compact_level_;</span><br><span class="line">    c = <span class="keyword">new</span> <span class="built_in">Compaction</span>(options_, level);</span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">push_back</span>(current_-&gt;file_to_compact_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c-&gt;input_version_ = current_;</span><br><span class="line">  c-&gt;input_version_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line">  <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">    <span class="built_in">GetRange</span>(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">    <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">    <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">    <span class="comment">// which will include the picked file.</span></span><br><span class="line">    current_-&gt;<span class="built_in">GetOverlappingInputs</span>(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">assert</span>(!c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">empty</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetupOtherInputs</span>(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于数据大小触发的 Compaction，会选取 <code>compact_pointer_</code> 后的第一个文件作为 Compaction 对象，即本层上一次 Compaction 区间之后的文件；而查询次数触发的 Compaction 其本身对应一个文件。对于 0 层文件，因为之间存在 Overlap，需要将存在重叠的文件都加入 Compaction 集合里。至此本层的文件选择完毕。</p>
<h3 id="2-扩大-Compaction-文件集合"><a href="#2-扩大-Compaction-文件集合" class="headerlink" title="2. 扩大 Compaction 文件集合"></a>2. 扩大 Compaction 文件集合</h3><p><code>VersionSet::PickCompaction</code> 随后执行 <code>SetupOtherInputs</code> 以扩大 Compaction 文件集合：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Finds the largest key in a vector of files. Returns true if files it not</span></span><br><span class="line"><span class="comment">// empty.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindLargestKey</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; files,</span></span></span><br><span class="line"><span class="params"><span class="function">                    InternalKey* largest_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (files.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *largest_key = files[<span class="number">0</span>]-&gt;largest;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; files.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    FileMetaData* f = files[i];</span><br><span class="line">    <span class="keyword">if</span> (icmp.<span class="built_in">Compare</span>(f-&gt;largest, *largest_key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      *largest_key = f-&gt;largest;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finds minimum file b2=(l2, u2) in level file for which l2 &gt; u1 and</span></span><br><span class="line"><span class="comment">// user_key(l2) = user_key(u1)</span></span><br><span class="line"><span class="function">FileMetaData* <span class="title">FindSmallestBoundaryFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; level_files,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> InternalKey&amp; largest_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* user_cmp = icmp.<span class="built_in">user_comparator</span>();</span><br><span class="line">  FileMetaData* smallest_boundary_file = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; level_files.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    FileMetaData* f = level_files[i];</span><br><span class="line">    <span class="keyword">if</span> (icmp.<span class="built_in">Compare</span>(f-&gt;smallest, largest_key) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        user_cmp-&gt;<span class="built_in">Compare</span>(f-&gt;smallest.<span class="built_in">user_key</span>(), largest_key.<span class="built_in">user_key</span>()) ==</span><br><span class="line">            <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (smallest_boundary_file == <span class="literal">nullptr</span> ||</span><br><span class="line">          icmp.<span class="built_in">Compare</span>(f-&gt;smallest, smallest_boundary_file-&gt;smallest) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        smallest_boundary_file = f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> smallest_boundary_file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extracts the largest file b1 from |compaction_files| and then searches for a</span></span><br><span class="line"><span class="comment">// b2 in |level_files| for which user_key(u1) = user_key(l2). If it finds such a</span></span><br><span class="line"><span class="comment">// file b2 (known as a boundary file) it adds it to |compaction_files| and then</span></span><br><span class="line"><span class="comment">// searches again using this new upper bound.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there are two blocks, b1=(l1, u1) and b2=(l2, u2) and</span></span><br><span class="line"><span class="comment">// user_key(u1) = user_key(l2), and if we compact b1 but not b2 then a</span></span><br><span class="line"><span class="comment">// subsequent get operation will yield an incorrect result because it will</span></span><br><span class="line"><span class="comment">// return the record from b2 in level i rather than from b1 because it searches</span></span><br><span class="line"><span class="comment">// level by level for records matching the supplied user key.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// parameters:</span></span><br><span class="line"><span class="comment">//   in     level_files:      List of files to search for boundary files.</span></span><br><span class="line"><span class="comment">//   in/out compaction_files: List of files to extend by adding boundary files.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBoundaryInputs</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; level_files,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::vector&lt;FileMetaData*&gt;* compaction_files)</span> </span>&#123;</span><br><span class="line">  InternalKey largest_key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Quick return if compaction_files is empty.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">FindLargestKey</span>(icmp, *compaction_files, &amp;largest_key)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> continue_searching = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (continue_searching) &#123;</span><br><span class="line">    FileMetaData* smallest_boundary_file =</span><br><span class="line">        <span class="built_in">FindSmallestBoundaryFile</span>(icmp, level_files, largest_key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a boundary file was found advance largest_key, otherwise we&#x27;re done.</span></span><br><span class="line">    <span class="keyword">if</span> (smallest_boundary_file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      compaction_files-&gt;<span class="built_in">push_back</span>(smallest_boundary_file);</span><br><span class="line">      largest_key = smallest_boundary_file-&gt;largest;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      continue_searching = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::SetupOtherInputs</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;<span class="built_in">level</span>();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AddBoundaryInputs</span>(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先执行的是 <code>AddBoundaryInputs</code>。其英文注释中解释地非常详细：当 Compaction 的范围为 [l1, u1][<em>l</em>1,<em>u</em>1] 时，该范围的数据将会被移动到 Level+1。如果当前 Level 存在文件 [l2, u2][<em>l</em>2,<em>u</em>2]，并且 <code>user_key(u1) = user_key(l2)</code>，那么下一次查询 <code>user_key(u1)</code> 时会在 Level 层提前返回旧的数据！故需要将受影响的文件全部加到 Compaction 文件范围中。继续看 <code>VersionSet::SetupOtherInputs</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::SetupOtherInputs</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">GetRange</span>(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"></span><br><span class="line">  current_-&gt;<span class="built_in">GetOverlappingInputs</span>(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">  InternalKey all_start, all_limit;</span><br><span class="line">  <span class="built_in">GetRange2</span>(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if we can grow the number of inputs in &quot;level&quot; without</span></span><br><span class="line">  <span class="comment">// changing the number of &quot;level+1&quot; files we pick up.</span></span><br><span class="line">  <span class="keyword">if</span> (!c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::vector&lt;FileMetaData*&gt; expanded0;</span><br><span class="line">    current_-&gt;<span class="built_in">GetOverlappingInputs</span>(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">    <span class="built_in">AddBoundaryInputs</span>(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = <span class="built_in">TotalFileSize</span>(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = <span class="built_in">TotalFileSize</span>(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = <span class="built_in">TotalFileSize</span>(expanded0);</span><br><span class="line">    <span class="keyword">if</span> (expanded0.<span class="built_in">size</span>() &gt; c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">        inputs1_size + expanded0_size &lt;</span><br><span class="line">            <span class="built_in">ExpandedCompactionByteSizeLimit</span>(options_)) &#123;</span><br><span class="line">      InternalKey new_start, new_limit;</span><br><span class="line">      <span class="built_in">GetRange</span>(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">      std::vector&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">      current_-&gt;<span class="built_in">GetOverlappingInputs</span>(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                     &amp;expanded1);</span><br><span class="line">      <span class="keyword">if</span> (expanded1.<span class="built_in">size</span>() == c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">Log</span>(options_-&gt;info_log,</span><br><span class="line">            <span class="string">&quot;Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n&quot;</span>,</span><br><span class="line">            level, <span class="built_in"><span class="keyword">int</span></span>(c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>()), <span class="built_in"><span class="keyword">int</span></span>(c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()),</span><br><span class="line">            <span class="built_in"><span class="keyword">long</span></span>(inputs0_size), <span class="built_in"><span class="keyword">long</span></span>(inputs1_size), <span class="built_in"><span class="keyword">int</span></span>(expanded0.<span class="built_in">size</span>()),</span><br><span class="line">            <span class="built_in"><span class="keyword">int</span></span>(expanded1.<span class="built_in">size</span>()), <span class="built_in"><span class="keyword">long</span></span>(expanded0_size), <span class="built_in"><span class="keyword">long</span></span>(inputs1_size));</span><br><span class="line">        smallest = new_start;</span><br><span class="line">        largest = new_limit;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">        c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">        <span class="built_in">GetRange2</span>(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the set of grandparent files that overlap this compaction</span></span><br><span class="line">  <span class="comment">// (parent == level+1; grandparent == level+2)</span></span><br><span class="line">  <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">    current_-&gt;<span class="built_in">GetOverlappingInputs</span>(level + <span class="number">2</span>, &amp;all_start, &amp;all_limit,</span><br><span class="line">                                   &amp;c-&gt;grandparents_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line">  <span class="comment">// We update this immediately instead of waiting for the VersionEdit</span></span><br><span class="line">  <span class="comment">// to be applied so that if the compaction fails, we will try a different</span></span><br><span class="line">  <span class="comment">// key range next time.</span></span><br><span class="line">  compact_pointer_[level] = largest.<span class="built_in">Encode</span>().<span class="built_in">ToString</span>();</span><br><span class="line">  c-&gt;edit_.<span class="built_in">SetCompactPointer</span>(level, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在 Level+1 层将所有存在重叠的文件加入 Compaction 文件集合里，更新 Compaction 的区间 <code>[all_start, all_limit]</code>。再回过头来使用新区间获得 Level 层重叠的文件 <code>expanded0</code>，如果新的数据大小在阈值以内且不会改变 Level+1 层选择的文件，那么则将 Level 层的文件集合更新为 <code>expanded0</code>。最后将当前 Level 的 <code>compact_pointer_</code> 设为当前 Compaction 的最大键。至此扩大 Compaction 文件集合结束，<code>VersionSet::PickCompaction</code> 也返回了 Compaction 对象。</p>
<h3 id="3-执行-Compaction"><a href="#3-执行-Compaction" class="headerlink" title="3. 执行 Compaction"></a>3. 执行 Compaction</h3><p>回到 <code>DBImpl::BackgroundCompaction</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DBImpl</span>:</span>:CompactionState &#123;</span><br><span class="line">  <span class="comment">// Files produced by compaction</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Output</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> number;</span><br><span class="line">    <span class="keyword">uint64_t</span> file_size;</span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">Output* <span class="title">current_output</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;outputs[outputs.<span class="built_in">size</span>() - <span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">CompactionState</span><span class="params">(Compaction* c)</span></span></span><br><span class="line"><span class="function">      : compaction(c),</span></span><br><span class="line"><span class="function">        smallest_snapshot(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        outfile(nullptr),</span></span><br><span class="line"><span class="function">        builder(nullptr),</span></span><br><span class="line"><span class="function">        total_bytes(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  Compaction* <span class="keyword">const</span> compaction;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sequence numbers &lt; smallest_snapshot are not significant since we</span></span><br><span class="line">  <span class="comment">// will never have to service a snapshot below smallest_snapshot.</span></span><br><span class="line">  <span class="comment">// Therefore if we have seen a sequence number S &lt;= smallest_snapshot,</span></span><br><span class="line">  <span class="comment">// we can drop all entries for the same key with sequence numbers &lt; S.</span></span><br><span class="line">  SequenceNumber smallest_snapshot;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Output&gt; outputs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// State kept for output being generated</span></span><br><span class="line">  WritableFile* outfile;</span><br><span class="line">  TableBuilder* builder;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> total_bytes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  Status status;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Nothing to do</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;<span class="built_in">IsTrivialMove</span>()) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    CompactionState* compact = <span class="keyword">new</span> <span class="built_in">CompactionState</span>(c);</span><br><span class="line">    status = <span class="built_in">DoCompactionWork</span>(compact);</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">RecordBackgroundError</span>(status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CleanupCompaction</span>(compact);</span><br><span class="line">    c-&gt;<span class="built_in">ReleaseInputs</span>();</span><br><span class="line">    <span class="built_in">DeleteObsoleteFiles</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Ignore compaction errors found during shutting down</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Compaction error: %s&quot;</span>, status.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不考虑手动模式和 TrivialMove，接下来会根据 <code>Compaction</code> 对象构建 <code>CompactionState</code>，并执行 <code>DBImpl::DoCompactionWork</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;<span class="built_in">NowMicros</span>();</span><br><span class="line">  <span class="keyword">int64_t</span> imm_micros = <span class="number">0</span>;  <span class="comment">// Micros spent doing imm_ compactions</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Compacting %d@%d + %d@%d files&quot;</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;<span class="built_in">num_input_files</span>(<span class="number">0</span>), compact-&gt;compaction-&gt;<span class="built_in">level</span>(),</span><br><span class="line">      compact-&gt;compaction-&gt;<span class="built_in">num_input_files</span>(<span class="number">1</span>),</span><br><span class="line">      compact-&gt;compaction-&gt;<span class="built_in">level</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(versions_-&gt;<span class="built_in">NumLevelFiles</span>(compact-&gt;compaction-&gt;<span class="built_in">level</span>()) &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">assert</span>(compact-&gt;builder == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(compact-&gt;outfile == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (snapshots_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = snapshots_.<span class="built_in">oldest</span>()-&gt;<span class="built_in">sequence_number</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Iterator* input = versions_-&gt;<span class="built_in">MakeInputIterator</span>(compact-&gt;compaction);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>compact-&gt;smallest_snapshot</code> 是为了让当前的 Snapshot 的数据在 Compaction 过程中不丢失。<code>versions_-&gt;MakeInputIterator</code> 返回 Compaction 文件集合的合并迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Iterator* <span class="title">VersionSet::MakeInputIterator</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  ReadOptions options;</span><br><span class="line">  options.verify_checksums = options_-&gt;paranoid_checks;</span><br><span class="line">  options.fill_cache = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level-0 files have to be merged together.  For other levels,</span></span><br><span class="line">  <span class="comment">// we will make a concatenating iterator per level.</span></span><br><span class="line">  <span class="comment">// TODO(opt): use concatenating iterator for level-0 if there is no overlap</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> space = (c-&gt;<span class="built_in">level</span>() == <span class="number">0</span> ? c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() + <span class="number">1</span> : <span class="number">2</span>);</span><br><span class="line">  Iterator** list = <span class="keyword">new</span> Iterator*[space];</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!c-&gt;inputs_[which].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c-&gt;<span class="built_in">level</span>() + which == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; files = c-&gt;inputs_[which];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          list[num++] = table_cache_-&gt;<span class="built_in">NewIterator</span>(options, files[i]-&gt;number,</span><br><span class="line">                                                  files[i]-&gt;file_size);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Create concatenating iterator for the files from this level</span></span><br><span class="line">        list[num++] = <span class="built_in">NewTwoLevelIterator</span>(</span><br><span class="line">            <span class="keyword">new</span> Version::<span class="built_in">LevelFileNumIterator</span>(icmp_, &amp;c-&gt;inputs_[which]),</span><br><span class="line">            &amp;GetFileIterator, table_cache_, options);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(num &lt;= space);</span><br><span class="line">  Iterator* result = <span class="built_in">NewMergingIterator</span>(&amp;icmp_, list, num);</span><br><span class="line">  <span class="keyword">delete</span>[] list;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看 <code>DBImpl::DoCompactionWork</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Release mutex while we&#x27;re actually doing the compaction work</span></span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  input-&gt;<span class="built_in">SeekToFirst</span>();</span><br><span class="line">  Status status;</span><br><span class="line">  ParsedInternalKey ikey;</span><br><span class="line">  std::string current_user_key;</span><br><span class="line">  <span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">  SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">  <span class="keyword">while</span> (input-&gt;<span class="built_in">Valid</span>() &amp;&amp; !shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Prioritize immutable compaction work</span></span><br><span class="line">    <span class="keyword">if</span> (has_imm_.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;<span class="built_in">NowMicros</span>();</span><br><span class="line">      mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">CompactMemTable</span>();</span><br><span class="line">        <span class="comment">// Wake up MakeRoomForWrite() if necessary.</span></span><br><span class="line">        background_work_finished_signal_.<span class="built_in">SignalAll</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">      imm_micros += (env_-&gt;<span class="built_in">NowMicros</span>() - imm_start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Slice key = input-&gt;<span class="built_in">key</span>();</span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;compaction-&gt;<span class="built_in">ShouldStopBefore</span>(key) &amp;&amp;</span><br><span class="line">        compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      status = <span class="built_in">FinishCompactionOutputFile</span>(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle key/value, add to state, etc.</span></span><br><span class="line">    <span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ParseInternalKey</span>(key, &amp;ikey)) &#123;</span><br><span class="line">      <span class="comment">// Do not hide error keys</span></span><br><span class="line">      current_user_key.<span class="built_in">clear</span>();</span><br><span class="line">      has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">      last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!has_current_user_key ||</span><br><span class="line">          <span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Compare</span>(ikey.user_key, <span class="built_in">Slice</span>(current_user_key)) !=</span><br><span class="line">              <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// First occurrence of this user key</span></span><br><span class="line">        current_user_key.<span class="built_in">assign</span>(ikey.user_key.<span class="built_in">data</span>(), ikey.user_key.<span class="built_in">size</span>());</span><br><span class="line">        has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">        last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;</span><br><span class="line">        <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">        drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line">                 ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">                 compact-&gt;compaction-&gt;<span class="built_in">IsBaseLevelForKey</span>(ikey.user_key)) &#123;</span><br><span class="line">        <span class="comment">// For this user key:</span></span><br><span class="line">        <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">        <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">        <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">        <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">        <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">        <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">        drop = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last_sequence_for_key = ikey.sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">      <span class="comment">// Open output file if necessary</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        status = <span class="built_in">OpenCompactionOutputFile</span>(compact);</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;<span class="built_in">NumEntries</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        compact-&gt;<span class="built_in">current_output</span>()-&gt;smallest.<span class="built_in">DecodeFrom</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">      compact-&gt;<span class="built_in">current_output</span>()-&gt;largest.<span class="built_in">DecodeFrom</span>(key);</span><br><span class="line">      compact-&gt;builder-&gt;<span class="built_in">Add</span>(key, input-&gt;<span class="built_in">value</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Close output file if it is big enough</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;<span class="built_in">FileSize</span>() &gt;=</span><br><span class="line">          compact-&gt;compaction-&gt;<span class="built_in">MaxOutputFileSize</span>()) &#123;</span><br><span class="line">        status = <span class="built_in">FinishCompactionOutputFile</span>(compact, input);</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input-&gt;<span class="built_in">Next</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>一个巨大的循环。首先判断是否已经 <code>shutting_down_</code>，如果已经关闭了，则终止当前的 Compaction 过程；随后判断当前是否有 <code>imm_</code>，如果存在的话则也先执行 <code>CompactMemTable</code>；再来判断当前输出的文件是否可以结束了，如果是的话就执行 <code>FinishCompactionOutputFile</code> 完成当前文件。</p>
<p>接下来是是否丢弃键值对的判定。如果某个 <code>user_key</code> 的非最新版本小于快照版本，则可以直接丢弃，因为读最新的版本就足够了；如果某个删除操作的版本小于快照版本，并且在更高层没有相同的 <code>user_key</code>，那么这个删除操作及其之前更早的插入操作可以同时丢弃了。</p>
<p>对于没有丢弃的键值对，将其写入当前的 Table Builder。当输出的大小超过阈值，同样执行 <code>FinishCompactionOutputFile</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::OpenCompactionOutputFile</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(compact != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(compact-&gt;builder == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> file_number;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">    file_number = versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">    pending_outputs_.<span class="built_in">insert</span>(file_number);</span><br><span class="line">    CompactionState::Output out;</span><br><span class="line">    out.number = file_number;</span><br><span class="line">    out.smallest.<span class="built_in">Clear</span>();</span><br><span class="line">    out.largest.<span class="built_in">Clear</span>();</span><br><span class="line">    compact-&gt;outputs.<span class="built_in">push_back</span>(out);</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the output file</span></span><br><span class="line">  std::string fname = <span class="built_in">TableFileName</span>(dbname_, file_number);</span><br><span class="line">  Status s = env_-&gt;<span class="built_in">NewWritableFile</span>(fname, &amp;compact-&gt;outfile);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    compact-&gt;builder = <span class="keyword">new</span> <span class="built_in">TableBuilder</span>(options_, compact-&gt;outfile);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::FinishCompactionOutputFile</span><span class="params">(CompactionState* compact,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Iterator* input)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(compact != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(compact-&gt;outfile != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(compact-&gt;builder != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> output_number = compact-&gt;<span class="built_in">current_output</span>()-&gt;number;</span><br><span class="line">  <span class="built_in">assert</span>(output_number != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for iterator errors</span></span><br><span class="line">  Status s = input-&gt;<span class="built_in">status</span>();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> current_entries = compact-&gt;builder-&gt;<span class="built_in">NumEntries</span>();</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = compact-&gt;builder-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compact-&gt;builder-&gt;<span class="built_in">Abandon</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> current_bytes = compact-&gt;builder-&gt;<span class="built_in">FileSize</span>();</span><br><span class="line">  compact-&gt;<span class="built_in">current_output</span>()-&gt;file_size = current_bytes;</span><br><span class="line">  compact-&gt;total_bytes += current_bytes;</span><br><span class="line">  <span class="keyword">delete</span> compact-&gt;builder;</span><br><span class="line">  compact-&gt;builder = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finish and check for file errors</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = compact-&gt;outfile-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = compact-&gt;outfile-&gt;<span class="built_in">Close</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> compact-&gt;outfile;</span><br><span class="line">  compact-&gt;outfile = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; current_entries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Verify that the table is usable</span></span><br><span class="line">    Iterator* iter =</span><br><span class="line">        table_cache_-&gt;<span class="built_in">NewIterator</span>(<span class="built_in">ReadOptions</span>(), output_number, current_bytes);</span><br><span class="line">    s = iter-&gt;<span class="built_in">status</span>();</span><br><span class="line">    <span class="keyword">delete</span> iter;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Generated table #%llu@%d: %lld keys, %lld bytes&quot;</span>,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)output_number, compact-&gt;compaction-&gt;<span class="built_in">level</span>(),</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)current_entries,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)current_bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续来看 <code>DBImpl::DoCompactionWork</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::InstallCompactionResults</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Compacted %d@%d + %d@%d files =&gt; %lld bytes&quot;</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;<span class="built_in">num_input_files</span>(<span class="number">0</span>), compact-&gt;compaction-&gt;<span class="built_in">level</span>(),</span><br><span class="line">      compact-&gt;compaction-&gt;<span class="built_in">num_input_files</span>(<span class="number">1</span>), compact-&gt;compaction-&gt;<span class="built_in">level</span>() + <span class="number">1</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(compact-&gt;total_bytes));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add compaction outputs</span></span><br><span class="line">  compact-&gt;compaction-&gt;<span class="built_in">AddInputDeletions</span>(compact-&gt;compaction-&gt;<span class="built_in">edit</span>());</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = compact-&gt;compaction-&gt;<span class="built_in">level</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> CompactionState::Output&amp; out = compact-&gt;outputs[i];</span><br><span class="line">    compact-&gt;compaction-&gt;<span class="built_in">edit</span>()-&gt;<span class="built_in">AddFile</span>(level + <span class="number">1</span>, out.number, out.file_size,</span><br><span class="line">                                         out.smallest, out.largest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> versions_-&gt;<span class="built_in">LogAndApply</span>(compact-&gt;compaction-&gt;<span class="built_in">edit</span>(), &amp;mutex_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    status = Status::<span class="built_in">IOError</span>(<span class="string">&quot;Deleting DB during compaction&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    status = <span class="built_in">FinishCompactionOutputFile</span>(compact, input);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    status = input-&gt;<span class="built_in">status</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> input;</span><br><span class="line">  input = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.micros = env_-&gt;<span class="built_in">NowMicros</span>() - start_micros - imm_micros;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compact-&gt;compaction-&gt;<span class="built_in">num_input_files</span>(which); i++) &#123;</span><br><span class="line">      stats.bytes_read += compact-&gt;compaction-&gt;<span class="built_in">input</span>(which, i)-&gt;file_size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    stats.bytes_written += compact-&gt;outputs[i].file_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  stats_[compact-&gt;compaction-&gt;<span class="built_in">level</span>() + <span class="number">1</span>].<span class="built_in">Add</span>(stats);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    status = <span class="built_in">InstallCompactionResults</span>(compact);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">RecordBackgroundError</span>(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;compacted to: %s&quot;</span>, versions_-&gt;<span class="built_in">LevelSummary</span>(&amp;tmp));</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>InstallCompactionResults</code> 时将 Compaction 的文件集合加入到 <code>VersionEdit</code> 的删除列表中，并将新生成的文件加入到新文件列表里，随后执行 <code>versions_-&gt;LogAndApply</code> 更新版本。最后再执行一些清理操作，Compaction 过程就结束了。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码分析——2.基本的数据结构续</title>
    <url>/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AD%20(copy)/</url>
    <content><![CDATA[<h2 id="二-基本的数据结构续"><a href="#二-基本的数据结构续" class="headerlink" title="二.基本的数据结构续"></a>二.基本的数据结构续</h2><p>本系列的<a href="https://gasolly.github.io/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">上一篇</a>介绍了 <code>LevelDB</code> 中的 <code>Slice</code>、<code>Hash</code> 和 <code>LRUCache</code> 的实现，这一篇将继续分析布隆过滤器、内存池和跳表。</p>
<span id="more"></span>

<h3 id="4-布隆过滤器-BloomFilter"><a href="#4-布隆过滤器-BloomFilter" class="headerlink" title="4. 布隆过滤器 BloomFilter"></a>4. 布隆过滤器 BloomFilter</h3><p>在介绍布隆过滤器之前，先介绍下 <code>LevelDB</code> 中的过滤器策略 <code>FilterPolicy</code>。考虑一个场景：在 <code>LevelDB</code> 中查询某个指定 <code>key = query</code> 对应的 <code>value</code>，如果我们事先知道了所有的 <code>key</code> 里都找不到这个 <code>query</code>，那也就不需要进一步的读取磁盘、精确查找了，可以有效地减少磁盘访问数量。</p>
<p><code>FilterPolicy</code> 就负责这件事情：它可以根据一组 <code>key</code> 创建一个小的过滤器 <code>filter</code>，并且可以将该过滤器和键值对存储在磁盘中，在查询时快速判断 <code>query</code> 是否在 <code>filter</code> 中。默认使用的 <code>FilterPolicy</code> 即为布隆过滤器。<code>FilterPolicy</code> 定义于 <a href="https://github.com/google/leveldb/blob/master/include/leveldb/filter_policy.h"><code>include/leveldb/filter_policy.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/export.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slice</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**过滤器，用于快速判断 查找的Key是否存在。默认采用布隆过滤器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 暴露的接口除了 FilterPolicy 接口类，还有 NewBloomFilterPolicy 函数，</span></span><br><span class="line"><span class="comment"> * 其他代码中均使用 FilterPolicy。</span></span><br><span class="line"><span class="comment"> * 这样的设计可以保证使用者可以自行定义策略类、方便地替换原有的布隆过滤器。</span></span><br><span class="line"><span class="comment"> * 这种设计也称之为策略模式，将策略单独设计为一个类或接口，</span></span><br><span class="line"><span class="comment"> * 不同的子类对应不同的策略方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">FilterPolicy</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">FilterPolicy</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the name of this policy.  Note that if the filter encoding</span></span><br><span class="line">  <span class="comment">// changes in an incompatible way, the name returned by this method</span></span><br><span class="line">  <span class="comment">// must be changed.  Otherwise, old incompatible filters may be</span></span><br><span class="line">  <span class="comment">// passed to methods of this type.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keys[0,n-1] contains a list of keys (potentially with duplicates)</span></span><br><span class="line">  <span class="comment">// that are ordered according to the user supplied comparator.</span></span><br><span class="line">  <span class="comment">// Append a filter that summarizes keys[0,n-1] to *dst.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Warning: do not change the initial contents of *dst.  Instead,</span></span><br><span class="line">  <span class="comment">// append the newly constructed filter to *dst.</span></span><br><span class="line">  <span class="comment">// 根据给定的keys创建Filter</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::string* dst)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &quot;filter&quot; contains the data appended by a preceding call to</span></span><br><span class="line">  <span class="comment">// CreateFilter() on this class.  This method must return true if</span></span><br><span class="line">  <span class="comment">// the key was in the list of keys passed to CreateFilter().</span></span><br><span class="line">  <span class="comment">// This method may return true or false if the key was not on the</span></span><br><span class="line">  <span class="comment">// list, but it should aim to return false with a high probability.</span></span><br><span class="line">  <span class="comment">// 注意函数名称的May，即存在 false positive的可能。</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; filter)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return a new filter policy that uses a bloom filter with approximately</span></span><br><span class="line"><span class="comment">// the specified number of bits per key.  A good value for bits_per_key</span></span><br><span class="line"><span class="comment">// is 10, which yields a filter with ~ 1% false positive rate.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Callers must delete the result after any database that is using the</span></span><br><span class="line"><span class="comment">// result has been closed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note: if you are using a custom comparator that ignores some parts</span></span><br><span class="line"><span class="comment">// of the keys being compared, you must not use NewBloomFilterPolicy()</span></span><br><span class="line"><span class="comment">// and must provide your own FilterPolicy that also ignores the</span></span><br><span class="line"><span class="comment">// corresponding parts of the keys.  For example, if the comparator</span></span><br><span class="line"><span class="comment">// ignores trailing spaces, it would be incorrect to use a</span></span><br><span class="line"><span class="comment">// FilterPolicy (like NewBloomFilterPolicy) that does not ignore</span></span><br><span class="line"><span class="comment">// trailing spaces in keys.</span></span><br><span class="line"><span class="comment">// 默认采用bloom过滤器，推荐的bits_per_key参数为10，此时false positive rate约等于1%</span></span><br><span class="line"><span class="function">LEVELDB_EXPORT <span class="keyword">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// STORAGE_LEVELDB_INCLUDE_FILTER_POLICY_H_</span></span></span><br></pre></td></tr></table></figure>

<p><code>FilterPolicy</code> 中，<code>CreateFilter</code> 负责创建 <code>filter</code>，<code>KeyMayMatch</code> 负责判断 <code>key</code> 是否在 <code>filter</code> 中。注意这个 <code>May</code>，即这里 <code>Match</code> 判断可能会出错，也允许会出错。对于布隆过滤器，如果 <code>Key</code> 在 <code>filter</code> 里，那么一定会 <code>Match</code> 上；反之如果不在，那么有小概率也会 <code>Match</code> 上，进而会多做一些磁盘访问，只要这个概率足够小也无伤大雅。这也刚好符合 <code>KeyMayMatch</code> 函数的需求。</p>
<p>暴露的接口除了 <code>FilterPolicy</code> 接口类，还有 <code>NewBloomFilterPolicy</code> 函数，其他代码中均使用 <code>FilterPolicy</code>。这样的设计可以保证使用者可以自行定义策略类、方便地替换原有的布隆过滤器。这种设计也称之为<a href="https://en.wikipedia.org/wiki/Strategy_pattern">策略模式</a>，将策略单独设计为一个类或接口，不同的子类对应不同的策略方法。继续看布隆过滤器的实现 <a href="https://github.com/google/leveldb/blob/master/util/bloom.cc"><code>util/bloom.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/filter_policy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/slice.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/hash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="comment">//对key进行哈希操作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">BloomHash</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Hash</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>(), <span class="number">0xbc9f1d34</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilterPolicy</span> :</span> <span class="keyword">public</span> FilterPolicy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> : bits_per_key_(bits_per_key) &#123;</span></span><br><span class="line">    <span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line">    <span class="comment">// 哈希函数的数目为 bits_per_key * ln2 ，上下限分别为30与1</span></span><br><span class="line">    k_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>);  <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line">    <span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回过滤策略的名称</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;leveldb.BuiltinBloomFilter2&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, std::string* dst)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line">    <span class="comment">// 根据 keys的数量n 与 每个key需要的比特位数，计算bloom filter的总体大小</span></span><br><span class="line">    <span class="keyword">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For small n, we can see a very high false positive rate.  Fix it</span></span><br><span class="line">    <span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line">    <span class="comment">// Bloom filter的容量过小时，很容易false positive，因此最小容量设置为64</span></span><br><span class="line">    <span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Bloom filter容量大小按字节大小向上取整，即为8bits的倍数</span></span><br><span class="line">    <span class="keyword">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">    bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> init_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">    dst-&gt;<span class="built_in">resize</span>(init_size + bytes, <span class="number">0</span>);</span><br><span class="line">    dst-&gt;<span class="built_in">push_back</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(k_));  <span class="comment">// Remember # of probes in filter</span></span><br><span class="line">    <span class="keyword">char</span>* array = &amp;(*dst)[init_size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line">      <span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line">      <span class="keyword">uint32_t</span> h = <span class="built_in">BloomHash</span>(keys[i]);</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">        array[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line">        h += delta;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; bloom_filter)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> len = bloom_filter.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* array = bloom_filter.<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the encoded k so that we can read filters generated by</span></span><br><span class="line">    <span class="comment">// bloom filters created using different parameters.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> k = array[len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k &gt; <span class="number">30</span>) &#123;</span><br><span class="line">      <span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></span><br><span class="line">      <span class="comment">// Consider it a match.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> h = <span class="built_in">BloomHash</span>(key);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">      <span class="keyword">if</span> ((array[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      h += delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">size_t</span> bits_per_key_; <span class="comment">//每一个key需要的bits位数，用于计算过滤器的容量</span></span><br><span class="line">  <span class="keyword">size_t</span> k_;            <span class="comment">//表示Bloom Filter中哈希函数的数目</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BloomFilterPolicy</span>(bits_per_key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p><code>BloomFilterPolicy</code> 构造时需要提供 <code>bits_per_key</code>，后再根据 <code>key</code> 的数量 n一起计算出所需要的 <code>bits</code> 数 m。而代码中的 <code>k_</code> 即为布隆过滤器中哈希函数的数目 k，这里 k=m*/<em>n</em>ln2，详细介绍可以参考<a href="https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions">维基百科</a>。</p>
<p>而后，依次计算 n个 <code>key</code> 的 k个哈希结果。这里使用了 <a href="https://en.wikipedia.org/wiki/Double_hashing">Double Hash</a>。</p>
<p>Double Hash 一般用于开放寻址哈希的优化。这里直接取连续的 k个哈希结果作为布隆过滤器需要的 k个哈希函数结果，一切为了速度。</p>
<h3 id="5-内存池-Arena"><a href="#5-内存池-Arena" class="headerlink" title="5. 内存池 Arena"></a>5. 内存池 Arena</h3><p><code>LevelDB</code> 中实现了一个简单的内存池组建 Arena，位于 <a href="https://github.com/google/leveldb/blob/master/util/arena.h"><code>util/arena.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LevelDB的内存池</span></span><br><span class="line"><span class="comment"> * 申请内存时，将申请到的内存块放入std::vector blocks_中，</span></span><br><span class="line"><span class="comment"> * 在Arena的生命周期结束后，统一释放掉所有申请到的内存</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 每次会申请一个大的 block，默认大小为 4KB。</span></span><br><span class="line"><span class="comment"> * 而后申请 bytes 长度的空间时，</span></span><br><span class="line"><span class="comment"> * 如果当前 block 的剩余大小足够分配，则返回分配的内存地址并更新余下的起始位置和大小；</span></span><br><span class="line"><span class="comment"> * 否则将会直接申请新的 block。析构时会删除所有 block。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当前空间不足时有一个优化，如果申请的空间大于 kBlockSize / 4 也就是 1KB 时，</span></span><br><span class="line"><span class="comment"> * 会直接申请对应长度的 block 返回，不更新当前剩余 block 的起始位置和大小，</span></span><br><span class="line"><span class="comment"> * 这样下次申请小空间时依然可以使用当前余下的空间；</span></span><br><span class="line"><span class="comment"> * 否则将放弃当前剩余空间，重新申请一块 4KB 的 block 再分配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arena</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Arena</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Arena</span>(<span class="keyword">const</span> Arena&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Arena&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Arena&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Arena</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接分配内存</span></span><br><span class="line">  <span class="comment">// Return a pointer to a newly allocated memory block of &quot;bytes&quot; bytes.</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">Allocate</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请对齐的内存空间</span></span><br><span class="line">  <span class="comment">// Allocate memory with the normal alignment guarantees provided by malloc.</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an estimate of the total memory usage of data allocated</span></span><br><span class="line">  <span class="comment">// by the arena.</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">MemoryUsage</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> memory_usage_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateFallback</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateNewBlock</span><span class="params">(<span class="keyword">size_t</span> block_bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocation state</span></span><br><span class="line">  <span class="comment">// alloc_ptr_标记1个4KB block内部分配内存的起始地址</span></span><br><span class="line">  <span class="keyword">char</span>* alloc_ptr_;</span><br><span class="line">  <span class="comment">//alloc_bytes_remaining_记录1个4KB block内部剩余可用的内存字节数</span></span><br><span class="line">  <span class="keyword">size_t</span> alloc_bytes_remaining_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Array of new[] allocated memory blocks</span></span><br><span class="line">  <span class="comment">// blocks_存储多个4KB block</span></span><br><span class="line">  std::vector&lt;<span class="keyword">char</span>*&gt; blocks_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Total memory usage of the arena.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// TODO(costan): This member is accessed via atomics, but the others are</span></span><br><span class="line">  <span class="comment">//               accessed without any locking. Is this OK?</span></span><br><span class="line">  std::atomic&lt;<span class="keyword">size_t</span>&gt; memory_usage_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">Arena::Allocate</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The semantics of what to return are a bit messy if we allow</span></span><br><span class="line">  <span class="comment">// 0-byte allocations, so we disallow them here (we don&#x27;t need</span></span><br><span class="line">  <span class="comment">// them for our internal use).</span></span><br><span class="line">  <span class="built_in">assert</span>(bytes &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    <span class="keyword">char</span>* result = alloc_ptr_;</span><br><span class="line">    alloc_ptr_ += bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p><code>Arena</code> 提供三个接口，<code>Allocate</code>、<code>AllocateAligned</code> 和 <code>MemoryUsage</code>，分别实现申请指定大小内存、申请对齐的指定大小内存和查询内存使用。具体的函数实现在 <a href="https://github.com/google/leveldb/blob/master/util/arena.cc"><code>util/arena.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/arena.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kBlockSize = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">Arena::<span class="built_in">Arena</span>()</span><br><span class="line">    : <span class="built_in">alloc_ptr_</span>(<span class="literal">nullptr</span>), <span class="built_in">alloc_bytes_remaining_</span>(<span class="number">0</span>), <span class="built_in">memory_usage_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Arena::~<span class="built_in">Arena</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; blocks_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] blocks_[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateFallback</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当申请的内存大小 大于 kBlockSize/4，即1KB时，会直接申请对应需要长度的block返回</span></span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// Object is more than a quarter of our block size.  Allocate it separately</span></span><br><span class="line">    <span class="comment">// to avoid wasting too much space in leftover bytes.</span></span><br><span class="line">    <span class="keyword">char</span>* result = <span class="built_in">AllocateNewBlock</span>(bytes);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当申请的内存大小小于1KB时，直接分配4KB block，并更新剩余block的起始位置和大小</span></span><br><span class="line">  <span class="comment">// We waste the remaining space in the current block.</span></span><br><span class="line">  alloc_ptr_ = <span class="built_in">AllocateNewBlock</span>(kBlockSize);</span><br><span class="line">  alloc_bytes_remaining_ = kBlockSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* result = alloc_ptr_;</span><br><span class="line">  alloc_ptr_ += bytes;</span><br><span class="line">  alloc_bytes_remaining_ -= bytes;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateAligned</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> align = (<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*) &gt; <span class="number">8</span>) ? <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*) : <span class="number">8</span>;</span><br><span class="line">  <span class="built_in"><span class="keyword">static_assert</span></span>((align &amp; (align - <span class="number">1</span>)) == <span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;Pointer size should be a power of 2&quot;</span>);</span><br><span class="line">  <span class="keyword">size_t</span> current_mod = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(alloc_ptr_) &amp; (align - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">size_t</span> slop = (current_mod == <span class="number">0</span> ? <span class="number">0</span> : align - current_mod);</span><br><span class="line">  <span class="keyword">size_t</span> needed = bytes + slop;</span><br><span class="line">  <span class="keyword">char</span>* result;</span><br><span class="line">  <span class="keyword">if</span> (needed &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    result = alloc_ptr_ + slop;</span><br><span class="line">    alloc_ptr_ += needed;</span><br><span class="line">    alloc_bytes_remaining_ -= needed;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// AllocateFallback always returned aligned memory</span></span><br><span class="line">    result = <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>((<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(result) &amp; (align - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="keyword">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span>[block_bytes];</span><br><span class="line">  blocks_.<span class="built_in">push_back</span>(result);</span><br><span class="line">  memory_usage_.<span class="built_in">fetch_add</span>(block_bytes + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>*),</span><br><span class="line">                          std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p>代码也很容易看懂。每次会申请一个大的 block，默认大小为 4KB。而后申请 <code>bytes</code> 长度的空间时，如果当前 block 的剩余大小足够分配，则返回分配的内存地址并更新余下的起始位置和大小；否则将会直接申请新的 block。析构时会删除所有 block。</p>
<p>当前空间不足时有一个优化，如果申请的空间大于 <code>kBlockSize / 4</code> 也就是 1KB 时，会直接申请对应长度的 block 返回，不更新当前剩余 block 的起始位置和大小，这样下次申请小空间时依然可以使用当前余下的空间；否则将放弃当前剩余空间，重新申请一块 4KB 的 block 再分配。</p>
<p>当频繁申请小内存时，内存池可以规避掉大部分的系统级申请。接下来的介绍的跳表、以及后续文章介绍的 <code>MemTable</code> 中均会使用到该内存池。</p>
<h3 id="6-跳表-SkipList"><a href="#6-跳表-SkipList" class="headerlink" title="6. 跳表 SkipList"></a>6. 跳表 SkipList</h3><p>跳表是在传统链表上加入跳跃连接的有序链表。因为有序，所以可以根据顺序关系，快速跳过无关元素。查询和插入的平均复杂度均为 \mathcal O(\log n)O(log<em>n</em>)。<a href="https://en.wikipedia.org/wiki/Skip_list">维基百科上有一副经典图</a>：</p>
<p><a href="https://sf-zhou.github.io/images/3c325892dba645fe90dd7a06f0c479c0.gif"><img src="https://sf-zhou.github.io/images/3c325892dba645fe90dd7a06f0c479c0.gif" alt="img"></a></p>
<p>LevelDB 中实现的跳表位于 <a href="https://github.com/google/leveldb/blob/master/db/skiplist.h"><code>db/skiplist.h</code></a>，所有实现均在该头文件里。仔细看图，对照代码，就很容易理解了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/arena.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/random.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳表的实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipList</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a new SkipList object that will use &quot;cmp&quot; for comparing keys,</span></span><br><span class="line">  <span class="comment">// and will allocate memory using &quot;*arena&quot;.  Objects allocated in the arena</span></span><br><span class="line">  <span class="comment">// must remain allocated for the lifetime of the skiplist object.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SkipList</span><span class="params">(Comparator cmp, Arena* arena)</span></span>;</span><br><span class="line">  <span class="comment">// 不允许拷贝构造</span></span><br><span class="line">  <span class="built_in">SkipList</span>(<span class="keyword">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  SkipList&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert key into the list.</span></span><br><span class="line">  <span class="comment">// REQUIRES: nothing that compares equal to key is currently in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff an entry that compares equal to key is in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Contains</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iteration over the contents of a skip list</span></span><br><span class="line">  <span class="comment">// 定义迭代器类，用于对跳表进行操作，包含SkipList*与Node*,2个成员变量</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Initialize an iterator over the specified list.</span></span><br><span class="line">    <span class="comment">// The returned iterator is not valid.</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(<span class="keyword">const</span> SkipList* list)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true iff the iterator is positioned at a valid node.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the key at the current position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advances to the next position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advances to the previous position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Key&amp; target)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the first entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the last entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> SkipList* list_;</span><br><span class="line">    Node* node_;</span><br><span class="line">    <span class="comment">// Intentionally copyable</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//记录SkipList最大的高度</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> kMaxHeight = <span class="number">12</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetMaxHeight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max_height_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Node* <span class="title">NewNode</span><span class="params">(<span class="keyword">const</span> Key&amp; key, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">RandomHeight</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Equal</span><span class="params">(<span class="keyword">const</span> Key&amp; a, <span class="keyword">const</span> Key&amp; b)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">compare_</span>(a, b) == <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if key is greater than the data stored in &quot;n&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">KeyIsAfterNode</span><span class="params">(<span class="keyword">const</span> Key&amp; key, Node* n)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the earliest node that comes at or after key.</span></span><br><span class="line">  <span class="comment">// Return nullptr if there is no such node.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If prev is non-null, fills prev[level] with pointer to previous</span></span><br><span class="line">  <span class="comment">// node at &quot;level&quot; for every level in [0..max_height_-1].</span></span><br><span class="line">  <span class="function">Node* <span class="title">FindGreaterOrEqual</span><span class="params">(<span class="keyword">const</span> Key&amp; key, Node** prev)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the latest node with a key &lt; key.</span></span><br><span class="line">  <span class="comment">// Return head_ if there is no such node.</span></span><br><span class="line">  <span class="function">Node* <span class="title">FindLessThan</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the last node in the list.</span></span><br><span class="line">  <span class="comment">// Return head_ if list is empty.</span></span><br><span class="line">  <span class="function">Node* <span class="title">FindLast</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Immutable after construction</span></span><br><span class="line">  <span class="comment">// 比较器</span></span><br><span class="line">  Comparator <span class="keyword">const</span> compare_;</span><br><span class="line">  <span class="comment">// 跳表的内存池</span></span><br><span class="line">  Arena* <span class="keyword">const</span> arena_;  <span class="comment">// Arena used for allocations of nodes</span></span><br><span class="line">  <span class="comment">// SkipList 的前置哨兵节点</span></span><br><span class="line">  Node* <span class="keyword">const</span> head_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modified only by Insert().  Read racily by readers, but stale</span></span><br><span class="line">  <span class="comment">// values are ok.</span></span><br><span class="line">  <span class="comment">// 最大高度</span></span><br><span class="line">  std::atomic&lt;<span class="keyword">int</span>&gt; max_height_;  <span class="comment">// Height of the entire list</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read/written only by Insert().</span></span><br><span class="line">  <span class="comment">// 随机数生成器</span></span><br><span class="line">  Random rnd_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation details follow</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SkipList</span>&lt;</span>Key, Comparator&gt;::Node &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Node</span><span class="params">(<span class="keyword">const</span> Key&amp; k)</span> : key(k) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储主键Key</span></span><br><span class="line">  Key <span class="keyword">const</span> key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Accessors/mutators for links.  Wrapped in methods so we can</span></span><br><span class="line">  <span class="comment">// add the appropriate barriers as necessary.</span></span><br><span class="line">  <span class="comment">// 获取当前节点在指定level的下一个节点</span></span><br><span class="line">  <span class="function">Node* <span class="title">Next</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span></span><br><span class="line">    <span class="comment">// version of the returned Node.</span></span><br><span class="line">    <span class="keyword">return</span> next_[n].<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将当前节点在指定level的下一个节点设置为x</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetNext</span><span class="params">(<span class="keyword">int</span> n, Node* x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use a &#x27;release store&#x27; so that anybody who reads through this</span></span><br><span class="line">    <span class="comment">// pointer observes a fully initialized version of the inserted node.</span></span><br><span class="line">    next_[n].<span class="built_in">store</span>(x, std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无内存障碍版本的实现</span></span><br><span class="line">  <span class="comment">// No-barrier variants that can be safely used in a few locations.</span></span><br><span class="line">  <span class="function">Node* <span class="title">NoBarrier_Next</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> next_[n].<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NoBarrier_SetNext</span><span class="params">(<span class="keyword">int</span> n, Node* x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    next_[n].<span class="built_in">store</span>(x, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Array of length equal to the node height.  next_[0] is lowest level link.</span></span><br><span class="line">  <span class="comment">//1.这里提前使用声明分配1个对象的内存，是因为，第0层数据肯定是都有的，而且，是全部数据</span></span><br><span class="line">  <span class="comment">//2.使用数组方式，那么后续分配的内存就是连续的，cache-friend</span></span><br><span class="line">  std::atomic&lt;Node*&gt; next_[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::<span class="built_in">NewNode</span>(</span><br><span class="line">    <span class="keyword">const</span> Key&amp; key, <span class="keyword">int</span> height) &#123;</span><br><span class="line">  <span class="comment">//因为Node中的成员变量已定义1个Node*，所以此处只需height-1</span></span><br><span class="line">  <span class="keyword">char</span>* <span class="keyword">const</span> node_memory = arena_-&gt;<span class="built_in">AllocateAligned</span>(</span><br><span class="line">      <span class="built_in"><span class="keyword">sizeof</span></span>(Node) + <span class="built_in"><span class="keyword">sizeof</span></span>(std::atomic&lt;Node*&gt;) * (height - <span class="number">1</span>));</span><br><span class="line">  <span class="comment">// 定位new ，空间换时间，从LevelDB的内存池Arena中开辟的node_memory中，new Node(key)</span></span><br><span class="line">  <span class="comment">// 与常规new相比，不需要申请空间，仅需调用构造函数，优化CPU缓存</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in"><span class="keyword">new</span></span> (node_memory) <span class="built_in">Node</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Iterator</span>(<span class="keyword">const</span> SkipList* list) &#123;</span><br><span class="line">  list_ = list;</span><br><span class="line">  node_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Valid</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> node_ != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Key&amp; SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">key</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">  <span class="keyword">return</span> node_-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Next</span>() &#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">  node_ = node_-&gt;<span class="built_in">Next</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Prev</span>() &#123;</span><br><span class="line">  <span class="comment">// Instead of using explicit &quot;prev&quot; links, we just search for the</span></span><br><span class="line">  <span class="comment">// last node that falls before key.</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">  node_ = list_-&gt;<span class="built_in">FindLessThan</span>(node_-&gt;key);</span><br><span class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class="line">    node_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Seek</span>(<span class="keyword">const</span> Key&amp; target) &#123;</span><br><span class="line">  node_ = list_-&gt;<span class="built_in">FindGreaterOrEqual</span>(target, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">SeekToFirst</span>() &#123;</span><br><span class="line">  node_ = list_-&gt;head_-&gt;<span class="built_in">Next</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">SeekToLast</span>() &#123;</span><br><span class="line">  node_ = list_-&gt;<span class="built_in">FindLast</span>();</span><br><span class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class="line">    node_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SkipList&lt;Key, Comparator&gt;::<span class="built_in">RandomHeight</span>() &#123;</span><br><span class="line">  <span class="comment">// Increase height with probability 1 in kBranching</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> kBranching = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> height = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (height &lt; kMaxHeight &amp;&amp; rnd_.<span class="built_in">OneIn</span>(kBranching)) &#123;</span><br><span class="line">    height++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(height &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">assert</span>(height &lt;= kMaxHeight);</span><br><span class="line">  <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> SkipList&lt;Key, Comparator&gt;::<span class="built_in">KeyIsAfterNode</span>(<span class="keyword">const</span> Key&amp; key, Node* n) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// null n is considered infinite</span></span><br><span class="line">  <span class="keyword">return</span> (n != <span class="literal">nullptr</span>) &amp;&amp; (<span class="built_in">compare_</span>(n-&gt;key, key) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::<span class="built_in">FindGreaterOrEqual</span>(<span class="keyword">const</span> Key&amp; key,</span><br><span class="line">                                              Node** prev) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="comment">// level从0开始编码，0 —— MaxHeight-1</span></span><br><span class="line">  <span class="keyword">int</span> level = <span class="built_in">GetMaxHeight</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 从最高层level开始查找</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 定位到当前level的下一个节点</span></span><br><span class="line">    Node* next = x-&gt;<span class="built_in">Next</span>(level);</span><br><span class="line">    <span class="comment">// key 大于next的key，说明不在当前区间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">KeyIsAfterNode</span>(key, next)) &#123;</span><br><span class="line">      <span class="comment">// Keep searching in this list</span></span><br><span class="line">      x = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// key在当前区间段内，则向更低的level中继续查找</span></span><br><span class="line">      <span class="comment">// 在查找的同时，对传入的参数prev进行设置，设置prev节点</span></span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">nullptr</span>) prev[level] = x;</span><br><span class="line">      <span class="comment">// 在最底层的level中找到相应位置</span></span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::<span class="built_in">FindLessThan</span>(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="built_in">GetMaxHeight</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(x == head_ || <span class="built_in">compare_</span>(x-&gt;key, key) &lt; <span class="number">0</span>);</span><br><span class="line">    Node* next = x-&gt;<span class="built_in">Next</span>(level);</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">nullptr</span> || <span class="built_in">compare_</span>(next-&gt;key, key) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::<span class="built_in">FindLast</span>()</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="built_in">GetMaxHeight</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Node* next = x-&gt;<span class="built_in">Next</span>(level);</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">SkipList&lt;Key, Comparator&gt;::<span class="built_in">SkipList</span>(Comparator cmp, Arena* arena)</span><br><span class="line">    : <span class="built_in">compare_</span>(cmp),</span><br><span class="line">      <span class="built_in">arena_</span>(arena),</span><br><span class="line">      <span class="built_in">head_</span>(<span class="built_in">NewNode</span>(<span class="number">0</span> <span class="comment">/* any key will do */</span>, kMaxHeight)),</span><br><span class="line">      <span class="built_in">max_height_</span>(<span class="number">1</span>),</span><br><span class="line">      <span class="built_in">rnd_</span>(<span class="number">0xdeadbeef</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kMaxHeight; i++) &#123;</span><br><span class="line">    head_-&gt;<span class="built_in">SetNext</span>(i, <span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SkipList&lt;Key, Comparator&gt;::<span class="built_in">Insert</span>(<span class="keyword">const</span> Key&amp; key) &#123;</span><br><span class="line">  <span class="comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></span><br><span class="line">  <span class="comment">// here since Insert() is externally synchronized.</span></span><br><span class="line">  <span class="comment">// 声明prev节点数组，代表插入位置的前一个节点</span></span><br><span class="line">  Node* prev[kMaxHeight];</span><br><span class="line">  <span class="comment">//使用FindGreaterOrEqual函数，找到第一个大于等于插入key的位置</span></span><br><span class="line">  Node* x = <span class="built_in">FindGreaterOrEqual</span>(key, prev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Our data structure does not allow duplicate insertion</span></span><br><span class="line">  <span class="built_in">assert</span>(x == <span class="literal">nullptr</span> || !<span class="built_in">Equal</span>(key, x-&gt;key));</span><br><span class="line">  <span class="comment">// 使用随机数获取该节点的插入高度</span></span><br><span class="line">  <span class="keyword">int</span> height = <span class="built_in">RandomHeight</span>();</span><br><span class="line">  <span class="keyword">if</span> (height &gt; <span class="built_in">GetMaxHeight</span>()) &#123;</span><br><span class="line">    <span class="comment">// 大于当前SkipList的最高高度的话，将多出来的高度的prev设置为哨兵节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">GetMaxHeight</span>(); i &lt; height; i++) &#123;</span><br><span class="line">      prev[i] = head_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// It is ok to mutate max_height_ without any synchronization</span></span><br><span class="line">    <span class="comment">// with concurrent readers.  A concurrent reader that observes</span></span><br><span class="line">    <span class="comment">// the new value of max_height_ will see either the old value of</span></span><br><span class="line">    <span class="comment">// new level pointers from head_ (nullptr), or a new value set in</span></span><br><span class="line">    <span class="comment">// the loop below.  In the former case the reader will</span></span><br><span class="line">    <span class="comment">// immediately drop to the next level since nullptr sorts after all</span></span><br><span class="line">    <span class="comment">// keys.  In the latter case the reader will use the new node.</span></span><br><span class="line">    <span class="comment">// 更新max_height_</span></span><br><span class="line">    max_height_.<span class="built_in">store</span>(height, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建要插入的节点对象x</span></span><br><span class="line">  x = <span class="built_in">NewNode</span>(key, height);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">    <span class="comment">// we publish a pointer to &quot;x&quot; in prev[i].</span></span><br><span class="line">    <span class="comment">// 首先将x的next指向prev的下一个节点</span></span><br><span class="line">    x-&gt;<span class="built_in">NoBarrier_SetNext</span>(i, prev[i]-&gt;<span class="built_in">NoBarrier_Next</span>(i));</span><br><span class="line">    <span class="comment">// 将prev指向x</span></span><br><span class="line">    prev[i]-&gt;<span class="built_in">SetNext</span>(i, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> SkipList&lt;Key, Comparator&gt;::<span class="built_in">Contains</span>(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = <span class="built_in">FindGreaterOrEqual</span>(key, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">nullptr</span> &amp;&amp; <span class="built_in">Equal</span>(key, x-&gt;key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本的数据结构主要介绍的是局部细节，没有过多的代码依赖，容易看懂。而真正困难的部分，是梳理清楚整体的流程和结构。这时自上而下就要容易很多，比如看看文档、架构图、流程图等，不至于在庞杂的代码细节中迷失。</p>
<p>下一篇会开始介绍 <code>LevelDB</code> 中的核心组件。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码分析——3.日志</title>
    <url>/2022/02/09/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%943.%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="三-日志"><a href="#三-日志" class="headerlink" title="三.日志"></a>三.日志</h2><p>本系列的<a href="https://gasolly.github.io/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AD/">前两篇</a>介绍了 LevelDB 中使用的数据结构，并没有牵涉到 LevelDB 的核心实现。接下来的几篇将着重介绍 LevelDB 核心组件，包括日志、内存数据库、SortedTable、Compaction 和版本管理。本篇着重阐述高性能写操作的核心：日志和内存数据库。</p>
<p>怎样最快地把键值对存起来？不考虑查找的速度的话，追加地写入文件是最快的，查找时反向查找。举个例子🌰：</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>[<span class="number">1</span>] = <span class="string">&quot;LY&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>] = <span class="string">&quot;SF&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">3</span>] = <span class="string">&quot;MX&quot;</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span>[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>] = <span class="string">&quot;ST&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中的 5 个操作，顺序地写入文件，每次添加一行，可以得到类似如下的记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Add 1: &quot;LY&quot;</span><br><span class="line">Add 2: &quot;SF&quot;</span><br><span class="line">Add 3: &quot;MX&quot;</span><br><span class="line">Del 1</span><br><span class="line">Add 2: &quot;ST&quot;</span><br></pre></td></tr></table></figure>

<p>查找时反向查找，例如查找 <code>key=2</code>，返回最后一行最新的结果 “ST”；查找 <code>key=1</code>，返回倒数第二行的删除操作。LevelDB 中写操作使用了相似的技术，其写入分为两步：</p>
<ol>
<li>将数据追加到日志中；</li>
<li>将数据插入内存数据库。</li>
</ol>
<p>追加到日志一来保证了写入速度，二来保证了数据不会丢失，只要日志写入了磁盘，即使机器断电了，重启后也可以根据日志恢复出数据来；插入内存数据库同样维持着高性能，当内存数据库的小大到达一定规模时，会将当前的内存数据库持久化并建立新的内存数据库。</p>
<h3 id="1-批量写操作-WriteBatch"><a href="#1-批量写操作-WriteBatch" class="headerlink" title="1. 批量写操作 WriteBatch"></a>1. 批量写操作 WriteBatch</h3><p>LevelDB 的键值对写入接口为 <code>DB::Put(options, key, value)</code>，删除某个键值对的接口为 <code>DB::Delete(options, key)</code>，其对应的实现为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// source: db/db_impl.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DB::Put</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; opt, <span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  batch.<span class="built_in">Put</span>(key, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Write</span>(opt, &amp;batch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DB::Delete</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; opt, <span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  batch.<span class="built_in">Delete</span>(key);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Write</span>(opt, &amp;batch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入和删除操作首先被打包成一个 <code>WriteBatch</code>。其定义于 <a href="https://github.com/google/leveldb/blob/master/include/leveldb/write_batch.h"><code>include/leveldb/write_batch.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WriteBatch holds a collection of updates to apply atomically to a DB.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The updates are applied in the order in which they are added</span></span><br><span class="line"><span class="comment">// to the WriteBatch.  For example, the value of &quot;key&quot; will be &quot;v3&quot;</span></span><br><span class="line"><span class="comment">// after the following batch is written:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    batch.Put(&quot;key&quot;, &quot;v1&quot;);</span></span><br><span class="line"><span class="comment">//    batch.Delete(&quot;key&quot;);</span></span><br><span class="line"><span class="comment">//    batch.Put(&quot;key&quot;, &quot;v2&quot;);</span></span><br><span class="line"><span class="comment">//    batch.Put(&quot;key&quot;, &quot;v3&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Multiple threads can invoke const methods on a WriteBatch without</span></span><br><span class="line"><span class="comment">// external synchronization, but if any of the threads may call a</span></span><br><span class="line"><span class="comment">// non-const method, all threads accessing the same WriteBatch must use</span></span><br><span class="line"><span class="comment">// external synchronization.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/export.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/status.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slice</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">WriteBatch</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Handler</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Handler</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Put</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WriteBatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Intentionally copyable.</span></span><br><span class="line">  <span class="built_in">WriteBatch</span>(<span class="keyword">const</span> WriteBatch&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  WriteBatch&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> WriteBatch&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">WriteBatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Store the mapping &quot;key-&gt;value&quot; in the database.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the database contains a mapping for &quot;key&quot;, erase it.  Else do nothing.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clear all updates buffered in this batch.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The size of the database changes caused by this batch.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This number is tied to implementation details, and may change across</span></span><br><span class="line">  <span class="comment">// releases. It is intended for LevelDB usage metrics.</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">ApproximateSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copies the operations in &quot;source&quot; to this batch.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This runs in O(source size) time. However, the constant factor is better</span></span><br><span class="line">  <span class="comment">// than calling Iterate() over the source batch with a Handler that replicates</span></span><br><span class="line">  <span class="comment">// the operations into this batch.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Append</span><span class="params">(<span class="keyword">const</span> WriteBatch&amp; source)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Support for iterating over the contents of a batch.</span></span><br><span class="line">  <span class="function">Status <span class="title">Iterate</span><span class="params">(Handler* handler)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteBatchInternal</span>;</span></span><br><span class="line"></span><br><span class="line">  std::string rep_;  <span class="comment">// See comment in write_batch.cc for the format of rep_</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p><code>WriteBatch</code> 接口中除了提到的 <code>Put</code> 和 <code>Delete</code>，还提供了一个 <code>Append</code> 方法可以将其他 <code>WriteBatch</code> 合并过来。另外提供了一个 <code>Iterate</code> 迭代函数和对应的 <code>Handler</code> 类接口，后面会使用到。值得注意的还有 <code>friend class WriteBatchInternal;</code>，这种预先定义一个友元类、后期则可以在该友元类中直接访问私有变量和方法，适合一些不方便暴露出来的内部操作。接着看 <code>WriteBatchInternal</code> 的定义 <a href="https://github.com/google/leveldb/blob/master/db/write_batch_internal.h"><code>db/write_batch_internal.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;db/dbformat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/write_batch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTable</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteBatchInternal provides static methods for manipulating a</span></span><br><span class="line"><span class="comment">// WriteBatch that we don&#x27;t want in the public WriteBatch interface.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteBatchInternal</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Return the number of entries in the batch.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Count</span><span class="params">(<span class="keyword">const</span> WriteBatch* batch)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the count for the number of entries in the batch.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetCount</span><span class="params">(WriteBatch* batch, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the sequence number for the start of this batch.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> SequenceNumber <span class="title">Sequence</span><span class="params">(<span class="keyword">const</span> WriteBatch* batch)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Store the specified number as the sequence number for the start of</span></span><br><span class="line">  <span class="comment">// this batch.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetSequence</span><span class="params">(WriteBatch* batch, SequenceNumber seq)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Slice <span class="title">Contents</span><span class="params">(<span class="keyword">const</span> WriteBatch* batch)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Slice</span>(batch-&gt;rep_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">ByteSize</span><span class="params">(<span class="keyword">const</span> WriteBatch* batch)</span> </span>&#123; <span class="keyword">return</span> batch-&gt;rep_.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetContents</span><span class="params">(WriteBatch* batch, <span class="keyword">const</span> Slice&amp; contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Status <span class="title">InsertInto</span><span class="params">(<span class="keyword">const</span> WriteBatch* batch, MemTable* memtable)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Append</span><span class="params">(WriteBatch* dst, <span class="keyword">const</span> WriteBatch* src)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p>类中全部是静态函数，并且附带至少一个 <code>WriteBatch* batch</code> 参数。因为友元类的原因这些函数里均可以访问 <code>WriteBatch</code> 里唯一的私有成员 <code>rep_</code>。<code>WriteBatch</code> 和 <code>WriteBatchInternal</code> 函数实现均位于 <a href="https://github.com/google/leveldb/blob/master/db/write_batch.cc"><code>db/write_batch.cc</code></a>，为了方便阅读我会把内部的函数重新排序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WriteBatch header has an 8-byte sequence number followed by a 4-byte count.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kHeader = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">WriteBatch::<span class="built_in">WriteBatch</span>() &#123; <span class="built_in">Clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">WriteBatch::~<span class="built_in">WriteBatch</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">WriteBatch::Handler::~<span class="built_in">Handler</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBatch::Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  rep_.<span class="built_in">clear</span>();</span><br><span class="line">  rep_.<span class="built_in">resize</span>(kHeader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">WriteBatch::ApproximateSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep_.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WriteBatchInternal::Count</span><span class="params">(<span class="keyword">const</span> WriteBatch* b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">DecodeFixed32</span>(b-&gt;rep_.<span class="built_in">data</span>() + <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBatchInternal::SetCount</span><span class="params">(WriteBatch* b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">EncodeFixed32</span>(&amp;b-&gt;rep_[<span class="number">8</span>], n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SequenceNumber <span class="title">WriteBatchInternal::Sequence</span><span class="params">(<span class="keyword">const</span> WriteBatch* b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SequenceNumber</span>(<span class="built_in">DecodeFixed64</span>(b-&gt;rep_.<span class="built_in">data</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBatchInternal::SetSequence</span><span class="params">(WriteBatch* b, SequenceNumber seq)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(&amp;b-&gt;rep_[<span class="number">0</span>], seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WriteBatch::rep_</code> 的前 12 个字节定义为 Header，存储了 sequence number 和 count。<code>EncodeFixed</code> 和 <code>DecodeFixed</code>系列函数实现了数值到字符串的编解码，有兴趣可以前往 <a href="https://github.com/google/leveldb/blob/master/util/coding.cc"><code>util/coding.cc</code></a> 查看实现，这里不详细介绍了。接下来看 <code>Put</code> 和 <code>Delete</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBatch::Put</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(<span class="keyword">this</span>, WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>) + <span class="number">1</span>);</span><br><span class="line">  rep_.<span class="built_in">push_back</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(kTypeValue));</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBatch::Delete</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(<span class="keyword">this</span>, WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>) + <span class="number">1</span>);</span><br><span class="line">  rep_.<span class="built_in">push_back</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(kTypeDeletion));</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBatch::Append</span><span class="params">(<span class="keyword">const</span> WriteBatch&amp; source)</span> </span>&#123;</span><br><span class="line">  WriteBatchInternal::<span class="built_in">Append</span>(<span class="keyword">this</span>, &amp;source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBatchInternal::SetContents</span><span class="params">(WriteBatch* b, <span class="keyword">const</span> Slice&amp; contents)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(contents.<span class="built_in">size</span>() &gt;= kHeader);</span><br><span class="line">  b-&gt;rep_.<span class="built_in">assign</span>(contents.<span class="built_in">data</span>(), contents.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBatchInternal::Append</span><span class="params">(WriteBatch* dst, <span class="keyword">const</span> WriteBatch* src)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetCount</span>(dst, <span class="built_in">Count</span>(dst) + <span class="built_in">Count</span>(src));</span><br><span class="line">  <span class="built_in">assert</span>(src-&gt;rep_.<span class="built_in">size</span>() &gt;= kHeader);</span><br><span class="line">  dst-&gt;rep_.<span class="built_in">append</span>(src-&gt;rep_.<span class="built_in">data</span>() + kHeader, src-&gt;rep_.<span class="built_in">size</span>() - kHeader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Put</code> 和 <code>Delete</code> 首先将计数加一，在 <code>rep_</code> 中写入操作类型，再写入键值对。<code>PutLengthPrefixedSlice</code> 函数会先写入字符串的长度，再写入字符串的内容。<code>WriteBatchInternal</code> 的赋值和追加均是对 <code>rep_</code> 的进行操作。继续看迭代函数和 <code>Handle</code> 的部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatch::Iterate</span><span class="params">(Handler* handler)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="function">Slice <span class="title">input</span><span class="params">(rep_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (input.<span class="built_in">size</span>() &lt; kHeader) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;malformed WriteBatch (too small)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  input.<span class="built_in">remove_prefix</span>(kHeader);</span><br><span class="line">  Slice key, value;</span><br><span class="line">  <span class="keyword">int</span> found = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!input.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    found++;</span><br><span class="line">    <span class="keyword">char</span> tag = input[<span class="number">0</span>];</span><br><span class="line">    input.<span class="built_in">remove_prefix</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> kTypeValue:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key) &amp;&amp;</span><br><span class="line">            <span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;value)) &#123;</span><br><span class="line">          handler-&gt;<span class="built_in">Put</span>(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad WriteBatch Put&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key)) &#123;</span><br><span class="line">          handler-&gt;<span class="built_in">Delete</span>(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad WriteBatch Delete&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;unknown WriteBatch tag&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (found != WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;WriteBatch has wrong count&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTableInserter</span> :</span> <span class="keyword">public</span> WriteBatch::Handler &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  SequenceNumber sequence_;</span><br><span class="line">  MemTable* mem_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    mem_-&gt;<span class="built_in">Add</span>(sequence_, kTypeValue, key, value);</span><br><span class="line">    sequence_++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    mem_-&gt;<span class="built_in">Add</span>(sequence_, kTypeDeletion, key, <span class="built_in">Slice</span>());</span><br><span class="line">    sequence_++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">WriteBatchInternal::InsertInto</span><span class="params">(<span class="keyword">const</span> WriteBatch* b, MemTable* memtable)</span> </span>&#123;</span><br><span class="line">  MemTableInserter inserter;</span><br><span class="line">  inserter.sequence_ = WriteBatchInternal::<span class="built_in">Sequence</span>(b);</span><br><span class="line">  inserter.mem_ = memtable;</span><br><span class="line">  <span class="keyword">return</span> b-&gt;<span class="built_in">Iterate</span>(&amp;inserter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代函数 <code>WriteBatch::Iterate</code> 会按照顺序将 <code>rep_</code> 中存储的键值对操作放到 <code>hander</code> 上执行。下面的匿名空间里定义了一个继承 <code>Handler</code> 的子类 <code>MemTableInserter</code>，将 <code>Put</code> 和 <code>Delete</code> 转到 <code>MemTable</code> 上执行。<code>MemTable</code> 即为内存数据库，本文稍后介绍。<code>WriteBatchInternal::InsertInto</code> 就直接根据 <code>MemTable</code> 构造 <code>MemTableInserter</code>。这样做的好处，可能就是 <code>WriteBatch::Iterate</code> 与 <code>MemTable</code> 解耦，<code>Handler</code> 可以自行替换。</p>
<p>综合来看，<code>WriteBatch</code> 将所有的修改和删除操作均存储到一个字符串中，并且提供了内存数据库的迭代接口。而单个字符串也可以非常方便地进行持久化，这一点也会在日志部分有所体现。</p>
<h3 id="2-日志-Log"><a href="#2-日志-Log" class="headerlink" title="2. 日志 Log"></a>2. 日志 Log</h3><p>在 <code>DB::Write</code> 函数中，核心的写入步骤代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add to log and apply to memtable.  We can release the lock</span></span><br><span class="line"><span class="comment">// during this phase since &amp;w is currently responsible for logging</span></span><br><span class="line"><span class="comment">// and protects against concurrent loggers and concurrent writes</span></span><br><span class="line"><span class="comment">// into mem_.</span></span><br><span class="line">&#123;</span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">  status = log_-&gt;<span class="built_in">AddRecord</span>(WriteBatchInternal::<span class="built_in">Contents</span>(updates));</span><br><span class="line">  <span class="keyword">bool</span> sync_error = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; options.sync) &#123;</span><br><span class="line">    status = logfile_-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      sync_error = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    status = WriteBatchInternal::<span class="built_in">InsertInto</span>(updates, mem_);</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  <span class="keyword">if</span> (sync_error) &#123;</span><br><span class="line">    <span class="comment">// The state of the log file is indeterminate: the log record we</span></span><br><span class="line">    <span class="comment">// just added may or may not show up when the DB is re-opened.</span></span><br><span class="line">    <span class="comment">// So we force the DB into a mode where all future writes fail.</span></span><br><span class="line">    <span class="built_in">RecordBackgroundError</span>(status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先追加到日志，再写入内存数据库。这里的 <code>log_</code> 为成员变量，类型为 <code>log::Writer</code>，其定义位于 <a href="https://github.com/google/leveldb/blob/master/db/log_writer.h"><code>db/log_writer.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;db/log_format.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/slice.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/status.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WritableFile</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> log &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a writer that will append data to &quot;*dest&quot;.</span></span><br><span class="line">  <span class="comment">// &quot;*dest&quot; must be initially empty.</span></span><br><span class="line">  <span class="comment">// &quot;*dest&quot; must remain live while this Writer is in use.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Writer</span><span class="params">(WritableFile* dest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a writer that will append data to &quot;*dest&quot;.</span></span><br><span class="line">  <span class="comment">// &quot;*dest&quot; must have initial length &quot;dest_length&quot;.</span></span><br><span class="line">  <span class="comment">// &quot;*dest&quot; must remain live while this Writer is in use.</span></span><br><span class="line">  <span class="built_in">Writer</span>(WritableFile* dest, <span class="keyword">uint64_t</span> dest_length);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Writer</span>(<span class="keyword">const</span> Writer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Writer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Writer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Writer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">Status <span class="title">EmitPhysicalRecord</span><span class="params">(RecordType type, <span class="keyword">const</span> <span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">  WritableFile* dest_;</span><br><span class="line">  <span class="keyword">int</span> block_offset_;  <span class="comment">// Current offset in block</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// crc32c values for all supported record types.  These are</span></span><br><span class="line">  <span class="comment">// pre-computed to reduce the overhead of computing the crc of the</span></span><br><span class="line">  <span class="comment">// record type stored in the header.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> type_crc_[kMaxRecordType + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace log</span></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p>公开的接口只有一个 <code>Log::Writer::AddRecord</code>，也就是 <code>DB::Write</code> 中调用的函数。另外类中还有一个私有数组 <code>type_crc_</code>，内部存储了预先计算的几种类型的 <code>CRC32</code> 校验值。常量 <code>kMaxRecordType</code> 定义于 <a href="https://github.com/google/leveldb/blob/master/db/format.h"><code>db/log_format.h</code></a>，该文件定义了日志格式相关的几个常量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RecordType</span> &#123;</span></span><br><span class="line">  <span class="comment">// Zero is reserved for preallocated files</span></span><br><span class="line">  kZeroType = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  kFullType = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For fragments</span></span><br><span class="line">  kFirstType = <span class="number">2</span>,</span><br><span class="line">  kMiddleType = <span class="number">3</span>,</span><br><span class="line">  kLastType = <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxRecordType = kLastType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kBlockSize = <span class="number">32768</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Header is checksum (4 bytes), length (2 bytes), type (1 byte).</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kHeaderSize = <span class="number">4</span> + <span class="number">2</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>日志类中的 <code>AddRecord</code> 函数每次调用会增加一条记录 Record，同时我们需要保证以后可以按顺序读取出每一条 Record。为了提升日志的读取速度速度，LevelDB 引入了 Block 的概念。在读写文件时会按照一个一个 Block 来读写，默认的 Block 大小为 <code>kBlockSize = 32KB</code>。而一条记录可能比 Block 还要长，所以还需要对过长的 Record 做合适的切分，切成片段 Fragment 后再放入 Block 中。Fragment 分为三种类型，分别是 <code>kFirstType</code>、<code>kMiddleType</code> 和 <code>kLastType</code>，参看下图：</p>
<p><a href="https://sf-zhou.github.io/images/0401845d2d596d0a577fe164ba72f66a.svg"><img src="https://sf-zhou.github.io/images/0401845d2d596d0a577fe164ba72f66a.svg" alt="img"></a>Log Format</p>
<p>继续看 <a href="https://github.com/google/leveldb/blob/master/db/log_writer.cc"><code>db/log_writer.cc</code></a> 的具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;db/log_writer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/env.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/coding.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/crc32c.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"><span class="keyword">namespace</span> log &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitTypeCrc</span><span class="params">(<span class="keyword">uint32_t</span>* type_crc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= kMaxRecordType; i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> t = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(i);</span><br><span class="line">    type_crc[i] = crc32c::<span class="built_in">Value</span>(&amp;t, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Writer::<span class="built_in">Writer</span>(WritableFile* dest) : <span class="built_in">dest_</span>(dest), <span class="built_in">block_offset_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">InitTypeCrc</span>(type_crc_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Writer::<span class="built_in">Writer</span>(WritableFile* dest, <span class="keyword">uint64_t</span> dest_length)</span><br><span class="line">    : <span class="built_in">dest_</span>(dest), <span class="built_in">block_offset_</span>(dest_length % kBlockSize) &#123;</span><br><span class="line">  <span class="built_in">InitTypeCrc</span>(type_crc_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Writer::~<span class="built_in">Writer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="keyword">const</span> <span class="keyword">char</span>* ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(length &lt;= <span class="number">0xffff</span>);  <span class="comment">// Must fit in two bytes</span></span><br><span class="line">  <span class="built_in">assert</span>(block_offset_ + kHeaderSize + length &lt;= kBlockSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Format the header</span></span><br><span class="line">  <span class="keyword">char</span> buf[kHeaderSize];</span><br><span class="line">  buf[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(length &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> crc = crc32c::<span class="built_in">Extend</span>(type_crc_[t], ptr, length);</span><br><span class="line">  crc = crc32c::<span class="built_in">Mask</span>(crc);  <span class="comment">// Adjust for storage</span></span><br><span class="line">  <span class="built_in">EncodeFixed32</span>(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  Status s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(buf, kHeaderSize));</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(ptr, length));</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = dest_-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block_offset_ += kHeaderSize + length;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace log</span></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p>构造时 <code>InitTypeCrc</code> 函数初始化了 <code>type_crc_</code> 数组，另外如果构造时有 <code>dest_length</code> 参数，则将 <code>block_offset_</code> 设为 <code>dest_length % kBlockSize</code>。至于函数 <code>EmitPhysicalRecord</code>，从函数名来看其作用是触发物理记录。该函数先构造了一个 Record Header <code>buf</code>，前 4 字节存储 CRC32 校验值，后面依次存储长度和 Record 类型。最终会将 Header、字节流写入文件并刷新，并且更新 <code>block_offset_</code>。最后来看下 <code>Log::Writer::AddRecord</code> 函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ptr = slice.<span class="built_in">data</span>();</span><br><span class="line">  <span class="keyword">size_t</span> left = slice.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fragment the record if necessary and emit it.  Note that if slice</span></span><br><span class="line">  <span class="comment">// is empty, we still want to iterate once to emit a single</span></span><br><span class="line">  <span class="comment">// zero-length record</span></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">bool</span> begin = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leftover = kBlockSize - block_offset_;</span><br><span class="line">    <span class="built_in">assert</span>(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;</span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        <span class="built_in"><span class="keyword">static_assert</span></span>(kHeaderSize == <span class="number">7</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(<span class="string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));</span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></span><br><span class="line">    <span class="built_in">assert</span>(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line"></span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> end = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;</span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123;</span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123;</span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    begin = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.<span class="built_in">ok</span>() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数首先会计算当前 Block 剩余空间大小 <code>leftover</code>，如果连 Header 都没法写进去，就直接填充 0 进去，后期读取时会直接过滤掉。而后计算可用的空间大小 <code>avail</code> 和当前写入的长度 <code>fragment_length</code> 以及对应的记录类型 <code>type</code>，最后调用 <code>EmitPhysicalRecord</code> 刷入文件。这种方式可以保证写 Record 时按照 <code>BlockSize</code> 对齐。</p>
<p>综上来看，写入时首先会把 <code>WriteBatch::rep_</code> 对齐地追加到日志中，写入时做了合适的切分，并且加入了 CRC 校验。有写肯定有读，当进行恢复操作时就会读取上述日志，<code>Log::Reader</code> 代码实现位于 <a href="https://github.com/google/leveldb/blob/master/db/log_reader.h"><code>db/log_reader.h</code></a> 和 <a href="https://github.com/google/leveldb/blob/master/db/log_reader.cc"><code>db/log_reader.cc</code></a>，读取的过程即为写入的逆过程</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码分析——4.内存数据库</title>
    <url>/2022/02/09/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%944.%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="四-内存数据库"><a href="#四-内存数据库" class="headerlink" title="四.内存数据库"></a>四.内存数据库</h2><p>本系列的上一篇介绍了 LevelDB 写操作中构造的 <code>WriteBatch</code>，以及写操作的第一步：追加日志。本篇将继续介绍写操作的第二步：插入内存数据库。</p>
<span id="more"></span>

<h3 id="3-内存数据库-MemTable"><a href="#3-内存数据库-MemTable" class="headerlink" title="3. 内存数据库 MemTable"></a>3. 内存数据库 MemTable</h3><p>MemTable 即为在内存中建立的 KV 数据库，基于跳表，定义于 <a href="https://github.com/google/leveldb/blob/master/db/memtable.h"><code>db/memtable.h</code></a>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;db/dbformat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;db/skiplist.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/arena.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InternalKeyComparator</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTableIterator</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// MemTables are reference counted.  The initial reference count</span></span><br><span class="line">  <span class="comment">// is zero and the caller must call Ref() at least once.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MemTable</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; comparator)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MemTable</span>(<span class="keyword">const</span> MemTable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MemTable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MemTable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Increase reference count.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">()</span> </span>&#123; ++refs_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop reference count.  Delete if no more references exist.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    --refs_;</span><br><span class="line">    <span class="built_in">assert</span>(refs_ &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (refs_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an estimate of the number of bytes of data in use by this</span></span><br><span class="line">  <span class="comment">// data structure. It is safe to call when MemTable is being modified.</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">ApproximateMemoryUsage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an iterator that yields the contents of the memtable.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The caller must ensure that the underlying MemTable remains live</span></span><br><span class="line">  <span class="comment">// while the returned iterator is live.  The keys returned by this</span></span><br><span class="line">  <span class="comment">// iterator are internal keys encoded by AppendInternalKey in the</span></span><br><span class="line">  <span class="comment">// db/format.&#123;h,cc&#125; module.</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add an entry into memtable that maps key to value at the</span></span><br><span class="line">  <span class="comment">// specified sequence number and with the specified type.</span></span><br><span class="line">  <span class="comment">// Typically value will be empty if type==kTypeDeletion.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(SequenceNumber seq, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line">  <span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line">  <span class="comment">// in *status and return true.</span></span><br><span class="line">  <span class="comment">// Else, return false.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, std::string* value, Status* s)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MemTableIterator</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MemTableBackwardIterator</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">KeyComparator</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> InternalKeyComparator comparator;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">KeyComparator</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; c)</span> : comparator(c) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a, <span class="keyword">const</span> <span class="keyword">char</span>* b)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> SkipList&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, KeyComparator&gt; Table;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">MemTable</span>();  <span class="comment">// Private since only Unref() should be used to delete it</span></span><br><span class="line"></span><br><span class="line">  KeyComparator comparator_;</span><br><span class="line">  <span class="keyword">int</span> refs_;</span><br><span class="line">  Arena arena_;</span><br><span class="line">  Table table_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p>MemTable 包含比较器 <code>comparator_</code> 、引用计数 <code>refs_</code>、内存池 <code>arena_</code> 和跳表 <code>table_</code> 四个成员变量。代码中首先前置声明了 <code>InternalKeyComparator</code> 类，该类的对象是 MemTable 的构造函数参数。该类定义为 <code>db/dbformat.h</code> 中，将在下文中介绍。随后 MemTable 禁止了拷贝构造和赋值操作符，不允许拷贝操作，这应该是内存池的副作用。MemTable 使用引用计数管理自己的生命周期，甚至其析构函数都是私有的。而接口 <code>ApproximateMemoryUsage</code> 实际上返回的是内存池中的内存使用量。接口方面提供了读写接口和迭代器接口。内部定义了结构体 <code>KeyComparator</code>，对 <code>InternalKeyComparator</code> 进行了封装。为了弄清楚 <code>InternalKeyComparator</code> 到底是什么，我们先转到 <a href="https://github.com/google/leveldb/blob/master/db/dbformat.h"><code>db/dbformat.h</code></a> 查看其定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ValueType</span> &#123;</span> kTypeDeletion = <span class="number">0x0</span>, kTypeValue = <span class="number">0x1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> ValueType kValueTypeForSeek = kTypeValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> SequenceNumber;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> SequenceNumber kMaxSequenceNumber = ((<span class="number">0x1</span>ull &lt;&lt; <span class="number">56</span>) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ParsedInternalKey</span> &#123;</span></span><br><span class="line">  Slice user_key;</span><br><span class="line">  SequenceNumber sequence;</span><br><span class="line">  ValueType type;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ParsedInternalKey</span>() &#123;&#125;  <span class="comment">// Intentionally left uninitialized (for speed)</span></span><br><span class="line">  <span class="built_in">ParsedInternalKey</span>(<span class="keyword">const</span> Slice&amp; u, <span class="keyword">const</span> SequenceNumber&amp; seq, ValueType t)</span><br><span class="line">      : <span class="built_in">user_key</span>(u), <span class="built_in">sequence</span>(seq), <span class="built_in">type</span>(t) &#123;&#125;</span><br><span class="line">  <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the length of the encoding of &quot;key&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">InternalKeyEncodingLength</span><span class="params">(<span class="keyword">const</span> ParsedInternalKey&amp; key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key.user_key.<span class="built_in">size</span>() + <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">PackSequenceAndType</span><span class="params">(<span class="keyword">uint64_t</span> seq, ValueType t)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(seq &lt;= kMaxSequenceNumber);</span><br><span class="line">  <span class="built_in">assert</span>(t &lt;= kValueTypeForSeek);</span><br><span class="line">  <span class="keyword">return</span> (seq &lt;&lt; <span class="number">8</span>) | t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AppendInternalKey</span><span class="params">(std::string* result, <span class="keyword">const</span> ParsedInternalKey&amp; key)</span> </span>&#123;</span><br><span class="line">  result-&gt;<span class="built_in">append</span>(key.user_key.<span class="built_in">data</span>(), key.user_key.<span class="built_in">size</span>());</span><br><span class="line">  <span class="built_in">PutFixed64</span>(result, <span class="built_in">PackSequenceAndType</span>(key.sequence, key.type));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ParseInternalKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; internal_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                             ParsedInternalKey* result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> n = internal_key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">8</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span> num = <span class="built_in">DecodeFixed64</span>(internal_key.<span class="built_in">data</span>() + n - <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">uint8_t</span> c = num &amp; <span class="number">0xff</span>;</span><br><span class="line">  result-&gt;sequence = num &gt;&gt; <span class="number">8</span>;</span><br><span class="line">  result-&gt;type = <span class="keyword">static_cast</span>&lt;ValueType&gt;(c);</span><br><span class="line">  result-&gt;user_key = <span class="built_in">Slice</span>(internal_key.<span class="built_in">data</span>(), n - <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">return</span> (c &lt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(kTypeValue));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Slice <span class="title">ExtractUserKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; internal_key)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(internal_key.<span class="built_in">size</span>() &gt;= <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Slice</span>(internal_key.<span class="built_in">data</span>(), internal_key.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便阅读这里对函数进行了重排。</p>
<p>首先定义了两种值类型 <code>kTypeDeletion</code> 和 <code>kTypeValue</code>，注意 <code>kTypeDeletion</code> 值较小。然后定义了 <code>SequenceNumber</code> 为 64 位无符号数，并且定义了其最大值。然后是 <code>ParsedInternalKey</code> 结构体的定义，其内部包括 <code>user_key</code>、<code>sequence</code> 和 <code>type</code>。根据类的名字就可以猜到一点了，Internal Key 应该是对 User Key 的封装，在其基础上加入了序列号 <code>sequence</code> 和值类型 <code>type</code>。函数 <code>PackSequenceAndType</code> 中可以发现， <code>sequence</code> 占用 56bit，剩下 8bit 给 <code>type</code>，一共组成 64 位无符号数，下文称之为合成序列号。所以 <code>InternalKeyEncodingLength</code> 计算的长度是 User Key 的长度加 8。</p>
<p>函数 <code>AppendInternalKey</code> 可以将 <code>ParsedInternalKey</code> 转为字符串，先将 User Key 编码进去，再将 64 位合成序列号加入，对应的解析函数 <code>ParseInternalKey</code> 为逆过程。</p>
<p>继续：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InternalKeyComparator</span> :</span> <span class="keyword">public</span> Comparator &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> Comparator* user_comparator_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">InternalKeyComparator</span><span class="params">(<span class="keyword">const</span> Comparator* c)</span> : user_comparator_(c) &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; a, <span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindShortestSeparator</span><span class="params">(std::string* start,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> Slice&amp; limit)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindShortSuccessor</span><span class="params">(std::string* key)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> Comparator* <span class="title">user_comparator</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> user_comparator_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> InternalKey&amp; a, <span class="keyword">const</span> InternalKey&amp; b)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">InternalKeyComparator::Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;leveldb.InternalKeyComparator&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InternalKeyComparator::Compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; akey, <span class="keyword">const</span> Slice&amp; bkey)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Order by:</span></span><br><span class="line">  <span class="comment">//    increasing user key (according to user-supplied comparator)</span></span><br><span class="line">  <span class="comment">//    decreasing sequence number</span></span><br><span class="line">  <span class="comment">//    decreasing type (though sequence# should be enough to disambiguate)</span></span><br><span class="line">  <span class="keyword">int</span> r = user_comparator_-&gt;<span class="built_in">Compare</span>(<span class="built_in">ExtractUserKey</span>(akey), <span class="built_in">ExtractUserKey</span>(bkey));</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> anum = <span class="built_in">DecodeFixed64</span>(akey.<span class="built_in">data</span>() + akey.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> bnum = <span class="built_in">DecodeFixed64</span>(bkey.<span class="built_in">data</span>() + bkey.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (anum &gt; bnum) &#123;</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (anum &lt; bnum) &#123;</span><br><span class="line">      r = +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InternalKeyComparator</code> 继承于 LevelDB 中定义的比较器 <code>Comparator</code>，其源码位于 <a href="https://github.com/google/leveldb/blob/master/include/leveldb/comparator.h"><code>include/leveldb/comparator.h</code> </a>，有兴趣自己阅读。其核心函数即为 <code>Compare</code>，比较两个 <code>Key</code> 的大小。<code>InternalKeyComparator</code> 对 <code>user_comparator_</code> 进行了封装，当比较 <code>InternalKey</code> 时，首先使用 <code>user_comparator_</code> 对 User Key 进行比较，如果相等，则抽取合成序列号进行比较，序列号大的反而在顺序上更小，即降序排列。继续看 <code>InternalKey</code> 的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InternalKey</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::string rep_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">InternalKey</span>() &#123;&#125;  <span class="comment">// Leave rep_ as empty to indicate it is invalid</span></span><br><span class="line">  <span class="built_in">InternalKey</span>(<span class="keyword">const</span> Slice&amp; user_key, SequenceNumber s, ValueType t) &#123;</span><br><span class="line">    <span class="built_in">AppendInternalKey</span>(&amp;rep_, <span class="built_in">ParsedInternalKey</span>(user_key, s, t));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">DecodeFrom</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123;</span><br><span class="line">    rep_.<span class="built_in">assign</span>(s.<span class="built_in">data</span>(), s.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> !rep_.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">Encode</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!rep_.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">return</span> rep_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">user_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ExtractUserKey</span>(rep_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetFrom</span><span class="params">(<span class="keyword">const</span> ParsedInternalKey&amp; p)</span> </span>&#123;</span><br><span class="line">    rep_.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">AppendInternalKey</span>(&amp;rep_, p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123; rep_.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">InternalKeyComparator::Compare</span><span class="params">(<span class="keyword">const</span> InternalKey&amp; a,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">const</span> InternalKey&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Compare</span>(a.<span class="built_in">Encode</span>(), b.<span class="built_in">Encode</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InternalKey</code> 存储的信息和 <code>ParseInternalKey</code> 一致，只是存储形式不同，前者直接使用字符串 <code>rep_</code> 存储 User Key 和合成序列号，对应的比较函数则直接使用 <code>InternalKeyComparator</code> 对 <code>rep_</code> 进行解析后的比较。该文件中还有 <code>InternalFilterPolicy</code> 的定义，同样是从 Internal Key 解析出 User Key 进行操作。继续看 <code>LookupKey</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A helper class useful for DBImpl::Get()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookupKey</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize *this for looking up user_key at a snapshot with</span></span><br><span class="line">  <span class="comment">// the specified sequence number.</span></span><br><span class="line">  <span class="built_in">LookupKey</span>(<span class="keyword">const</span> Slice&amp; user_key, SequenceNumber sequence);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LookupKey</span>(<span class="keyword">const</span> LookupKey&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  LookupKey&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> LookupKey&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">LookupKey</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a key suitable for lookup in a MemTable.</span></span><br><span class="line">  <span class="function">Slice <span class="title">memtable_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Slice</span>(start_, end_ - start_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an internal key (suitable for passing to an internal iterator)</span></span><br><span class="line">  <span class="function">Slice <span class="title">internal_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Slice</span>(kstart_, end_ - kstart_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the user key</span></span><br><span class="line">  <span class="function">Slice <span class="title">user_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Slice</span>(kstart_, end_ - kstart_ - <span class="number">8</span>); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// We construct a char array of the form:</span></span><br><span class="line">  <span class="comment">//    klength  varint32               &lt;-- start_</span></span><br><span class="line">  <span class="comment">//    userkey  char[klength]          &lt;-- kstart_</span></span><br><span class="line">  <span class="comment">//    tag      uint64</span></span><br><span class="line">  <span class="comment">//                                    &lt;-- end_</span></span><br><span class="line">  <span class="comment">// The array is a suitable MemTable key.</span></span><br><span class="line">  <span class="comment">// The suffix starting with &quot;userkey&quot; can be used as an InternalKey.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* start_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* kstart_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* end_;</span><br><span class="line">  <span class="keyword">char</span> space_[<span class="number">200</span>];  <span class="comment">// Avoid allocation for short keys</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LookupKey::<span class="built_in">LookupKey</span>(<span class="keyword">const</span> Slice&amp; user_key, SequenceNumber s) &#123;</span><br><span class="line">  <span class="keyword">size_t</span> usize = user_key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">size_t</span> needed = usize + <span class="number">13</span>;  <span class="comment">// A conservative estimate</span></span><br><span class="line">  <span class="keyword">char</span>* dst;</span><br><span class="line">  <span class="keyword">if</span> (needed &lt;= <span class="built_in"><span class="keyword">sizeof</span></span>(space_)) &#123;</span><br><span class="line">    dst = space_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dst = <span class="keyword">new</span> <span class="keyword">char</span>[needed];</span><br><span class="line">  &#125;</span><br><span class="line">  start_ = dst;</span><br><span class="line">  dst = <span class="built_in">EncodeVarint32</span>(dst, usize + <span class="number">8</span>);</span><br><span class="line">  kstart_ = dst;</span><br><span class="line">  <span class="built_in">memcpy</span>(dst, user_key.<span class="built_in">data</span>(), usize);</span><br><span class="line">  dst += usize;</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(dst, <span class="built_in">PackSequenceAndType</span>(s, kValueTypeForSeek));</span><br><span class="line">  dst += <span class="number">8</span>;</span><br><span class="line">  end_ = dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到内存数据库的定义中，<code>KeyComparator</code> 对 <code>InternalKeyComparator</code> 又进行了一次封装，来看下其具体函数定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Slice <span class="title">GetLengthPrefixedSlice</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> len;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* p = data;</span><br><span class="line">  p = <span class="built_in">GetVarint32Ptr</span>(p, p + <span class="number">5</span>, &amp;len);  <span class="comment">// +5: we assume &quot;p&quot; is not corrupted</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Slice</span>(p, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MemTable::KeyComparator::<span class="built_in"><span class="keyword">operator</span></span>()(<span class="keyword">const</span> <span class="keyword">char</span>* aptr,</span><br><span class="line">                                        <span class="keyword">const</span> <span class="keyword">char</span>* bptr) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// Internal keys are encoded as length-prefixed strings.</span></span><br><span class="line">  Slice a = <span class="built_in">GetLengthPrefixedSlice</span>(aptr);</span><br><span class="line">  Slice b = <span class="built_in">GetLengthPrefixedSlice</span>(bptr);</span><br><span class="line">  <span class="keyword">return</span> comparator.<span class="built_in">Compare</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>comparator</code> 自然是 <code>InternalKeyComparator</code>，从 <code>GetLengthPrefixedSlice</code> 推测该函数的参数为 MemTable Key。继续看 <code>MemTable::Add</code> 和 <code>MemTable::Get</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemTable::Add</span><span class="params">(SequenceNumber s, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></span><br><span class="line">  <span class="keyword">size_t</span> key_size = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">size_t</span> val_size = value.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">size_t</span> internal_key_size = key_size + <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> encoded_len = <span class="built_in">VarintLength</span>(internal_key_size) +</span><br><span class="line">                             internal_key_size + <span class="built_in">VarintLength</span>(val_size) +</span><br><span class="line">                             val_size;</span><br><span class="line">  <span class="keyword">char</span>* buf = arena_.<span class="built_in">Allocate</span>(encoded_len);</span><br><span class="line">  <span class="keyword">char</span>* p = <span class="built_in">EncodeVarint32</span>(buf, internal_key_size);</span><br><span class="line">  <span class="built_in">memcpy</span>(p, key.<span class="built_in">data</span>(), key_size);</span><br><span class="line">  p += key_size;</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">  p += <span class="number">8</span>;</span><br><span class="line">  p = <span class="built_in">EncodeVarint32</span>(p, val_size);</span><br><span class="line">  <span class="built_in">memcpy</span>(p, value.<span class="built_in">data</span>(), val_size);</span><br><span class="line">  <span class="built_in">assert</span>(p + val_size == buf + encoded_len);</span><br><span class="line">  table_.<span class="built_in">Insert</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MemTable::Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, std::string* value, Status* s)</span> </span>&#123;</span><br><span class="line">  Slice memkey = key.<span class="built_in">memtable_key</span>();</span><br><span class="line">  <span class="function">Table::Iterator <span class="title">iter</span><span class="params">(&amp;table_)</span></span>;</span><br><span class="line">  iter.<span class="built_in">Seek</span>(memkey.<span class="built_in">data</span>());</span><br><span class="line">  <span class="keyword">if</span> (iter.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="comment">// entry format is:</span></span><br><span class="line">    <span class="comment">//    klength  varint32</span></span><br><span class="line">    <span class="comment">//    userkey  char[klength]</span></span><br><span class="line">    <span class="comment">//    tag      uint64</span></span><br><span class="line">    <span class="comment">//    vlength  varint32</span></span><br><span class="line">    <span class="comment">//    value    char[vlength]</span></span><br><span class="line">    <span class="comment">// Check that it belongs to same user key.  We do not check the</span></span><br><span class="line">    <span class="comment">// sequence number since the Seek() call above should have skipped</span></span><br><span class="line">    <span class="comment">// all entries with overly large sequence numbers.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* entry = iter.<span class="built_in">key</span>();</span><br><span class="line">    <span class="keyword">uint32_t</span> key_length;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr = <span class="built_in">GetVarint32Ptr</span>(entry, entry + <span class="number">5</span>, &amp;key_length);</span><br><span class="line">    <span class="keyword">if</span> (comparator_.comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Compare</span>(</span><br><span class="line">            <span class="built_in">Slice</span>(key_ptr, key_length - <span class="number">8</span>), key.<span class="built_in">user_key</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Correct user key</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> tag = <span class="built_in">DecodeFixed64</span>(key_ptr + key_length - <span class="number">8</span>);</span><br><span class="line">      <span class="built_in"><span class="keyword">switch</span></span> (<span class="keyword">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>)) &#123;</span><br><span class="line">        <span class="keyword">case</span> kTypeValue: &#123;</span><br><span class="line">          Slice v = <span class="built_in">GetLengthPrefixedSlice</span>(key_ptr + key_length);</span><br><span class="line">          value-&gt;<span class="built_in">assign</span>(v.<span class="built_in">data</span>(), v.<span class="built_in">size</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">          *s = Status::<span class="built_in">NotFound</span>(<span class="built_in">Slice</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MemTable::Add</code> 的注释中写明了条目的格式，除了图中 <code>Key</code> 部分的存储外，条目还包括 <code>Value</code> 的存储，打包好后插入跳表中。<code>MemTable::Get</code> 中则根据 MemTable Key 查找对应的条目，查到后使用 <code>user_comparator</code> 进一步比较两者的 User Key 是否一致，如果完全一致并且值类型不是删除，就把条目中的 <code>Value</code> 读出来放到结果中。最后看下迭代器的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">EncodeKey</span><span class="params">(std::string* scratch, <span class="keyword">const</span> Slice&amp; target)</span> </span>&#123;</span><br><span class="line">  scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">PutVarint32</span>(scratch, target.<span class="built_in">size</span>());</span><br><span class="line">  scratch-&gt;<span class="built_in">append</span>(target.<span class="built_in">data</span>(), target.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">return</span> scratch-&gt;<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTableIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MemTableIterator</span><span class="params">(MemTable::Table* table)</span> : iter_(table) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MemTableIterator</span>(<span class="keyword">const</span> MemTableIterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MemTableIterator&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MemTableIterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">MemTableIterator</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> iter_.<span class="built_in">Valid</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; k)</span> <span class="keyword">override</span> </span>&#123; iter_.<span class="built_in">Seek</span>(<span class="built_in">EncodeKey</span>(&amp;tmp_, k)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_.<span class="built_in">SeekToFirst</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_.<span class="built_in">SeekToLast</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_.<span class="built_in">Next</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_.<span class="built_in">Prev</span>(); &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetLengthPrefixedSlice</span>(iter_.<span class="built_in">key</span>()); &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    Slice key_slice = <span class="built_in">GetLengthPrefixedSlice</span>(iter_.<span class="built_in">key</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetLengthPrefixedSlice</span>(key_slice.<span class="built_in">data</span>() + key_slice.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> Status::<span class="built_in">OK</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  MemTable::Table::Iterator iter_;</span><br><span class="line">  std::string tmp_;  <span class="comment">// For passing to EncodeKey</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">MemTable::NewIterator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MemTableIterator</span>(&amp;table_); &#125;</span><br></pre></td></tr></table></figure>

<p><code>MemTableIterator</code> 对跳表的迭代器进行了一层封装，跳表的条目中编码了 <code>Key</code> 和 <code>Value</code>，<code>MemTableIterator</code> 中对其进行了对应的解析。至此，内存数据库的代码就分析完了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上一篇和本篇分析了 LevelDB 写操作的具体过程，分析了 <code>WriteBatch</code>、<code>Log</code> 和 <code>MemTable</code> 的代码，理解了高性能写操作的原理。不过内存数据库的大小毕竟是有限的，总会需要把内存中的数据持久化到硬盘中，并且还需要提供高速的硬盘数据查询操作，这些又是怎样实现的呢？且听下回分解！</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码分析——9.读写完整流程</title>
    <url>/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%949.%E8%AF%BB%E5%86%99%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="九-读写完整流程"><a href="#九-读写完整流程" class="headerlink" title="九.读写完整流程"></a>九.读写完整流程</h2><p>本系列之前的数篇博文从面向对象的角度分析了 LevelDB 中的核心组件，理解了每个类的作用。本篇将从面向过程的角度，分析 LevelDB 创建、打开和读写的完整流程。</p>
<h3 id="1-新建数据库并写入"><a href="#1-新建数据库并写入" class="headerlink" title="1. 新建数据库并写入"></a>1. 新建数据库并写入</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  leveldb::DB* db;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    leveldb::Options options;</span><br><span class="line">    options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">    options.compression = leveldb::kNoCompression;</span><br><span class="line">    leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;testdb&quot;</span>, &amp;db);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    leveldb::WriteOptions options;</span><br><span class="line">    leveldb::Status status = db-&gt;<span class="built_in">Put</span>(options, <span class="string">&quot;[Key]&quot;</span>, <span class="string">&quot;[Value]&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保当前路径下没有 <code>testdb</code> 目录，然后执行上方的代码。可以在写入前加入 <code>getchar()</code> 中断以观察中间的状态，测试得到的中间状态如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ ls -l</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r--  1 pxf  staff     0B Sep  7 10:02 000003.log</span><br><span class="line">-rw-r--r--  1 pxf  staff    16B Sep  7 10:02 CURRENT</span><br><span class="line">-rw-r--r--  1 pxf  staff     0B Sep  7 10:02 LOCK</span><br><span class="line">-rw-r--r--  1 pxf  staff    56B Sep  7 10:02 LOG</span><br><span class="line">-rw-r--r--  1 pxf  staff    50B Sep  7 10:02 MANIFEST-000002</span><br></pre></td></tr></table></figure>

<p>待写入完成后，文件 <code>000003.log</code> 的大小变为 34，其余大小不变。</p>
<p>接下来沿着代码一步一步分析，这里推荐使用 VS Code 查看函数实现。首先来看 <code>leveldb::DB::Open</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DB::Open</span><span class="params">(<span class="keyword">const</span> Options&amp; options, <span class="keyword">const</span> std::string&amp; dbname, DB** dbptr)</span> </span>&#123;</span><br><span class="line">  *dbptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  DBImpl* impl = <span class="keyword">new</span> <span class="built_in">DBImpl</span>(options, dbname);</span><br><span class="line">  impl-&gt;mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  <span class="comment">// Recover handles create_if_missing, error_if_exists</span></span><br><span class="line">  <span class="keyword">bool</span> save_manifest = <span class="literal">false</span>;</span><br><span class="line">  Status s = impl-&gt;<span class="built_in">Recover</span>(&amp;edit, &amp;save_manifest);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; impl-&gt;mem_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Create new log and a corresponding memtable.</span></span><br><span class="line">    <span class="keyword">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">    WritableFile* lfile;</span><br><span class="line">    s = options.env-&gt;<span class="built_in">NewWritableFile</span>(<span class="built_in">LogFileName</span>(dbname, new_log_number),</span><br><span class="line">                                     &amp;lfile);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      edit.<span class="built_in">SetLogNumber</span>(new_log_number);</span><br><span class="line">      impl-&gt;logfile_ = lfile;</span><br><span class="line">      impl-&gt;logfile_number_ = new_log_number;</span><br><span class="line">      impl-&gt;log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(lfile);</span><br><span class="line">      impl-&gt;mem_ = <span class="keyword">new</span> <span class="built_in">MemTable</span>(impl-&gt;internal_comparator_);</span><br><span class="line">      impl-&gt;mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; save_manifest) &#123;</span><br><span class="line">    edit.<span class="built_in">SetPrevLogNumber</span>(<span class="number">0</span>);  <span class="comment">// No older logs needed after recovery.</span></span><br><span class="line">    edit.<span class="built_in">SetLogNumber</span>(impl-&gt;logfile_number_);</span><br><span class="line">    s = impl-&gt;versions_-&gt;<span class="built_in">LogAndApply</span>(&amp;edit, &amp;impl-&gt;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    impl-&gt;<span class="built_in">DeleteObsoleteFiles</span>();</span><br><span class="line">    impl-&gt;<span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  impl-&gt;mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(impl-&gt;mem_ != <span class="literal">nullptr</span>);</span><br><span class="line">    *dbptr = impl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> impl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先给输出参数 <code>*dbptr</code> 赋空指针，然后 new 一个 <code>DBImpl</code> 对象。<code>DBImpl</code> 的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DBImpl::<span class="built_in">DBImpl</span>(<span class="keyword">const</span> Options&amp; raw_options, <span class="keyword">const</span> std::string&amp; dbname)</span><br><span class="line">    : <span class="built_in">env_</span>(raw_options.env),</span><br><span class="line">      <span class="built_in">internal_comparator_</span>(raw_options.comparator),</span><br><span class="line">      <span class="built_in">internal_filter_policy_</span>(raw_options.filter_policy),</span><br><span class="line">      <span class="built_in">options_</span>(<span class="built_in">SanitizeOptions</span>(dbname, &amp;internal_comparator_,</span><br><span class="line">                               &amp;internal_filter_policy_, raw_options)),</span><br><span class="line">      <span class="built_in">owns_info_log_</span>(options_.info_log != raw_options.info_log),</span><br><span class="line">      <span class="built_in">owns_cache_</span>(options_.block_cache != raw_options.block_cache),</span><br><span class="line">      <span class="built_in">dbname_</span>(dbname),</span><br><span class="line">      <span class="built_in">table_cache_</span>(<span class="keyword">new</span> <span class="built_in">TableCache</span>(dbname_, options_, <span class="built_in">TableCacheSize</span>(options_))),</span><br><span class="line">      <span class="built_in">db_lock_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">shutting_down_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">background_work_finished_signal_</span>(&amp;mutex_),</span><br><span class="line">      <span class="built_in">mem_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">imm_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">has_imm_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">logfile_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">logfile_number_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">log_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">seed_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">tmp_batch_</span>(<span class="keyword">new</span> WriteBatch),</span><br><span class="line">      <span class="built_in">background_compaction_scheduled_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">manual_compaction_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">versions_</span>(<span class="keyword">new</span> <span class="built_in">VersionSet</span>(dbname_, &amp;options_, table_cache_,</span><br><span class="line">                               &amp;internal_comparator_)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>都是成员变量的初始化，大部分成员置为 0。值得关注的 <code>SanitizeOptions</code> 实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ClipToRange</span><span class="params">(T* ptr, V minvalue, V maxvalue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;V&gt;(*ptr) &gt; maxvalue) *ptr = maxvalue;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;V&gt;(*ptr) &lt; minvalue) *ptr = minvalue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Options <span class="title">SanitizeOptions</span><span class="params">(<span class="keyword">const</span> std::string&amp; dbname,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> InternalKeyComparator* icmp,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> InternalFilterPolicy* ipolicy,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">const</span> Options&amp; src)</span> </span>&#123;</span><br><span class="line">  Options result = src;</span><br><span class="line">  result.comparator = icmp;</span><br><span class="line">  result.filter_policy = (src.filter_policy != <span class="literal">nullptr</span>) ? ipolicy : <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">ClipToRange</span>(&amp;result.max_open_files, <span class="number">64</span> + kNumNonTableCacheFiles, <span class="number">50000</span>);</span><br><span class="line">  <span class="built_in">ClipToRange</span>(&amp;result.write_buffer_size, <span class="number">64</span> &lt;&lt; <span class="number">10</span>, <span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">ClipToRange</span>(&amp;result.max_file_size, <span class="number">1</span> &lt;&lt; <span class="number">20</span>, <span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">ClipToRange</span>(&amp;result.block_size, <span class="number">1</span> &lt;&lt; <span class="number">10</span>, <span class="number">4</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">if</span> (result.info_log == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Open a log file in the same directory as the db</span></span><br><span class="line">    src.env-&gt;<span class="built_in">CreateDir</span>(dbname);  <span class="comment">// In case it does not exist</span></span><br><span class="line">    src.env-&gt;<span class="built_in">RenameFile</span>(<span class="built_in">InfoLogFileName</span>(dbname), <span class="built_in">OldInfoLogFileName</span>(dbname));</span><br><span class="line">    Status s = src.env-&gt;<span class="built_in">NewLogger</span>(<span class="built_in">InfoLogFileName</span>(dbname), &amp;result.info_log);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="comment">// No place suitable for logging</span></span><br><span class="line">      result.info_log = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result.block_cache == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    result.block_cache = <span class="built_in">NewLRUCache</span>(<span class="number">8</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SanitizeOptions</code> 函数将原 <code>src</code> 中的属性进行了安全裁剪，并且创建了 <code>dbname</code> 目录、将原 Info Log 文件重命名并创建了新的 Info Log 文件，也就是 <code>testdb/LOG</code> 文件。最后按需创建了 block cache 并返回作为 <code>DBImpl</code> 的 <code>options_</code>。 <code>DBImpl</code> 的构造函数还为 <code>table_cache_</code>、<code>tmp_batch_</code> 和 <code>version_</code> 创建了新对象。</p>
<p>回到 <code>leveldb::DB::Open</code>，创建 <code>DBImpl</code> 后上锁并执行 <code>impl-&gt;Recover</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Recover</span><span class="params">(VersionEdit* edit, <span class="keyword">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ignore error from CreateDir since the creation of the DB is</span></span><br><span class="line">  <span class="comment">// committed only when the descriptor is created, and this directory</span></span><br><span class="line">  <span class="comment">// may already exist from a previous failed creation attempt.</span></span><br><span class="line">  env_-&gt;<span class="built_in">CreateDir</span>(dbname_);</span><br><span class="line">  <span class="built_in">assert</span>(db_lock_ == <span class="literal">nullptr</span>);</span><br><span class="line">  Status s = env_-&gt;<span class="built_in">LockFile</span>(<span class="built_in">LockFileName</span>(dbname_), &amp;db_lock_);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!env_-&gt;<span class="built_in">FileExists</span>(<span class="built_in">CurrentFileName</span>(dbname_))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options_.create_if_missing) &#123;</span><br><span class="line">      s = <span class="built_in">NewDB</span>();</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">InvalidArgument</span>(</span><br><span class="line">          dbname_, <span class="string">&quot;does not exist (create_if_missing is false)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (options_.error_if_exists) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">InvalidArgument</span>(dbname_,</span><br><span class="line">                                     <span class="string">&quot;exists (error_if_exists is true)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  s = versions_-&gt;<span class="built_in">Recover</span>(save_manifest);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试创建 dbname 目录且忽略错误，启用文件锁 <code>testdb/LOCK</code> 以阻止其他进程操作当前数据库。由于当前没有 CURRENT 文件，并且我们开启了 <code>options.create_if_missing</code>，这里会继续调用 <code>NewDB</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::NewDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  VersionEdit new_db;</span><br><span class="line">  new_db.<span class="built_in">SetComparatorName</span>(<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Name</span>());</span><br><span class="line">  new_db.<span class="built_in">SetLogNumber</span>(<span class="number">0</span>);</span><br><span class="line">  new_db.<span class="built_in">SetNextFile</span>(<span class="number">2</span>);</span><br><span class="line">  new_db.<span class="built_in">SetLastSequence</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> std::string manifest = <span class="built_in">DescriptorFileName</span>(dbname_, <span class="number">1</span>);</span><br><span class="line">  WritableFile* file;</span><br><span class="line">  Status s = env_-&gt;<span class="built_in">NewWritableFile</span>(manifest, &amp;file);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">log::Writer <span class="title">log</span><span class="params">(file)</span></span>;</span><br><span class="line">    std::string record;</span><br><span class="line">    new_db.<span class="built_in">EncodeTo</span>(&amp;record);</span><br><span class="line">    s = log.<span class="built_in">AddRecord</span>(record);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = file-&gt;<span class="built_in">Close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> file;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Make &quot;CURRENT&quot; file that points to the new manifest file.</span></span><br><span class="line">    s = <span class="built_in">SetCurrentFile</span>(env_, dbname_, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    env_-&gt;<span class="built_in">DeleteFile</span>(manifest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NewDB</code> 中创建了一个新的 <code>VersionEdit</code> 对象，将日志编号设为 0，MANIFEST 编号设为 1，NextFile 编号自然是 2 了。而后将 <code>VersionEdit</code> 对象转为日志 Record 写入 MANIFEST 文件中，并将 CURRENT 指向该 MANIFEST。</p>
<p>ちょっと待って（桥豆麻袋），先前观察到的 MANIFEST 文件名为 MANIFEST-000002，和这里分析的编号为 1 并不相符，应该是中间发生了什么。回到 <code>DBImpl::Recover</code> 继续看，接下来将会执行 <code>versions_-&gt;Recover</code>，该函数在上一篇文章中有贴出源码，可以翻回去看一下这里不贴了。简述其过程：根据 CURRENT 文件，读取指向的 MANIFEST 文件中的 VersionEdit 记录，并合成 Version。贴一部分与编号相关的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Version* v = <span class="keyword">new</span> <span class="built_in">Version</span>(<span class="keyword">this</span>);</span><br><span class="line">builder.<span class="built_in">SaveTo</span>(v);</span><br><span class="line"><span class="comment">// Install recovered version</span></span><br><span class="line"><span class="built_in">Finalize</span>(v);</span><br><span class="line"><span class="built_in">AppendVersion</span>(v);</span><br><span class="line">manifest_file_number_ = next_file;</span><br><span class="line">next_file_number_ = next_file + <span class="number">1</span>;</span><br><span class="line">last_sequence_ = last_sequence;</span><br><span class="line">log_number_ = log_number;</span><br><span class="line">prev_log_number_ = prev_log_number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See if we can reuse the existing MANIFEST file.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ReuseManifest</span>(dscname, current)) &#123;</span><br><span class="line">  <span class="comment">// No need to save new manifest</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  *save_manifest = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里将 <code>manifest_file_number_</code> 设为了 <code>next_file</code>，也就是 2。<code>Options::reuse_logs</code> 默认为关闭状态，故这里会将 <code>save_manifest</code> 设为 <code>true</code>，所以后面保存 MANIFEST 时编号就是 2 了。</p>
<p>回到 <code>DBImpl::Recover</code>，当 <code>versions_-&gt;Recover</code> 执行完成后，会读取当前存在的日志文件。而新数据库并没有日志，中间过程就跳过、直接返回了，进而回到 <code>leveldb::DB::Open</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; impl-&gt;mem_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// Create new log and a corresponding memtable.</span></span><br><span class="line">  <span class="keyword">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">  WritableFile* lfile;</span><br><span class="line">  s = options.env-&gt;<span class="built_in">NewWritableFile</span>(<span class="built_in">LogFileName</span>(dbname, new_log_number),</span><br><span class="line">                                   &amp;lfile);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    edit.<span class="built_in">SetLogNumber</span>(new_log_number);</span><br><span class="line">    impl-&gt;logfile_ = lfile;</span><br><span class="line">    impl-&gt;logfile_number_ = new_log_number;</span><br><span class="line">    impl-&gt;log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(lfile);</span><br><span class="line">    impl-&gt;mem_ = <span class="keyword">new</span> <span class="built_in">MemTable</span>(impl-&gt;internal_comparator_);</span><br><span class="line">    impl-&gt;mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; save_manifest) &#123;</span><br><span class="line">  edit.<span class="built_in">SetPrevLogNumber</span>(<span class="number">0</span>);  <span class="comment">// No older logs needed after recovery.</span></span><br><span class="line">  edit.<span class="built_in">SetLogNumber</span>(impl-&gt;logfile_number_);</span><br><span class="line">  s = impl-&gt;versions_-&gt;<span class="built_in">LogAndApply</span>(&amp;edit, &amp;impl-&gt;mutex_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>impl-&gt;mem_</code> 依然保持为空，故申请新的日志编号 3，创建日志文件和对应的内存数据库，也就是 <code>testdb/000003.log</code>。<code>save_manifest</code> 为真，则调用 <code>version_-&gt;LogAndApply</code> 将当前版本 <code>edit</code> 写入文件，也就是最终看到的 <code>testdb/MANIFEST-000002</code>。这里硬核一点，直接看下 MANIFEST 文件的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ hexdump MANIFEST-000002</span><br><span class="line">0000000 56 f9 b8 f8 1c 00 01 01 1a 6c 65 76 65 6c 64 62</span><br><span class="line">0000010 2e 42 79 74 65 77 69 73 65 43 6f 6d 70 61 72 61</span><br><span class="line">0000020 74 6f 72 a4 9c 8b be 08 00 01 02 03 09 00 03 04</span><br><span class="line">0000030 04 00</span><br></pre></td></tr></table></figure>

<p><code>version_-&gt;LogAndApply</code> 创建 MANIFEST 文件后，会先执行 <code>VersionSet::WriteSnapshot</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::WriteSnapshot</span><span class="params">(log::Writer* log)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Break up into multiple records to reduce memory usage on recovery?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save metadata</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  edit.<span class="built_in">SetComparatorName</span>(icmp_.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Name</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!compact_pointer_[level].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      InternalKey key;</span><br><span class="line">      key.<span class="built_in">DecodeFrom</span>(compact_pointer_[level]);</span><br><span class="line">      edit.<span class="built_in">SetCompactPointer</span>(level, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; files = current_-&gt;files_[level];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> FileMetaData* f = files[i];</span><br><span class="line">      edit.<span class="built_in">AddFile</span>(level, f-&gt;number, f-&gt;file_size, f-&gt;smallest, f-&gt;largest);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string record;</span><br><span class="line">  edit.<span class="built_in">EncodeTo</span>(&amp;record);</span><br><span class="line">  <span class="keyword">return</span> log-&gt;<span class="built_in">AddRecord</span>(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先会将比较器的名字作为 Record 写入 MANIFEST 文件中。根据本系列第三篇博文中分析的日志记录方式，每一条 Record 会有 7 字节的 Header，其中前 4 字节为 CRC 校验值可以不理会，5、6 字节为记录的长度，这里是 <code>0x1c = 28</code>，最后是 Record 类型，这里的类型是 <code>kFullType = 1</code>。而后的 28 字节便是记录了比较器名字的 <code>edit</code> 对象，其内容需要根据编码的方式进行解码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tag numbers for serialized VersionEdit.  These numbers are written to</span></span><br><span class="line"><span class="comment">// disk and should not be changed.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Tag</span> &#123;</span></span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionEdit::EncodeTo</span><span class="params">(std::string* dst)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (has_comparator_) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kComparator);</span><br><span class="line">    <span class="built_in">PutLengthPrefixedSlice</span>(dst, comparator_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_log_number_) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kLogNumber);</span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_prev_log_number_) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kPrevLogNumber);</span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_next_file_number_) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kNextFileNumber);</span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, next_file_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_last_sequence_) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kLastSequence);</span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, last_sequence_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kCompactPointer);</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, compact_pointers_[i].first);  <span class="comment">// level</span></span><br><span class="line">    <span class="built_in">PutLengthPrefixedSlice</span>(dst, compact_pointers_[i].second.<span class="built_in">Encode</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_kvp : deleted_files_) &#123;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kDeletedFile);</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, deleted_file_kvp.first);   <span class="comment">// level</span></span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, deleted_file_kvp.second);  <span class="comment">// file number</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> FileMetaData&amp; f = new_files_[i].second;</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, kNewFile);</span><br><span class="line">    <span class="built_in">PutVarint32</span>(dst, new_files_[i].first);  <span class="comment">// level</span></span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, f.number);</span><br><span class="line">    <span class="built_in">PutVarint64</span>(dst, f.file_size);</span><br><span class="line">    <span class="built_in">PutLengthPrefixedSlice</span>(dst, f.smallest.<span class="built_in">Encode</span>());</span><br><span class="line">    <span class="built_in">PutLengthPrefixedSlice</span>(dst, f.largest.<span class="built_in">Encode</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">01</span> <span class="number">1</span>a <span class="number">6</span>c <span class="number">65</span> <span class="number">76</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">64</span> <span class="number">62</span> <span class="number">2</span>e <span class="number">42</span> <span class="number">79</span> <span class="number">74</span> <span class="number">65</span> <span class="number">77</span> <span class="number">69</span> <span class="number">73</span> <span class="number">65</span> <span class="number">43</span> <span class="number">6f</span> <span class="number">6</span>d <span class="number">70</span> <span class="number">61</span> <span class="number">72</span> <span class="number">61</span> <span class="number">74</span> <span class="number">6f</span> <span class="number">72</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>kComparator=1</code>，而后是比较器的长度 <code>0x1a=26</code> 和名字对应的 ASCII 码，<a href="http://www.unit-conversion.info/texttools/hexadecimal/">翻译过来</a>就是 <code>leveldb.BytewiseComparator</code>。之后的第二条记录便是 <code>leveldb::DB:OpenDB</code> 中的 <code>edit</code> 对象的 Record 记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a4 9c 8b be 08 00 01 02 03 09 00 03 04 04 00</span><br></pre></td></tr></table></figure>

<p>一样的 7 字节 Header，Record 长度为 8，具体内容为：</p>
<ol>
<li><code>kLogNumber=02</code>，对应的日志编号为 3；</li>
<li><code>kPrevLogNumber=09</code>，对应的上一个日志编号为 0；</li>
<li><code>kNextFileNumber=03</code>，对应的下一个文件编号为 4；</li>
<li><code>kLastSequence=04</code>，对应的最新序列号为 0。</li>
</ol>
<p>最后回到 <code>leveldb::DB::OpenDB</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">  impl-&gt;<span class="built_in">DeleteObsoleteFiles</span>();</span><br><span class="line">  impl-&gt;<span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建或恢复成功后，执行 <code>DBImpl::DeleteObsoleteFiles</code> 删除废弃文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::DeleteObsoleteFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// After a background error, we don&#x27;t know whether a new version may</span></span><br><span class="line">    <span class="comment">// or may not have been committed, so we cannot safely garbage collect.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a set of all of the live files</span></span><br><span class="line">  std::set&lt;<span class="keyword">uint64_t</span>&gt; live = pending_outputs_;</span><br><span class="line">  versions_-&gt;<span class="built_in">AddLiveFiles</span>(&amp;live);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; filenames;</span><br><span class="line">  env_-&gt;<span class="built_in">GetChildren</span>(dbname_, &amp;filenames);  <span class="comment">// Ignoring errors on purpose</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  FileType type;</span><br><span class="line">  std::vector&lt;std::string&gt; files_to_delete;</span><br><span class="line">  <span class="keyword">for</span> (std::string&amp; filename : filenames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ParseFileName</span>(filename, &amp;number, &amp;type)) &#123;</span><br><span class="line">      <span class="keyword">bool</span> keep = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> kLogFile:</span><br><span class="line">          keep = ((number &gt;= versions_-&gt;<span class="built_in">LogNumber</span>()) ||</span><br><span class="line">                  (number == versions_-&gt;<span class="built_in">PrevLogNumber</span>()));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kDescriptorFile:</span><br><span class="line">          <span class="comment">// Keep my manifest file, and any newer incarnations&#x27;</span></span><br><span class="line">          <span class="comment">// (in case there is a race that allows other incarnations)</span></span><br><span class="line">          keep = (number &gt;= versions_-&gt;<span class="built_in">ManifestFileNumber</span>());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTableFile:</span><br><span class="line">          keep = (live.<span class="built_in">find</span>(number) != live.<span class="built_in">end</span>());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTempFile:</span><br><span class="line">          <span class="comment">// Any temp files that are currently being written to must</span></span><br><span class="line">          <span class="comment">// be recorded in pending_outputs_, which is inserted into &quot;live&quot;</span></span><br><span class="line">          keep = (live.<span class="built_in">find</span>(number) != live.<span class="built_in">end</span>());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCurrentFile:</span><br><span class="line">        <span class="keyword">case</span> kDBLockFile:</span><br><span class="line">        <span class="keyword">case</span> kInfoLogFile:</span><br><span class="line">          keep = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        files_to_delete.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(filename));</span><br><span class="line">        <span class="keyword">if</span> (type == kTableFile) &#123;</span><br><span class="line">          table_cache_-&gt;<span class="built_in">Evict</span>(number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Delete type=%d #%lld\n&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(type),</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// While deleting all files unblock other threads. All files being deleted</span></span><br><span class="line">  <span class="comment">// have unique names which will not collide with newly created files and</span></span><br><span class="line">  <span class="comment">// are therefore safe to delete while allowing other threads to proceed.</span></span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> std::string&amp; filename : files_to_delete) &#123;</span><br><span class="line">    env_-&gt;<span class="built_in">DeleteFile</span>(dbname_ + <span class="string">&quot;/&quot;</span> + filename);</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的废弃文件也包括创建不久的 <code>testdb/MANIFEST-000001</code>。至此 <code>leveldb::DB::Open</code> 函数分析完毕。</p>
<p>而后执行的写入操作 <code>db-&gt;Put</code>，会将数据写入日志文件和内存数据库。此时使用的日志文件编号为 3，也就是 <code>testdb/000003.db</code>，其写入后的内容为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ hexdump 000003.log</span><br><span class="line">0000000 aa a0 87 24 1b 00 01 01 00 00 00 00 00 00 00 01</span><br><span class="line">0000010 00 00 00 01 05 5b 4b 65 79 5d 07 5b 56 61 6c 75</span><br><span class="line">0000020 65 5d</span><br></pre></td></tr></table></figure>

<p>一样的 7 字节 Header，Record 长度为 <code>0x1b=27</code>，内容为 <code>WriteBatch</code> 编码结果。参考本系列第三篇博文，内容的前 8 字节为序列号，这里是 1；其后的 4 字节为键值对数量，这里也是 1；再后面就是附带长度编码的键值对，分别是 <code>[Key]</code> 和 <code>[Value]</code>。最后代码结束，删除了 <code>db</code> 对象，也就得到了前文叙述的文件状态。</p>
<h3 id="2-打开数据库并读取"><a href="#2-打开数据库并读取" class="headerlink" title="2. 打开数据库并读取"></a>2. 打开数据库并读取</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  leveldb::DB* db;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    leveldb::Options options;</span><br><span class="line">    options.compression = leveldb::kNoCompression;</span><br><span class="line">    leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;testdb&quot;</span>, &amp;db);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    std::string key = <span class="string">&quot;[Key]&quot;</span>;</span><br><span class="line">    std::string value;</span><br><span class="line">    leveldb::ReadOptions read_options;</span><br><span class="line">    leveldb::Status status = db-&gt;<span class="built_in">Get</span>(read_options, key, &amp;value);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上一节创建的数据库的基础上，执行上方的代码。首先打开数据库，再读取 Key 对应的 Value。最终的数据库文件状态为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ ls -l</span><br><span class="line">total 40</span><br><span class="line">-rw-r--r--  1 pxf  staff   124B Sep  7 09:57 000005.ldb</span><br><span class="line">-rw-r--r--  1 pxf  staff     0B Sep  7 09:57 000006.log</span><br><span class="line">-rw-r--r--  1 pxf  staff    16B Sep  7 09:57 CURRENT</span><br><span class="line">-rw-r--r--  1 pxf  staff     0B Sep  7 09:57 LOCK</span><br><span class="line">-rw-r--r--  1 pxf  staff   304B Sep  7 09:57 LOG</span><br><span class="line">-rw-r--r--  1 pxf  staff    56B Sep  7 09:57 LOG.old</span><br><span class="line">-rw-r--r--  1 pxf  staff    82B Sep  7 09:57 MANIFEST-000004</span><br></pre></td></tr></table></figure>

<p>和之前一样，沿着代码分析打开数据库的流程。<code>DB::Open</code> 前期的步骤一致，直接跳到 <code>impl-&gt;Recover</code>。由于存在 CURRENT 文件，所以就跳过了 <code>NewDB</code> 的步骤。随后依然是 <code>versions_-&gt;Recover</code>，读取 CURRENT 文件、继而读取 MANIFEST。如上一节中所分析的，LogNumber 为 3，NextFileNumber 为 4，故最后新建的 MANIFEST 文件编号为 4。随后回到 <code>impl-&gt;Recover</code> 执行恢复日志文件数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Recover</span><span class="params">(VersionEdit* edit, <span class="keyword">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">SequenceNumber <span class="title">max_sequence</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recover from all newer log files than the ones named in the</span></span><br><span class="line">  <span class="comment">// descriptor (new log files may have been added by the previous</span></span><br><span class="line">  <span class="comment">// incarnation without registering them in the descriptor).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Note that PrevLogNumber() is no longer used, but we pay</span></span><br><span class="line">  <span class="comment">// attention to it in case we are recovering a database</span></span><br><span class="line">  <span class="comment">// produced by an older version of leveldb.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> min_log = versions_-&gt;<span class="built_in">LogNumber</span>();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> prev_log = versions_-&gt;<span class="built_in">PrevLogNumber</span>();</span><br><span class="line">  std::vector&lt;std::string&gt; filenames;</span><br><span class="line">  s = env_-&gt;<span class="built_in">GetChildren</span>(dbname_, &amp;filenames);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  std::set&lt;<span class="keyword">uint64_t</span>&gt; expected;</span><br><span class="line">  versions_-&gt;<span class="built_in">AddLiveFiles</span>(&amp;expected);</span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  FileType type;</span><br><span class="line">  std::vector&lt;<span class="keyword">uint64_t</span>&gt; logs;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filenames.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ParseFileName</span>(filenames[i], &amp;number, &amp;type)) &#123;</span><br><span class="line">      expected.<span class="built_in">erase</span>(number);</span><br><span class="line">      <span class="keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))</span><br><span class="line">        logs.<span class="built_in">push_back</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!expected.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf), <span class="string">&quot;%d missing files; e.g.&quot;</span>,</span><br><span class="line">             <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(expected.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(buf, <span class="built_in">TableFileName</span>(dbname_, *(expected.<span class="built_in">begin</span>())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recover in the order in which the logs were generated</span></span><br><span class="line">  std::<span class="built_in">sort</span>(logs.<span class="built_in">begin</span>(), logs.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; logs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    s = <span class="built_in">RecoverLogFile</span>(logs[i], (i == logs.<span class="built_in">size</span>() - <span class="number">1</span>), save_manifest, edit,</span><br><span class="line">                       &amp;max_sequence);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The previous incarnation may not have written any MANIFEST</span></span><br><span class="line">    <span class="comment">// records after allocating this log number.  So we manually</span></span><br><span class="line">    <span class="comment">// update the file number allocation counter in VersionSet.</span></span><br><span class="line">    versions_-&gt;<span class="built_in">MarkFileNumberUsed</span>(logs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (versions_-&gt;<span class="built_in">LastSequence</span>() &lt; max_sequence) &#123;</span><br><span class="line">    versions_-&gt;<span class="built_in">SetLastSequence</span>(max_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索数据库目录下的、符合条件的日志文件，然后执行 <code>DBImpl::RecoverLogFile</code> 进行恢复：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::RecoverLogFile</span><span class="params">(<span class="keyword">uint64_t</span> log_number, <span class="keyword">bool</span> last_log,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">bool</span>* save_manifest, VersionEdit* edit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              SequenceNumber* max_sequence)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LogReporter</span> :</span> <span class="keyword">public</span> log::Reader::Reporter &#123;</span><br><span class="line">    Env* env;</span><br><span class="line">    Logger* info_log;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* fname;</span><br><span class="line">    Status* status;  <span class="comment">// null if options_.paranoid_checks==false</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">const</span> Status&amp; s)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="built_in">Log</span>(info_log, <span class="string">&quot;%s%s: dropping %d bytes; %s&quot;</span>,</span><br><span class="line">          (<span class="keyword">this</span>-&gt;status == <span class="literal">nullptr</span> ? <span class="string">&quot;(ignoring error) &quot;</span> : <span class="string">&quot;&quot;</span>), fname,</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(bytes), s.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;status != <span class="literal">nullptr</span> &amp;&amp; <span class="keyword">this</span>-&gt;status-&gt;<span class="built_in">ok</span>()) *<span class="keyword">this</span>-&gt;status = s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the log file</span></span><br><span class="line">  std::string fname = <span class="built_in">LogFileName</span>(dbname_, log_number);</span><br><span class="line">  SequentialFile* file;</span><br><span class="line">  Status status = env_-&gt;<span class="built_in">NewSequentialFile</span>(fname, &amp;file);</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">MaybeIgnoreError</span>(&amp;status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the log reader.</span></span><br><span class="line">  LogReporter reporter;</span><br><span class="line">  reporter.env = env_;</span><br><span class="line">  reporter.info_log = options_.info_log;</span><br><span class="line">  reporter.fname = fname.<span class="built_in">c_str</span>();</span><br><span class="line">  reporter.status = (options_.paranoid_checks ? &amp;status : <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// We intentionally make log::Reader do checksumming even if</span></span><br><span class="line">  <span class="comment">// paranoid_checks==false so that corruptions cause entire commits</span></span><br><span class="line">  <span class="comment">// to be skipped instead of propagating bad information (like overly</span></span><br><span class="line">  <span class="comment">// large sequence numbers).</span></span><br><span class="line">  <span class="function">log::Reader <span class="title">reader</span><span class="params">(file, &amp;reporter, <span class="literal">true</span> <span class="comment">/*checksum*/</span>, <span class="number">0</span> <span class="comment">/*initial_offset*/</span>)</span></span>;</span><br><span class="line">  <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Recovering log #%llu&quot;</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)log_number);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read all the records and add to a memtable</span></span><br><span class="line">  std::string scratch;</span><br><span class="line">  Slice record;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  <span class="keyword">int</span> compactions = <span class="number">0</span>;</span><br><span class="line">  MemTable* mem = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (reader.<span class="built_in">ReadRecord</span>(&amp;record, &amp;scratch) &amp;&amp; status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (record.<span class="built_in">size</span>() &lt; <span class="number">12</span>) &#123;</span><br><span class="line">      reporter.<span class="built_in">Corruption</span>(record.<span class="built_in">size</span>(),</span><br><span class="line">                          Status::<span class="built_in">Corruption</span>(<span class="string">&quot;log record too small&quot;</span>));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WriteBatchInternal::<span class="built_in">SetContents</span>(&amp;batch, record);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      mem = <span class="keyword">new</span> <span class="built_in">MemTable</span>(internal_comparator_);</span><br><span class="line">      mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    status = WriteBatchInternal::<span class="built_in">InsertInto</span>(&amp;batch, mem);</span><br><span class="line">    <span class="built_in">MaybeIgnoreError</span>(&amp;status);</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> SequenceNumber last_seq = WriteBatchInternal::<span class="built_in">Sequence</span>(&amp;batch) +</span><br><span class="line">                                    WriteBatchInternal::<span class="built_in">Count</span>(&amp;batch) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (last_seq &gt; *max_sequence) &#123;</span><br><span class="line">      *max_sequence = last_seq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;<span class="built_in">ApproximateMemoryUsage</span>() &gt; options_.write_buffer_size) &#123;</span><br><span class="line">      compactions++;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">      status = <span class="built_in">WriteLevel0Table</span>(mem, edit, <span class="literal">nullptr</span>);</span><br><span class="line">      mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">      mem = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="comment">// Reflect errors immediately so that conditions like full</span></span><br><span class="line">        <span class="comment">// file-systems cause the DB::Open() to fail.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> file;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if we should keep reusing the last log file.</span></span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; options_.reuse_logs &amp;&amp; last_log &amp;&amp; compactions == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(logfile_ == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">assert</span>(log_ == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">assert</span>(mem_ == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> lfile_size;</span><br><span class="line">    <span class="keyword">if</span> (env_-&gt;<span class="built_in">GetFileSize</span>(fname, &amp;lfile_size).<span class="built_in">ok</span>() &amp;&amp;</span><br><span class="line">        env_-&gt;<span class="built_in">NewAppendableFile</span>(fname, &amp;logfile_).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Reusing old log %s \n&quot;</span>, fname.<span class="built_in">c_str</span>());</span><br><span class="line">      log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(logfile_, lfile_size);</span><br><span class="line">      logfile_number_ = log_number;</span><br><span class="line">      <span class="keyword">if</span> (mem != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        mem_ = mem;</span><br><span class="line">        mem = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mem can be nullptr if lognum exists but was empty.</span></span><br><span class="line">        mem_ = <span class="keyword">new</span> <span class="built_in">MemTable</span>(internal_comparator_);</span><br><span class="line">        mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// mem did not get reused; compact it.</span></span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">      status = <span class="built_in">WriteLevel0Table</span>(mem, edit, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DBImpl::RecoverLogFile</code> 将日志文件中的数据读取到内存数据库中，同时更新序列号，最后将内存数据库中的数据写入 Level0 的 Sorted Table 里，也就是最终状态里的 <code>testdb/000005.ldb</code>。执行完成后回到 <code>DBImpl::Recover</code>，再回到 <code>DB::Open</code> 里。再后面就与上一节中的行为一致了。</p>
<p>最后来看下 MANIFEST 的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ hexdump MANIFEST-000004</span><br><span class="line">0000000 56 f9 b8 f8 1c 00 01 01 1a 6c 65 76 65 6c 64 62</span><br><span class="line">0000010 2e 42 79 74 65 77 69 73 65 43 6f 6d 70 61 72 61</span><br><span class="line">0000020 74 6f 72 9e bc a9 67 28 00 01 02 06 09 00 03 07</span><br><span class="line">0000030 04 01 07 00 05 7c 0d 5b 4b 65 79 5d 01 01 00 00</span><br><span class="line">0000040 00 00 00 00 0d 5b 4b 65 79 5d 01 01 00 00 00 00</span><br><span class="line">0000050 00 00</span><br></pre></td></tr></table></figure>

<p>前面的一段比较器名和上一节中的一致，直接来看第二条记录，也就是第 0x23 个字节开始看。4 字节 CRC，忽略；记录长度为 <code>0x28=40</code>，后面依旧是 <code>VersionEdit</code> 的编码结果：</p>
<ol>
<li><code>kLogNumber=02</code>，对应的日志编号为 6；</li>
<li><code>kPrevLogNumber=09</code>，对应的上一个日志编号为 0；</li>
<li><code>kNextFileNumber=03</code>，对应的下一个文件编号为 7；</li>
<li><code>kLastSequence=04</code>，对应的最新序列号为 1；</li>
<li><code>kNewFile=07</code>，对应新增文件，其 Level 为 0，编号为 5，文件大小 <code>0x7c=124</code>，最小键和最大键都是长度为 <code>0x0d = 13</code> 的 <code>5b 4b 65 79 5d 01 01 00 00 00 00 00 00</code>，格式为 Internal Key。Internal Key 后面的 8 个字节为综合序列号，对应 <code>kTypeValue=1</code>，序列号为 1。</li>
</ol>
<p>至此数据库打开的流程分析完毕。接下来看 <code>leveldb::DB::Get</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::string* value)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  <span class="keyword">if</span> (options.snapshot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    snapshot =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;<span class="built_in">sequence_number</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    snapshot = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* mem = mem_;</span><br><span class="line">  MemTable* imm = imm_;</span><br><span class="line">  Version* current = versions_-&gt;<span class="built_in">current</span>();</span><br><span class="line">  mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  current-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">  Version::GetStats stats;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">    <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = current-&gt;<span class="built_in">Get</span>(options, lkey, value, &amp;stats);</span><br><span class="line">      have_stat_update = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;<span class="built_in">UpdateStats</span>(stats)) &#123;</span><br><span class="line">    <span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  current-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DBImpl::Get</code> 首先会尝试从内存数据中读取数据，如果找不到则会使用 <code>Version::Get</code> 读取，其过程参见上一篇博文。至此读取的流程也分析完毕。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>LevelDB 每次打开数据库时都会创建新的 MANIFEST 文件（默认情况下 <code>Options::reuse_logs=false</code>）；</li>
<li>存储在日志中的键值对，会在下一次打开数据库时转为 <code>.ldb</code> 文件。</li>
</ol>
<p>。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码分析——6.Sorted String Table</title>
    <url>/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%946.Sorted%20String%20Table/</url>
    <content><![CDATA[<h2 id="六-Sorted-String-Table"><a href="#六-Sorted-String-Table" class="headerlink" title="六.Sorted String Table"></a>六.Sorted String Table</h2><p>本系列的上一篇介绍了内存数据库，并且提到了内存数据库的大小限制问题。当内存数据块占用的内存达到阈值时（LevelDB 默认 4MB），会将当前的内存数据库 <code>mem_</code> 转为不可修改的 <code>imm_</code>，并且为 <code>mem_</code> 赋值一个新的内存数据库。这使得内存数据库的大小始终保持在阈值以下，同时保持着超高的读写性能。而不可修改的 <code>imm_</code> 会经历Compaction 过程，转为 Sorted Table 存储到磁盘中。本篇将详细阐述该过程。</p>
<span id="more"></span>

<h3 id="1-Compact-内存数据库"><a href="#1-Compact-内存数据库" class="headerlink" title="1. Compact 内存数据库"></a>1. Compact 内存数据库</h3><p>在 <code>DBImpl::Write</code> 写入内存数据库前，会先调用 <code>DBImpl::MakeRoomForWrite</code> 申请空间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::MakeRoomForWrite</span><span class="params">(<span class="keyword">bool</span> force)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!writers_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="keyword">bool</span> allow_delay = !force;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="comment">// Yield previous error</span></span><br><span class="line">      s = bg_error_;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allow_delay &amp;&amp; versions_-&gt;<span class="built_in">NumLevelFiles</span>(<span class="number">0</span>) &gt;=</span><br><span class="line">                                  config::kL0_SlowdownWritesTrigger) &#123;</span><br><span class="line">      <span class="comment">// We are getting close to hitting a hard limit on the number of</span></span><br><span class="line">      <span class="comment">// L0 files.  Rather than delaying a single write by several</span></span><br><span class="line">      <span class="comment">// seconds when we hit the hard limit, start delaying each</span></span><br><span class="line">      <span class="comment">// individual write by 1ms to reduce latency variance.  Also,</span></span><br><span class="line">      <span class="comment">// this delay hands over some CPU to the compaction thread in</span></span><br><span class="line">      <span class="comment">// case it is sharing the same core as the writer.</span></span><br><span class="line">      mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">      env_-&gt;<span class="built_in">SleepForMicroseconds</span>(<span class="number">1000</span>);</span><br><span class="line">      allow_delay = <span class="literal">false</span>;  <span class="comment">// Do not delay a single write more than once</span></span><br><span class="line">      mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!force &amp;&amp;</span><br><span class="line">               (mem_-&gt;<span class="built_in">ApproximateMemoryUsage</span>() &lt;= options_.write_buffer_size)) &#123;</span><br><span class="line">      <span class="comment">// There is room in current memtable</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// We have filled up the current memtable, but the previous</span></span><br><span class="line">      <span class="comment">// one is still being compacted, so we wait.</span></span><br><span class="line">      <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Current memtable full; waiting...\n&quot;</span>);</span><br><span class="line">      background_work_finished_signal_.<span class="built_in">Wait</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (versions_-&gt;<span class="built_in">NumLevelFiles</span>(<span class="number">0</span>) &gt;= config::kL0_StopWritesTrigger) &#123;</span><br><span class="line">      <span class="comment">// There are too many level-0 files.</span></span><br><span class="line">      <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Too many L0 files; waiting...\n&quot;</span>);</span><br><span class="line">      background_work_finished_signal_.<span class="built_in">Wait</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Attempt to switch to a new memtable and trigger compaction of old</span></span><br><span class="line">      <span class="built_in">assert</span>(versions_-&gt;<span class="built_in">PrevLogNumber</span>() == <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">uint64_t</span> new_log_number = versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">      WritableFile* lfile = <span class="literal">nullptr</span>;</span><br><span class="line">      s = env_-&gt;<span class="built_in">NewWritableFile</span>(<span class="built_in">LogFileName</span>(dbname_, new_log_number), &amp;lfile);</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="comment">// Avoid chewing through file number space in a tight loop.</span></span><br><span class="line">        versions_-&gt;<span class="built_in">ReuseFileNumber</span>(new_log_number);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> log_;</span><br><span class="line">      <span class="keyword">delete</span> logfile_;</span><br><span class="line">      logfile_ = lfile;</span><br><span class="line">      logfile_number_ = new_log_number;</span><br><span class="line">      log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(lfile);</span><br><span class="line">      imm_ = mem_;</span><br><span class="line">      has_imm_.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">      mem_ = <span class="keyword">new</span> <span class="built_in">MemTable</span>(internal_comparator_);</span><br><span class="line">      mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">      force = <span class="literal">false</span>;  <span class="comment">// Do not force another compaction if have room</span></span><br><span class="line">      <span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 While 循环中，会依次检查：</p>
<ol>
<li>是否有后台错误，如果是就退出；</li>
<li>是否允许延迟、并且现有的 L0 文件稍多，如果是则释放锁、等待 1 毫秒、再等待锁，并且不允许再次等待；</li>
<li>是否非强制模式、并且内存数据库大小没有超出阈值，如果是就还有空间、可以退出了；</li>
<li>是否 <code>imm_</code> 还在 Compact 中，如果是就等待 Compact 完成（条件变量）；</li>
<li>是否现有的 L0 文件太多，如果是就等待 Compact 完成（条件变量）；</li>
<li>以上都不是，那就说明当前的 <code>mem_</code> 满了，把它丢给 <code>imm_</code>，再新建一个 <code>mem_</code>，触发 Compaction。</li>
</ol>
<p>除了第 1 步和第 3 步，其他步骤完成后均重新进入循环，最终从 1 或 3 中退出。第 2 步中当 L0 文件数目达到 <code>kL0_SlowdownWritesTrigger</code> 限制时，对每个写入请求等待 1 毫秒，也就减缓了写入的速度；第 5 步中当 L0 文件数目达到 <code>kL0_StopWritesTrigger</code> 限制时，就强制等待当前的 Compact 完成，直到 L0 文件数目小于限制时，下次循环才能到达第 6 步。</p>
<p>继续看 <code>MaybeScheduleCompaction</code> 及其后续过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;<span class="built_in">NeedsCompaction</span>()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BGWork</span><span class="params">(<span class="keyword">void</span>* db)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">reinterpret_cast</span>&lt;DBImpl*&gt;(db)-&gt;<span class="built_in">BackgroundCall</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">assert</span>(background_compaction_scheduled_);</span><br><span class="line">  <span class="keyword">if</span> (shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// No more background work when shutting down.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// No more background work after a background error.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">BackgroundCompaction</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_compaction_scheduled_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Previous compaction may have produced too many files in a level,</span></span><br><span class="line">  <span class="comment">// so reschedule another compaction if needed.</span></span><br><span class="line">  <span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">  background_work_finished_signal_.<span class="built_in">SignalAll</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">CompactMemTable</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::CompactMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="built_in">assert</span>(imm_ != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the memtable as a new Table</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  Version* base = versions_-&gt;<span class="built_in">current</span>();</span><br><span class="line">  base-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  Status s = <span class="built_in">WriteLevel0Table</span>(imm_, &amp;edit, base);</span><br><span class="line">  base-&gt;<span class="built_in">Unref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; shutting_down_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">    s = Status::<span class="built_in">IOError</span>(<span class="string">&quot;Deleting DB during memtable compaction&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    edit.<span class="built_in">SetPrevLogNumber</span>(<span class="number">0</span>);</span><br><span class="line">    edit.<span class="built_in">SetLogNumber</span>(logfile_number_);  <span class="comment">// Earlier logs no longer needed</span></span><br><span class="line">    s = versions_-&gt;<span class="built_in">LogAndApply</span>(&amp;edit, &amp;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Commit to the new state</span></span><br><span class="line">    imm_-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">    imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">    has_imm_.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_release);</span><br><span class="line">    <span class="built_in">DeleteObsoleteFiles</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">RecordBackgroundError</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::WriteLevel0Table</span><span class="params">(MemTable* mem, VersionEdit* edit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Version* base)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;<span class="built_in">NowMicros</span>();</span><br><span class="line">  FileMetaData meta;</span><br><span class="line">  meta.number = versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">  pending_outputs_.<span class="built_in">insert</span>(meta.number);</span><br><span class="line">  Iterator* iter = mem-&gt;<span class="built_in">NewIterator</span>();</span><br><span class="line">  <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Level-0 table #%llu: started&quot;</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number);</span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    s = <span class="built_in">BuildTable</span>(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Level-0 table #%llu: %lld bytes %s&quot;</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.file_size,</span><br><span class="line">      s.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  pending_outputs_.<span class="built_in">erase</span>(meta.number);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note that if file_size is zero, the file has been deleted and</span></span><br><span class="line">  <span class="comment">// should not be added to the manifest.</span></span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; meta.file_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> Slice min_user_key = meta.smallest.<span class="built_in">user_key</span>();</span><br><span class="line">    <span class="keyword">const</span> Slice max_user_key = meta.largest.<span class="built_in">user_key</span>();</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      level = base-&gt;<span class="built_in">PickLevelForMemTableOutput</span>(min_user_key, max_user_key);</span><br><span class="line">    &#125;</span><br><span class="line">    edit-&gt;<span class="built_in">AddFile</span>(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line">                  meta.largest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.micros = env_-&gt;<span class="built_in">NowMicros</span>() - start_micros;</span><br><span class="line">  stats.bytes_written = meta.file_size;</span><br><span class="line">  stats_[level].<span class="built_in">Add</span>(stats);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MaybeScheduleCompaction</code> 经过一些判断，最后调用 <code>env_-&gt;Schedule</code> 创建一个 Detached 的线程启动 <code>DBImpl::BGWork</code>，继而调用 <code>DBImpl::BackgroundCall</code>，继而调用 <code>DBImpl::BackgroundCompaction</code>。该函数在 <code>imm_</code> 非空的情况下，直接执行 <code>CompactMemTable</code> 返回。<code>CompactMemTable</code> 的核心操作为 <code>WriteLevel0Table(imm_, &amp;edit, base)</code>，将会把 <code>imm_</code> 中的数据写到 Level0 Table 里。这是我们第一次碰触到 LevelDB 名字中 Level 的边缘。</p>
<p>如果先不看 Version 相关的部分，<code>WriteLevel0Table</code> 会调用 <code>BuildTable</code> 建 Sorted Table。该函数的实现位于 <a href="https://github.com/google/leveldb/blob/master/db/builder.cc"><code>db/builder.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;db/builder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;db/dbformat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;db/filename.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;db/table_cache.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;db/version_edit.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/env.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/iterator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BuildTable</span><span class="params">(<span class="keyword">const</span> std::string&amp; dbname, Env* env, <span class="keyword">const</span> Options&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                  TableCache* table_cache, Iterator* iter, FileMetaData* meta)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  meta-&gt;file_size = <span class="number">0</span>;</span><br><span class="line">  iter-&gt;<span class="built_in">SeekToFirst</span>();</span><br><span class="line"></span><br><span class="line">  std::string fname = <span class="built_in">TableFileName</span>(dbname, meta-&gt;number);</span><br><span class="line">  <span class="keyword">if</span> (iter-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    WritableFile* file;</span><br><span class="line">    s = env-&gt;<span class="built_in">NewWritableFile</span>(fname, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TableBuilder* builder = <span class="keyword">new</span> <span class="built_in">TableBuilder</span>(options, file);</span><br><span class="line">    meta-&gt;smallest.<span class="built_in">DecodeFrom</span>(iter-&gt;<span class="built_in">key</span>());</span><br><span class="line">    <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">      Slice key = iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">      meta-&gt;largest.<span class="built_in">DecodeFrom</span>(key);</span><br><span class="line">      builder-&gt;<span class="built_in">Add</span>(key, iter-&gt;<span class="built_in">value</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish and check for builder errors</span></span><br><span class="line">    s = builder-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      meta-&gt;file_size = builder-&gt;<span class="built_in">FileSize</span>();</span><br><span class="line">      <span class="built_in">assert</span>(meta-&gt;file_size &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> builder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish and check for file errors</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = file-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = file-&gt;<span class="built_in">Close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> file;</span><br><span class="line">    file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="comment">// Verify that the table is usable</span></span><br><span class="line">      Iterator* it = table_cache-&gt;<span class="built_in">NewIterator</span>(<span class="built_in">ReadOptions</span>(), meta-&gt;number,</span><br><span class="line">                                              meta-&gt;file_size);</span><br><span class="line">      s = it-&gt;<span class="built_in">status</span>();</span><br><span class="line">      <span class="keyword">delete</span> it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for input iterator errors</span></span><br><span class="line">  <span class="keyword">if</span> (!iter-&gt;<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = iter-&gt;<span class="built_in">status</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; meta-&gt;file_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Keep it</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    env-&gt;<span class="built_in">DeleteFile</span>(fname);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p>核心操作是遍历迭代器，将键值对加入到一个 <code>TableBuilder</code> 对象里，同时维护 <code>meta</code> 信息，包括 <code>smallest</code>、<code>largest</code> 和 <code>file_size</code>。</p>
<h3 id="2-Block-Builder"><a href="#2-Block-Builder" class="headerlink" title="2. Block Builder"></a>2. Block Builder</h3><p>在介绍 <code>TableBuilder</code> 之前，需要先介绍它的依赖 <code>BlockBuilder</code>。先看 <a href="https://github.com/google/leveldb/blob/master/table/block_builder.h"><code>table/block_builder.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">BlockBuilder</span><span class="params">(<span class="keyword">const</span> Options* options)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">BlockBuilder</span>(<span class="keyword">const</span> BlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  BlockBuilder&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> BlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reset the contents as if the BlockBuilder was just constructed.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// REQUIRES: Finish() has not been called since the last call to Reset().</span></span><br><span class="line">  <span class="comment">// REQUIRES: key is larger than any previously added key</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finish building the block and return a slice that refers to the</span></span><br><span class="line">  <span class="comment">// block contents.  The returned slice will remain valid for the</span></span><br><span class="line">  <span class="comment">// lifetime of this builder or until Reset() is called.</span></span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an estimate of the current (uncompressed) size of the block</span></span><br><span class="line">  <span class="comment">// we are building.</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">CurrentSizeEstimate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true iff no entries have been added since the last Reset()</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> buffer_.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> Options* options_;</span><br><span class="line">  std::string buffer_;              <span class="comment">// Destination buffer</span></span><br><span class="line">  std::vector&lt;<span class="keyword">uint32_t</span>&gt; restarts_;  <span class="comment">// Restart points</span></span><br><span class="line">  <span class="keyword">int</span> counter_;                     <span class="comment">// Number of entries emitted since restart</span></span><br><span class="line">  <span class="keyword">bool</span> finished_;                   <span class="comment">// Has Finish() been called?</span></span><br><span class="line">  std::string last_key_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接口看不出什么，继续看实现 <a href="https://github.com/google/leveldb/blob/master/table/block_builder.cc"><code>table/block_builder.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BlockBuilder generates blocks where keys are prefix-compressed:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When we store a key, we drop the prefix shared with the previous</span></span><br><span class="line"><span class="comment">// string.  This helps reduce the space requirement significantly.</span></span><br><span class="line"><span class="comment">// Furthermore, once every K keys, we do not apply the prefix</span></span><br><span class="line"><span class="comment">// compression and store the entire key.  We call this a &quot;restart</span></span><br><span class="line"><span class="comment">// point&quot;.  The tail end of the block stores the offsets of all of the</span></span><br><span class="line"><span class="comment">// restart points, and can be used to do a binary search when looking</span></span><br><span class="line"><span class="comment">// for a particular key.  Values are stored as-is (without compression)</span></span><br><span class="line"><span class="comment">// immediately following the corresponding key.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// An entry for a particular key-value pair has the form:</span></span><br><span class="line"><span class="comment">//     shared_bytes: varint32</span></span><br><span class="line"><span class="comment">//     unshared_bytes: varint32</span></span><br><span class="line"><span class="comment">//     value_length: varint32</span></span><br><span class="line"><span class="comment">//     key_delta: char[unshared_bytes]</span></span><br><span class="line"><span class="comment">//     value: char[value_length]</span></span><br><span class="line"><span class="comment">// shared_bytes == 0 for restart points.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The trailer of the block has the form:</span></span><br><span class="line"><span class="comment">//     restarts: uint32[num_restarts]</span></span><br><span class="line"><span class="comment">//     num_restarts: uint32</span></span><br><span class="line"><span class="comment">// restarts[i] contains the offset within the block of the ith restart point.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;table/block_builder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/comparator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/options.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/coding.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line">BlockBuilder::<span class="built_in">BlockBuilder</span>(<span class="keyword">const</span> Options* options)</span><br><span class="line">    : <span class="built_in">options_</span>(options), <span class="built_in">restarts_</span>(), <span class="built_in">counter_</span>(<span class="number">0</span>), <span class="built_in">finished_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(options-&gt;block_restart_interval &gt;= <span class="number">1</span>);</span><br><span class="line">  restarts_.<span class="built_in">push_back</span>(<span class="number">0</span>);  <span class="comment">// First restart point is at offset 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBuilder::Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  buffer_.<span class="built_in">clear</span>();</span><br><span class="line">  restarts_.<span class="built_in">clear</span>();</span><br><span class="line">  restarts_.<span class="built_in">push_back</span>(<span class="number">0</span>);  <span class="comment">// First restart point is at offset 0</span></span><br><span class="line">  counter_ = <span class="number">0</span>;</span><br><span class="line">  finished_ = <span class="literal">false</span>;</span><br><span class="line">  last_key_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">BlockBuilder::CurrentSizeEstimate</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (buffer_.<span class="built_in">size</span>() +                       <span class="comment">// Raw data buffer</span></span><br><span class="line">          restarts_.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>) +  <span class="comment">// Restart array</span></span><br><span class="line">          <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>));                     <span class="comment">// Restart array length</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Slice <span class="title">BlockBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Append restart array</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; restarts_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in">PutFixed32</span>(&amp;buffer_, restarts_[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">PutFixed32</span>(&amp;buffer_, restarts_.<span class="built_in">size</span>());</span><br><span class="line">  finished_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Slice</span>(buffer_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="function">Slice <span class="title">last_key_piece</span><span class="params">(last_key_)</span></span>;</span><br><span class="line">  <span class="built_in">assert</span>(!finished_);</span><br><span class="line">  <span class="built_in">assert</span>(counter_ &lt;= options_-&gt;block_restart_interval);</span><br><span class="line">  <span class="built_in">assert</span>(buffer_.<span class="built_in">empty</span>()  <span class="comment">// No values yet?</span></span><br><span class="line">         || options_-&gt;comparator-&gt;<span class="built_in">Compare</span>(key, last_key_piece) &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">size_t</span> shared = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;</span><br><span class="line">    <span class="comment">// See how much sharing to do with previous string</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> min_length = std::<span class="built_in">min</span>(last_key_piece.<span class="built_in">size</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;</span><br><span class="line">      shared++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Restart compression</span></span><br><span class="line">    restarts_.<span class="built_in">push_back</span>(buffer_.<span class="built_in">size</span>());</span><br><span class="line">    counter_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> non_shared = key.<span class="built_in">size</span>() - shared;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add &quot;&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&quot; to buffer_</span></span><br><span class="line">  <span class="built_in">PutVarint32</span>(&amp;buffer_, shared);</span><br><span class="line">  <span class="built_in">PutVarint32</span>(&amp;buffer_, non_shared);</span><br><span class="line">  <span class="built_in">PutVarint32</span>(&amp;buffer_, value.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add string delta to buffer_ followed by value</span></span><br><span class="line">  buffer_.<span class="built_in">append</span>(key.<span class="built_in">data</span>() + shared, non_shared);</span><br><span class="line">  buffer_.<span class="built_in">append</span>(value.<span class="built_in">data</span>(), value.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update state</span></span><br><span class="line">  last_key_.<span class="built_in">resize</span>(shared);</span><br><span class="line">  last_key_.<span class="built_in">append</span>(key.<span class="built_in">data</span>() + shared, non_shared);</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Slice</span>(last_key_) == key);</span><br><span class="line">  counter_++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p>文件头部的英文注释写得十分详细。为了节约空间，<code>LevelDB</code> 存储键值对时，会利用局部性原理，将省略掉键与上一个键的共同前缀部分。存储一键值对时，按照下面的方式存储：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shared_bytes: varint32           # Key 与上一个键共享的长度</span><br><span class="line">unshared_bytes: varint32         # Key 非共享长度</span><br><span class="line">value_length: varint32           # Value 的长度</span><br><span class="line">key_delta: char[unshared_bytes]  # Key 非共享部分</span><br><span class="line">value: char[value_length]        # Value</span><br></pre></td></tr></table></figure>

<p>省略前缀节约了空间，但就无法方便地执行二分查找了。LevelDB 的解决方案是每隔 <code>K=16</code> 个键值队设定一个复活点（没错想想超级玛丽的复活点），复活点上将完整存储键、不进行前缀共享。<code>Block</code> 的结尾存储所有复活点的位置，查找时先在复活点上做二分查找，确定大概位置后再遍历恢复 Key 后对比。为了更好地表达这件事，这里画个表：</p>
<table>
<thead>
<tr>
<th>Original Key</th>
<th>Shared</th>
<th>Unshared</th>
<th>Key Delta</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Abel</strong></td>
<td><strong>0</strong></td>
<td>4</td>
<td>Abel</td>
</tr>
<tr>
<td>Abner</td>
<td>2</td>
<td>3</td>
<td>ner</td>
</tr>
<tr>
<td>Abram</td>
<td>2</td>
<td>3</td>
<td>ram</td>
</tr>
<tr>
<td>Adam</td>
<td>1</td>
<td>3</td>
<td>dam</td>
</tr>
<tr>
<td><strong>Adelbert</strong></td>
<td><strong>0</strong></td>
<td>8</td>
<td>Adelbert</td>
</tr>
<tr>
<td>Adrian</td>
<td>2</td>
<td>4</td>
<td>rian</td>
</tr>
<tr>
<td>Alan</td>
<td>1</td>
<td>3</td>
<td>lan</td>
</tr>
<tr>
<td>Albert</td>
<td>2</td>
<td>4</td>
<td>bert</td>
</tr>
</tbody></table>
<p>这里使用的复活点间隔 <code>K=4</code>。使用该方案每个条目需要额外至少一个字节存储共享的长度 <code>shared</code>，但同时会节约 <code>shared</code> 个字节。上表中整体会节约 <code>2+2+1+2+1+2-8=2</code> 个字节。当需要读第八个键时，需要先读取前面最近的复活点 <code>Adelbert</code>，根据共享前缀恢复第六个键 <code>Ad + rian</code>，再恢复第七个键 <code>A + lan</code>，最后恢复 <code>Al + bert</code>。所以这里的 <code>K</code> 并不能取得过大。</p>
<p><code>BlockBuilder::Finish</code> 时，会将所有的复活点位置及复活点数量写到 <code>buffer_</code> 里，以实现解析。对应的解析代码位于 <a href="https://github.com/google/leveldb/blob/master/table/block.cc"><code>table/block.cc</code></a>，后续文章会再分析。</p>
<h3 id="3-Table-Builder"><a href="#3-Table-Builder" class="headerlink" title="3. Table Builder"></a>3. Table Builder</h3><p><code>TableBuilder</code> 的接口位于 <a href="https://github.com/google/leveldb/blob/master/include/leveldb/table_builder.h"><code>include/leveldb/table_builder.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TableBuilder provides the interface used to build a Table</span></span><br><span class="line"><span class="comment">// (an immutable and sorted map from keys to values).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Multiple threads can invoke const methods on a TableBuilder without</span></span><br><span class="line"><span class="comment">// external synchronization, but if any of the threads may call a</span></span><br><span class="line"><span class="comment">// non-const method, all threads accessing the same TableBuilder must use</span></span><br><span class="line"><span class="comment">// external synchronization.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STORAGE_LEVELDB_INCLUDE_TABLE_BUILDER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORAGE_LEVELDB_INCLUDE_TABLE_BUILDER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/export.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/options.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/status.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockBuilder</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockHandle</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WritableFile</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">TableBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a builder that will store the contents of the table it is</span></span><br><span class="line">  <span class="comment">// building in *file.  Does not close the file.  It is up to the</span></span><br><span class="line">  <span class="comment">// caller to close the file after calling Finish().</span></span><br><span class="line">  <span class="built_in">TableBuilder</span>(<span class="keyword">const</span> Options&amp; options, WritableFile* file);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TableBuilder</span>(<span class="keyword">const</span> TableBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  TableBuilder&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TableBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// REQUIRES: Either Finish() or Abandon() has been called.</span></span><br><span class="line">  ~<span class="built_in">TableBuilder</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Change the options used by this builder.  Note: only some of the</span></span><br><span class="line">  <span class="comment">// option fields can be changed after construction.  If a field is</span></span><br><span class="line">  <span class="comment">// not allowed to change dynamically and its value in the structure</span></span><br><span class="line">  <span class="comment">// passed to the constructor is different from its value in the</span></span><br><span class="line">  <span class="comment">// structure passed to this method, this method will return an error</span></span><br><span class="line">  <span class="comment">// without changing any fields.</span></span><br><span class="line">  <span class="function">Status <span class="title">ChangeOptions</span><span class="params">(<span class="keyword">const</span> Options&amp; options)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add key,value to the table being constructed.</span></span><br><span class="line">  <span class="comment">// REQUIRES: key is after any previously added key according to comparator.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Finish(), Abandon() have not been called</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Advanced operation: flush any buffered key/value pairs to file.</span></span><br><span class="line">  <span class="comment">// Can be used to ensure that two adjacent entries never live in</span></span><br><span class="line">  <span class="comment">// the same data block.  Most clients should not need to use this method.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Finish(), Abandon() have not been called</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return non-ok iff some error has been detected.</span></span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finish building the table.  Stops using the file passed to the</span></span><br><span class="line">  <span class="comment">// constructor after this function returns.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Finish(), Abandon() have not been called</span></span><br><span class="line">  <span class="function">Status <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Indicate that the contents of this builder should be abandoned.  Stops</span></span><br><span class="line">  <span class="comment">// using the file passed to the constructor after this function returns.</span></span><br><span class="line">  <span class="comment">// If the caller is not going to call Finish(), it must call Abandon()</span></span><br><span class="line">  <span class="comment">// before destroying this builder.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Finish(), Abandon() have not been called</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Abandon</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Number of calls to Add() so far.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">NumEntries</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Size of the file generated so far.  If invoked after a successful</span></span><br><span class="line">  <span class="comment">// Finish() call, returns the size of the final generated file.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">FileSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">status</span>().<span class="built_in">ok</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">WriteBlock</span><span class="params">(BlockBuilder* block, BlockHandle* handle)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">WriteRawBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; data, CompressionType, BlockHandle* handle)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Rep</span>;</span></span><br><span class="line">  Rep* rep_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// STORAGE_LEVELDB_INCLUDE_TABLE_BUILDER_H_</span></span></span><br></pre></td></tr></table></figure>

<p>接口代码里，LevelDB 都提供了详细的英文注释，不再赘述。这里刚好遇到 <code>pImpl</code> 范式，多说一点。对 C++ 来说，ABI 始终是一个痛点。Zero-Overhead 的 OOP，会把这部分 Overhead 加到编译期上。当一个类的数据成员发生变化时，会影响该类对象的大小和内存布局，进而导致所有依赖该类的文件需要重新编译。如果使用动态链接库，当版本升级、类发生变化时，由于 ABI 不兼容会导致无法直接替换动态链接库文件完成升级。而使用 <code>pImpl</code> 范式，将类的成员和类的声明隔离开，使用一个指针指向存储成员的对象 <code>rep_</code> 上。当成员发生变化时，也不需要重新编译，并且保证了 ABI 的稳定。该方案的缺点是访问成员时增加了一次指针寻址，不过瑕不掩瑜，和智能指针一样耗费微小的代价、带来极大的提升。LevelDB 的源代码中大量使用了该范式。接着看 <code>TableBuilder</code> 的实现 <a href="https://github.com/google/leveldb/blob/master/db/table_builder.cc"><code>table/table_builder.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TableBuilder</span>:</span>:Rep &#123;</span><br><span class="line">  <span class="built_in">Rep</span>(<span class="keyword">const</span> Options&amp; opt, WritableFile* f)</span><br><span class="line">      : <span class="built_in">options</span>(opt),</span><br><span class="line">        <span class="built_in">index_block_options</span>(opt),</span><br><span class="line">        <span class="built_in">file</span>(f),</span><br><span class="line">        <span class="built_in">offset</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">data_block</span>(&amp;options),</span><br><span class="line">        <span class="built_in">index_block</span>(&amp;index_block_options),</span><br><span class="line">        <span class="built_in">num_entries</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">closed</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">filter_block</span>(opt.filter_policy == <span class="literal">nullptr</span></span><br><span class="line">                         ? <span class="literal">nullptr</span></span><br><span class="line">                         : <span class="keyword">new</span> <span class="built_in">FilterBlockBuilder</span>(opt.filter_policy)),</span><br><span class="line">        <span class="built_in">pending_index_entry</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    index_block_options.block_restart_interval = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Options options;</span><br><span class="line">  Options index_block_options;</span><br><span class="line">  WritableFile* file;</span><br><span class="line">  <span class="keyword">uint64_t</span> offset;</span><br><span class="line">  Status status;</span><br><span class="line">  BlockBuilder data_block;</span><br><span class="line">  BlockBuilder index_block;</span><br><span class="line">  std::string last_key;</span><br><span class="line">  <span class="keyword">int64_t</span> num_entries;</span><br><span class="line">  <span class="keyword">bool</span> closed;  <span class="comment">// Either Finish() or Abandon() has been called.</span></span><br><span class="line">  FilterBlockBuilder* filter_block;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We do not emit the index entry for a block until we have seen the</span></span><br><span class="line">  <span class="comment">// first key for the next data block.  This allows us to use shorter</span></span><br><span class="line">  <span class="comment">// keys in the index block.  For example, consider a block boundary</span></span><br><span class="line">  <span class="comment">// between the keys &quot;the quick brown fox&quot; and &quot;the who&quot;.  We can use</span></span><br><span class="line">  <span class="comment">// &quot;the r&quot; as the key for the index block entry since it is &gt;= all</span></span><br><span class="line">  <span class="comment">// entries in the first block and &lt; all entries in subsequent</span></span><br><span class="line">  <span class="comment">// blocks.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Invariant: r-&gt;pending_index_entry is true only if data_block is empty.</span></span><br><span class="line">  <span class="keyword">bool</span> pending_index_entry;</span><br><span class="line">  BlockHandle pending_handle;  <span class="comment">// Handle to add to index block</span></span><br><span class="line"></span><br><span class="line">  std::string compressed_output;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TableBuilder::<span class="built_in">TableBuilder</span>(<span class="keyword">const</span> Options&amp; options, WritableFile* file)</span><br><span class="line">    : <span class="built_in">rep_</span>(<span class="keyword">new</span> <span class="built_in">Rep</span>(options, file)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    rep_-&gt;filter_block-&gt;<span class="built_in">StartBlock</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TableBuilder::~<span class="built_in">TableBuilder</span>() &#123;</span><br><span class="line">  <span class="built_in">assert</span>(rep_-&gt;closed);  <span class="comment">// Catch errors where caller forgot to call Finish()</span></span><br><span class="line">  <span class="keyword">delete</span> rep_-&gt;filter_block;</span><br><span class="line">  <span class="keyword">delete</span> rep_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TableBuilder::status</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep_-&gt;status; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">TableBuilder::NumEntries</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep_-&gt;num_entries; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">TableBuilder::FileSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep_-&gt;offset; &#125;</span><br></pre></td></tr></table></figure>

<p>首先是 <code>TableBuilder::Rep</code> 的定义。该定义位于 <code>.cc</code> 文件内，即使发生修改也仅仅会重新编译文件本身。<code>TableBuilder</code> 的构造函数中会初始化 <code>rep_</code> 对象，并且在析构函数中将 <code>rep_</code> 删除。而需要访问成员变量时，都需要使用 <code>rep_-&gt;</code> 进行多一次的寻址。</p>
<p><code>TableBuilder::rep_</code> 包含两个 <code>BlockBuilder</code> 对象，分别用来存储键值对数据和元数据。接下来是 <code>TableBuilder::Add</code> 等函数的实现。由于依赖的原因，这里需要先看 <a href="https://github.com/google/leveldb/blob/master/table/format.h"><code>table/format.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFile</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReadOptions</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BlockHandle is a pointer to the extent of a file that stores a data</span></span><br><span class="line"><span class="comment">// block or a meta block.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockHandle</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Maximum encoding length of a BlockHandle</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> kMaxEncodedLength = <span class="number">10</span> + <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">BlockHandle</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The offset of the block in the file.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">offset</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> offset_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_offset</span><span class="params">(<span class="keyword">uint64_t</span> offset)</span> </span>&#123; offset_ = offset; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The size of the stored block</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_size</span><span class="params">(<span class="keyword">uint64_t</span> size)</span> </span>&#123; size_ = size; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">EncodeTo</span><span class="params">(std::string* dst)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">Status <span class="title">DecodeFrom</span><span class="params">(Slice* input)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uint64_t</span> offset_;</span><br><span class="line">  <span class="keyword">uint64_t</span> size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Footer encapsulates the fixed information stored at the tail</span></span><br><span class="line"><span class="comment">// end of every table file.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Footer</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Encoded length of a Footer.  Note that the serialization of a</span></span><br><span class="line">  <span class="comment">// Footer will always occupy exactly this many bytes.  It consists</span></span><br><span class="line">  <span class="comment">// of two block handles and a magic number.</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> kEncodedLength = <span class="number">2</span> * BlockHandle::kMaxEncodedLength + <span class="number">8</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Footer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The block handle for the metaindex block of the table</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> BlockHandle&amp; <span class="title">metaindex_handle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> metaindex_handle_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_metaindex_handle</span><span class="params">(<span class="keyword">const</span> BlockHandle&amp; h)</span> </span>&#123; metaindex_handle_ = h; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The block handle for the index block of the table</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> BlockHandle&amp; <span class="title">index_handle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> index_handle_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_index_handle</span><span class="params">(<span class="keyword">const</span> BlockHandle&amp; h)</span> </span>&#123; index_handle_ = h; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">EncodeTo</span><span class="params">(std::string* dst)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">Status <span class="title">DecodeFrom</span><span class="params">(Slice* input)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  BlockHandle metaindex_handle_;</span><br><span class="line">  BlockHandle index_handle_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kTableMagicNumber was picked by running</span></span><br><span class="line"><span class="comment">//    echo http://code.google.com/p/leveldb/ | sha1sum</span></span><br><span class="line"><span class="comment">// and taking the leading 64 bits.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint64_t</span> kTableMagicNumber = <span class="number">0xdb4775248b80fb57</span>ull;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1-byte type + 32-bit crc</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kBlockTrailerSize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlockContents</span> &#123;</span></span><br><span class="line">  Slice data;           <span class="comment">// Actual contents of data</span></span><br><span class="line">  <span class="keyword">bool</span> cachable;        <span class="comment">// True iff data can be cached</span></span><br><span class="line">  <span class="keyword">bool</span> heap_allocated;  <span class="comment">// True iff caller should delete[] data.data()</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the block identified by &quot;handle&quot; from &quot;file&quot;.  On failure</span></span><br><span class="line"><span class="comment">// return non-OK.  On success fill *result and return OK.</span></span><br><span class="line"><span class="function">Status <span class="title">ReadBlock</span><span class="params">(RandomAccessFile* file, <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">const</span> BlockHandle&amp; handle, BlockContents* result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation details follow.  Clients should ignore,</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">BlockHandle::BlockHandle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    : offset_(~static_cast&lt;uint64_t&gt;(<span class="number">0</span>)), size_(~static_cast&lt;uint64_t&gt;(<span class="number">0</span>)) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>BlockBuilder</code> 将 Block 的数据写到字节流中，当需要进行解析时，必须知道其起始位置和长度，以便于读取复活点信息。故这里引入了 <code>BlockHandle</code>，存储 Block 数据所在的位置 <code>offset_</code> 和长度 <code>size_</code>。其 <code>EncodeTo</code> 和 <code>DecodeFrom</code> 函数的实现都非常简单，不再赘述。有了 <code>BlockHandle</code>，就可以读取对应的 <code>Block</code> 数据，<code>Footer</code> 就用来存储两个 <code>BlockHandle</code>。最后来看下 <code>TableBuilder</code> 的核心部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;num_entries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(r-&gt;options.comparator-&gt;<span class="built_in">Compare</span>(key, <span class="built_in">Slice</span>(r-&gt;last_key)) &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(r-&gt;data_block.<span class="built_in">empty</span>());</span><br><span class="line">    r-&gt;options.comparator-&gt;<span class="built_in">FindShortestSeparator</span>(&amp;r-&gt;last_key, key);</span><br><span class="line">    std::string handle_encoding;</span><br><span class="line">    r-&gt;pending_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">    r-&gt;index_block.<span class="built_in">Add</span>(r-&gt;last_key, <span class="built_in">Slice</span>(handle_encoding));</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    r-&gt;filter_block-&gt;<span class="built_in">AddKey</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  r-&gt;last_key.<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">  r-&gt;num_entries++;</span><br><span class="line">  r-&gt;data_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> estimated_block_size = r-&gt;data_block.<span class="built_in">CurrentSizeEstimate</span>();</span><br><span class="line">  <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">    <span class="built_in">Flush</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;pending_index_entry);</span><br><span class="line">  <span class="built_in">WriteBlock</span>(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    r-&gt;filter_block-&gt;<span class="built_in">StartBlock</span>(r-&gt;offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::WriteBlock</span><span class="params">(BlockBuilder* block, BlockHandle* handle)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// File format contains a sequence of blocks where each block has:</span></span><br><span class="line">  <span class="comment">//    block_data: uint8[n]</span></span><br><span class="line">  <span class="comment">//    type: uint8</span></span><br><span class="line">  <span class="comment">//    crc: uint32</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">ok</span>());</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  Slice raw = block-&gt;<span class="built_in">Finish</span>();</span><br><span class="line"></span><br><span class="line">  Slice block_contents;</span><br><span class="line">  CompressionType type = r-&gt;options.compression;</span><br><span class="line">  <span class="comment">// TODO(postrelease): Support more compression options: zlib?</span></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> kNoCompression:</span><br><span class="line">      block_contents = raw;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> kSnappyCompression: &#123;</span><br><span class="line">      std::string* compressed = &amp;r-&gt;compressed_output;</span><br><span class="line">      <span class="keyword">if</span> (port::<span class="built_in">Snappy_Compress</span>(raw.<span class="built_in">data</span>(), raw.<span class="built_in">size</span>(), compressed) &amp;&amp;</span><br><span class="line">          compressed-&gt;<span class="built_in">size</span>() &lt; raw.<span class="built_in">size</span>() - (raw.<span class="built_in">size</span>() / <span class="number">8u</span>)) &#123;</span><br><span class="line">        block_contents = *compressed;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Snappy not supported, or compressed less than 12.5%, so just</span></span><br><span class="line">        <span class="comment">// store uncompressed form</span></span><br><span class="line">        block_contents = raw;</span><br><span class="line">        type = kNoCompression;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">WriteRawBlock</span>(block_contents, type, handle);</span><br><span class="line">  r-&gt;compressed_output.<span class="built_in">clear</span>();</span><br><span class="line">  block-&gt;<span class="built_in">Reset</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::WriteRawBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 CompressionType type, BlockHandle* handle)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  handle-&gt;<span class="built_in">set_offset</span>(r-&gt;offset);</span><br><span class="line">  handle-&gt;<span class="built_in">set_size</span>(block_contents.<span class="built_in">size</span>());</span><br><span class="line">  r-&gt;status = r-&gt;file-&gt;<span class="built_in">Append</span>(block_contents);</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">char</span> trailer[kBlockTrailerSize];</span><br><span class="line">    trailer[<span class="number">0</span>] = type;</span><br><span class="line">    <span class="keyword">uint32_t</span> crc = crc32c::<span class="built_in">Value</span>(block_contents.<span class="built_in">data</span>(), block_contents.<span class="built_in">size</span>());</span><br><span class="line">    crc = crc32c::<span class="built_in">Extend</span>(crc, trailer, <span class="number">1</span>);  <span class="comment">// Extend crc to cover block type</span></span><br><span class="line">    <span class="built_in">EncodeFixed32</span>(trailer + <span class="number">1</span>, crc32c::<span class="built_in">Mask</span>(crc));</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(trailer, kBlockTrailerSize));</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      r-&gt;offset += block_contents.<span class="built_in">size</span>() + kBlockTrailerSize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">  r-&gt;closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write filter block</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">WriteRawBlock</span>(r-&gt;filter_block-&gt;<span class="built_in">Finish</span>(), kNoCompression,</span><br><span class="line">                  &amp;filter_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write metaindex block</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// Add mapping from &quot;filter.Name&quot; to location of filter data</span></span><br><span class="line">      std::string key = <span class="string">&quot;filter.&quot;</span>;</span><br><span class="line">      key.<span class="built_in">append</span>(r-&gt;options.filter_policy-&gt;<span class="built_in">Name</span>());</span><br><span class="line">      std::string handle_encoding;</span><br><span class="line">      filter_block_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">      meta_index_block.<span class="built_in">Add</span>(key, handle_encoding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></span><br><span class="line">    <span class="built_in">WriteBlock</span>(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write index block</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">      r-&gt;options.comparator-&gt;<span class="built_in">FindShortSuccessor</span>(&amp;r-&gt;last_key);</span><br><span class="line">      std::string handle_encoding;</span><br><span class="line">      r-&gt;pending_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">      r-&gt;index_block.<span class="built_in">Add</span>(r-&gt;last_key, <span class="built_in">Slice</span>(handle_encoding));</span><br><span class="line">      r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">WriteBlock</span>(&amp;r-&gt;index_block, &amp;index_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write footer</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    Footer footer;</span><br><span class="line">    footer.<span class="built_in">set_metaindex_handle</span>(metaindex_block_handle);</span><br><span class="line">    footer.<span class="built_in">set_index_handle</span>(index_block_handle);</span><br><span class="line">    std::string footer_encoding;</span><br><span class="line">    footer.<span class="built_in">EncodeTo</span>(&amp;footer_encoding);</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;<span class="built_in">Append</span>(footer_encoding);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      r-&gt;offset += footer_encoding.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r-&gt;status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次执行 <code>Add</code> 操作时，会将键值对写入 <code>data_block_</code> 中；当 <code>data_block_</code> 的大小超过阈值时（默认 4KB），将会把该 Block 写入文件，并将 Block 的 <code>last_key</code> 作为 <code>Key</code>，将 <code>offset</code> 和 <code>size</code> 信息作为 <code>Value</code> 加入到 <code>index_block_</code> 中。当执行 <code>TableBuilder::Finish</code> 操作时，会将 <code>index_block_</code> 也写入文件，其对应的 <code>index_block_handle_</code> 写到最后的 <code>Footer</code> 里。这样就完成了 Sorted Table 文件的构建。</p>
<p>反推回来，当需要读取一个 Sorted Table 文件时，首先读取文件末尾的 Footer，根据存储的 Index Block Handle 可以读取到每个 Data Block 对应的 Data Block Handler 信息，进而读取到对应的 Data Block。读取的详细过程将在下一篇博文中分析。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>TableBuilder</code> 建好 Sorted Table 后，存储为后缀 <code>.ldb</code> 的物理文件，并且将其加入版本管理中。Sorted Table 建好后是不可修改的，进而可以很好地支持并发访问，并且对缓存友好。</p>
<p>题外话：Sorted Table 本来存储的文件文件格式是 <code>.sst</code>，但后来由于 <a href="https://groups.google.com/forum/#!topic/leveldb/u9izbG-pDis">Windows 系统的原因</a>，LevelDB 将后缀改为 <code>.ldb</code>，不过仍然保持着对 <code>.sst</code> 的兼容。</p>
<p>关于PImpl机制与C++ ABI的内容可见：</p>
<p>1.<a href="https://blog.csdn.net/sesiria/article/details/51555811">PImpl机制</a></p>
<p>2.<a href="https://blog.csdn.net/absurd/article/details/930158">C++ ABI</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码分析——7.Sorted String Table续</title>
    <url>/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%947.Sorted%20String%20Table%E7%BB%AD/</url>
    <content><![CDATA[<h2 id="七-Sorted-String-Table续"><a href="#七-Sorted-String-Table续" class="headerlink" title="七.Sorted String Table续"></a>七.Sorted String Table续</h2><p>本系列的上一篇介绍了 Sorted Table 的构建过程，本篇就继续分析 Sorted Table 的读取、解析过程。</p>
<h3 id="4-Block"><a href="#4-Block" class="headerlink" title="4. Block"></a>4. Block</h3><p>根据依赖关系，首先来看 <a href="https://github.com/google/leveldb/blob/master/table/format.cc"><code>table/format.cc</code></a> 中 <code>ReadBlock</code> 函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlockContents</span> &#123;</span></span><br><span class="line">  Slice data;           <span class="comment">// Actual contents of data</span></span><br><span class="line">  <span class="keyword">bool</span> cachable;        <span class="comment">// True iff data can be cached</span></span><br><span class="line">  <span class="keyword">bool</span> heap_allocated;  <span class="comment">// True iff caller should delete[] data.data()</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the block identified by &quot;handle&quot; from &quot;file&quot;.  On failure</span></span><br><span class="line"><span class="comment">// return non-OK.  On success fill *result and return OK.</span></span><br><span class="line"><span class="function">Status <span class="title">ReadBlock</span><span class="params">(RandomAccessFile* file, <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">const</span> BlockHandle&amp; handle, BlockContents* result)</span> </span>&#123;</span><br><span class="line">  result-&gt;data = <span class="built_in">Slice</span>();</span><br><span class="line">  result-&gt;cachable = <span class="literal">false</span>;</span><br><span class="line">  result-&gt;heap_allocated = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read the block contents as well as the type/crc footer.</span></span><br><span class="line">  <span class="comment">// See table_builder.cc for the code that built this structure.</span></span><br><span class="line">  <span class="keyword">size_t</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(handle.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">char</span>[n + kBlockTrailerSize];</span><br><span class="line">  Slice contents;</span><br><span class="line">  Status s = file-&gt;<span class="built_in">Read</span>(handle.<span class="built_in">offset</span>(), n + kBlockTrailerSize, &amp;contents, buf);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (contents.<span class="built_in">size</span>() != n + kBlockTrailerSize) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;truncated block read&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check the crc of the type and the block contents</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data = contents.<span class="built_in">data</span>();  <span class="comment">// Pointer to where Read put the data</span></span><br><span class="line">  <span class="keyword">if</span> (options.verify_checksums) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> crc = crc32c::<span class="built_in">Unmask</span>(<span class="built_in">DecodeFixed32</span>(data + n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> actual = crc32c::<span class="built_in">Value</span>(data, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (actual != crc) &#123;</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;block checksum mismatch&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (data[n]) &#123;</span><br><span class="line">    <span class="keyword">case</span> kNoCompression:</span><br><span class="line">      <span class="keyword">if</span> (data != buf) &#123;</span><br><span class="line">        <span class="comment">// File implementation gave us pointer to some other data.</span></span><br><span class="line">        <span class="comment">// Use it directly under the assumption that it will be live</span></span><br><span class="line">        <span class="comment">// while the file is open.</span></span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        result-&gt;data = <span class="built_in">Slice</span>(data, n);</span><br><span class="line">        result-&gt;heap_allocated = <span class="literal">false</span>;</span><br><span class="line">        result-&gt;cachable = <span class="literal">false</span>;  <span class="comment">// Do not double-cache</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result-&gt;data = <span class="built_in">Slice</span>(buf, n);</span><br><span class="line">        result-&gt;heap_allocated = <span class="literal">true</span>;</span><br><span class="line">        result-&gt;cachable = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ok</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kSnappyCompression: &#123;</span><br><span class="line">      <span class="keyword">size_t</span> ulength = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (!port::<span class="built_in">Snappy_GetUncompressedLength</span>(data, n, &amp;ulength)) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;corrupted compressed block contents&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">char</span>* ubuf = <span class="keyword">new</span> <span class="keyword">char</span>[ulength];</span><br><span class="line">      <span class="keyword">if</span> (!port::<span class="built_in">Snappy_Uncompress</span>(data, n, ubuf)) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        <span class="keyword">delete</span>[] ubuf;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;corrupted compressed block contents&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      result-&gt;data = <span class="built_in">Slice</span>(ubuf, ulength);</span><br><span class="line">      result-&gt;heap_allocated = <span class="literal">true</span>;</span><br><span class="line">      result-&gt;cachable = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad block type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于已经存储的 Sorted Table 文件，提供 <code>ReadOptions</code> 和 <code>BlockHandle</code> 后，可以将 <code>handle</code> 对应的 Block 内容读取到 <code>BlockContents</code> 中。该结构体储存 Block 的字节流，以及能否缓存、是否需要手动清理的标记。<code>ReadBlock</code> 的实现非常直接，读取文件对应位置的字节流，进行必要的校验和解压缩。继续看 <code>Block</code> 的解析部分 <a href="https://github.com/google/leveldb/blob/master/table/block.h"><code>table/block.h</code></a> ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlockContents</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize the block with the specified contents.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Block</span><span class="params">(<span class="keyword">const</span> BlockContents&amp; contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Block</span>(<span class="keyword">const</span> Block&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Block&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Block&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Block</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">(<span class="keyword">const</span> Comparator* comparator)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iter</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">NumRestarts</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;</span><br><span class="line">  <span class="keyword">size_t</span> size_;</span><br><span class="line">  <span class="keyword">uint32_t</span> restart_offset_;  <span class="comment">// Offset in data_ of restart array</span></span><br><span class="line">  <span class="keyword">bool</span> owned_;               <span class="comment">// Block owns data_[]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接口的核心部分自然是迭代器。迭代器提供 Block 中键值对数据的遍历和查找。继续看对应函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">Block::NumRestarts</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(size_ &gt;= <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">DecodeFixed32</span>(data_ + size_ - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Block::<span class="built_in">Block</span>(<span class="keyword">const</span> BlockContents&amp; contents)</span><br><span class="line">    : <span class="built_in">data_</span>(contents.data.<span class="built_in">data</span>()),</span><br><span class="line">      <span class="built_in">size_</span>(contents.data.<span class="built_in">size</span>()),</span><br><span class="line">      <span class="built_in">owned_</span>(contents.heap_allocated) &#123;</span><br><span class="line">  <span class="keyword">if</span> (size_ &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>)) &#123;</span><br><span class="line">    size_ = <span class="number">0</span>;  <span class="comment">// Error marker</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">size_t</span> max_restarts_allowed = (size_ - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>)) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NumRestarts</span>() &gt; max_restarts_allowed) &#123;</span><br><span class="line">      <span class="comment">// The size is too small for NumRestarts()</span></span><br><span class="line">      size_ = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      restart_offset_ = size_ - (<span class="number">1</span> + <span class="built_in">NumRestarts</span>()) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Block::~<span class="built_in">Block</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (owned_) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] data_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper routine: decode the next block entry starting at &quot;p&quot;,</span></span><br><span class="line"><span class="comment">// storing the number of shared key bytes, non_shared key bytes,</span></span><br><span class="line"><span class="comment">// and the length of the value in &quot;*shared&quot;, &quot;*non_shared&quot;, and</span></span><br><span class="line"><span class="comment">// &quot;*value_length&quot;, respectively.  Will not dereference past &quot;limit&quot;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If any errors are detected, returns nullptr.  Otherwise, returns a</span></span><br><span class="line"><span class="comment">// pointer to the key delta (just past the three decoded values).</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">DecodeEntry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">uint32_t</span>* shared, <span class="keyword">uint32_t</span>* non_shared,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">uint32_t</span>* value_length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (limit - p &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  *shared = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p)[<span class="number">0</span>];</span><br><span class="line">  *non_shared = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p)[<span class="number">1</span>];</span><br><span class="line">  *value_length = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p)[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> ((*shared | *non_shared | *value_length) &lt; <span class="number">128</span>) &#123;</span><br><span class="line">    <span class="comment">// Fast path: all three values are encoded in one byte each</span></span><br><span class="line">    p += <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, shared)) == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, non_shared)) == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, value_length)) == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(limit - p) &lt; (*non_shared + *value_length)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照之前描述的 Block 存储结构，最后 4 字节存储复活点的数量，如 <code>NumRestarts</code> 实现。构造时进行必要的判断，在 <code>restart_offset_</code> 中存储复活点列表的位置。解析条目时，首先假设 <code>shared</code>、<code>non_shared</code> 和 <code>value_length</code> 都小于 128，尝试按照按字节读取长度以提高解析速度。在大部分情况下该规则都是满足的，当少数情况出现超长的串时，会回退到普通的 <code>GetVarint32Ptr</code>。继续看迭代器的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span>:</span>:Iter : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> Comparator* <span class="keyword">const</span> comparator_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> data_;       <span class="comment">// underlying block contents</span></span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="keyword">const</span> restarts_;      <span class="comment">// Offset of restart array (list of fixed32)</span></span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="keyword">const</span> num_restarts_;  <span class="comment">// Number of uint32_t entries in restart array</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// current_ is offset in data_ of current entry.  &gt;= restarts_ if !Valid</span></span><br><span class="line">  <span class="keyword">uint32_t</span> current_;</span><br><span class="line">  <span class="keyword">uint32_t</span> restart_index_;  <span class="comment">// Index of restart block in which current_ falls</span></span><br><span class="line">  std::string key_;</span><br><span class="line">  Slice value_;</span><br><span class="line">  Status status_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; a, <span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparator_-&gt;<span class="built_in">Compare</span>(a, b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the offset in data_ just past the end of the current entry.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">NextEntryOffset</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value_.<span class="built_in">data</span>() + value_.<span class="built_in">size</span>()) - data_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">GetRestartPoint</span><span class="params">(<span class="keyword">uint32_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(index &lt; num_restarts_);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DecodeFixed32</span>(data_ + restarts_ + index * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToRestartPoint</span><span class="params">(<span class="keyword">uint32_t</span> index)</span> </span>&#123;</span><br><span class="line">    key_.<span class="built_in">clear</span>();</span><br><span class="line">    restart_index_ = index;</span><br><span class="line">    <span class="comment">// current_ will be fixed by ParseNextKey();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ParseNextKey() starts at the end of value_, so set value_ accordingly</span></span><br><span class="line">    <span class="keyword">uint32_t</span> offset = <span class="built_in">GetRestartPoint</span>(index);</span><br><span class="line">    value_ = <span class="built_in">Slice</span>(data_ + offset, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Iter</span>(<span class="keyword">const</span> Comparator* comparator, <span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">uint32_t</span> restarts,</span><br><span class="line">       <span class="keyword">uint32_t</span> num_restarts)</span><br><span class="line">      : <span class="built_in">comparator_</span>(comparator),</span><br><span class="line">        <span class="built_in">data_</span>(data),</span><br><span class="line">        <span class="built_in">restarts_</span>(restarts),</span><br><span class="line">        <span class="built_in">num_restarts_</span>(num_restarts),</span><br><span class="line">        <span class="built_in">current_</span>(restarts_),</span><br><span class="line">        <span class="built_in">restart_index_</span>(num_restarts_) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(num_restarts_ &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> current_ &lt; restarts_; &#125;</span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> status_; &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> key_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> value_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="built_in">ParseNextKey</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan backwards to a restart point before current_</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> original = current_;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetRestartPoint</span>(restart_index_) &gt;= original) &#123;</span><br><span class="line">      <span class="keyword">if</span> (restart_index_ == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// No more entries</span></span><br><span class="line">        current_ = restarts_;</span><br><span class="line">        restart_index_ = num_restarts_;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      restart_index_--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SeekToRestartPoint</span>(restart_index_);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// Loop until end of current entry hits the start of original entry</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">ParseNextKey</span>() &amp;&amp; <span class="built_in">NextEntryOffset</span>() &lt; original);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SeekToRestartPoint</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ParseNextKey</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SeekToRestartPoint</span>(num_restarts_ - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">ParseNextKey</span>() &amp;&amp; <span class="built_in">NextEntryOffset</span>() &lt; restarts_) &#123;</span><br><span class="line">      <span class="comment">// Keep skipping</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CorruptionError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    current_ = restarts_;</span><br><span class="line">    restart_index_ = num_restarts_;</span><br><span class="line">    status_ = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad entry in block&quot;</span>);</span><br><span class="line">    key_.<span class="built_in">clear</span>();</span><br><span class="line">    value_.<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ParseNextKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    current_ = <span class="built_in">NextEntryOffset</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p = data_ + current_;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* limit = data_ + restarts_;  <span class="comment">// Restarts come right after data</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= limit) &#123;</span><br><span class="line">      <span class="comment">// No more entries to return.  Mark as invalid.</span></span><br><span class="line">      current_ = restarts_;</span><br><span class="line">      restart_index_ = num_restarts_;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode next entry</span></span><br><span class="line">    <span class="keyword">uint32_t</span> shared, non_shared, value_length;</span><br><span class="line">    p = <span class="built_in">DecodeEntry</span>(p, limit, &amp;shared, &amp;non_shared, &amp;value_length);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || key_.<span class="built_in">size</span>() &lt; shared) &#123;</span><br><span class="line">      <span class="built_in">CorruptionError</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      key_.<span class="built_in">resize</span>(shared);</span><br><span class="line">      key_.<span class="built_in">append</span>(p, non_shared);</span><br><span class="line">      value_ = <span class="built_in">Slice</span>(p + non_shared, value_length);</span><br><span class="line">      <span class="keyword">while</span> (restart_index_ + <span class="number">1</span> &lt; num_restarts_ &amp;&amp;</span><br><span class="line">             <span class="built_in">GetRestartPoint</span>(restart_index_ + <span class="number">1</span>) &lt; current_) &#123;</span><br><span class="line">        ++restart_index_;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">Block::NewIterator</span><span class="params">(<span class="keyword">const</span> Comparator* comparator)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size_ &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewErrorIterator</span>(Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad block contents&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> num_restarts = <span class="built_in">NumRestarts</span>();</span><br><span class="line">  <span class="keyword">if</span> (num_restarts == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewEmptyIterator</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Iter</span>(comparator, data_, restart_offset_, num_restarts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看成员变量：</p>
<ol>
<li>Block 的字节流存储于 <code>data_</code> 中；</li>
<li><code>restarts_</code> 和 <code>num_restarts_</code> 存储复活点列表的偏移和数量；</li>
<li><code>current_</code> 存储当前迭代器的偏移，<code>restart_index_</code> 存储 <code>current_</code> 前面最近的复活点偏移；</li>
<li><code>key_</code> 和 <code>value_</code> 存储键值对。注意 <code>key_</code> 是 <code>std::string</code>，因为有共享前缀，需要存储中间恢复的 <code>Key</code>，而 <code>value_</code> 可以直接从 <code>data_</code> 中截取。</li>
</ol>
<p>函数 <code>NextEntryOffset</code> 根据当前的 <code>value</code> 的位置和大小计算下一个键值对的起始位置，因为每个条目最后存储的是 <code>value</code>。函数 <code>GetRestartPoint</code> 读取第 <code>index</code> 个复活点的位置，函数 <code>SeekToRestartPoint</code> 将当前的 <code>key_</code> 清空、设定 <code>restart_index_</code> 并将 <code>value_</code> 设为复活点前的空串，以便于执行 <code>NextEntryOffset</code> 时获得对应复活点偏移。跳到函数 <code>ParseNextKey</code>，将 <code>current_</code> 设为下一个键值对的起点，通过 <code>DecodeEntry</code> 解析得到需要的长度信息，恢复 <code>key_</code> 并读取 <code>value_</code>。</p>
<p>迭代器存储的状态信息包括 <code>key_</code> 存储的共享前缀，和 <code>value_</code> 存储的下个条目起点。当发生起始点的切换时，需要先执行函数 <code>SeekToRestartPoint</code> 清空当前存储的状态信息，再执行函数 <code>ParseNextKey</code> 解析下一个键值对。按照这个过程读函数 <code>Prev</code>、<code>SeekToFirst</code> 和 <code>SeekToLast</code> 就非常轻松了。最后来看函数 <code>Seek</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Binary search in restart array to find the last restart point</span></span><br><span class="line">  <span class="comment">// with a key &lt; target</span></span><br><span class="line">  <span class="keyword">uint32_t</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> right = num_restarts_ - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> region_offset = <span class="built_in">GetRestartPoint</span>(mid);</span><br><span class="line">    <span class="keyword">uint32_t</span> shared, non_shared, value_length;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr =</span><br><span class="line">      <span class="built_in">DecodeEntry</span>(data_ + region_offset, data_ + restarts_, &amp;shared,</span><br><span class="line">                  &amp;non_shared, &amp;value_length);</span><br><span class="line">    <span class="keyword">if</span> (key_ptr == <span class="literal">nullptr</span> || (shared != <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="built_in">CorruptionError</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Slice <span class="title">mid_key</span><span class="params">(key_ptr, non_shared)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Compare</span>(mid_key, target) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Key at &quot;mid&quot; is smaller than &quot;target&quot;.  Therefore all</span></span><br><span class="line">      <span class="comment">// blocks before &quot;mid&quot; are uninteresting.</span></span><br><span class="line">      left = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Key at &quot;mid&quot; is &gt;= &quot;target&quot;.  Therefore all blocks at or</span></span><br><span class="line">      <span class="comment">// after &quot;mid&quot; are uninteresting.</span></span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linear search (within restart block) for first key &gt;= target</span></span><br><span class="line">  <span class="built_in">SeekToRestartPoint</span>(left);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ParseNextKey</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Compare</span>(key_, target) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在复活点上做二分查找，这里实现的二分查找的结果就是 <code>left</code> 对应的复活点 <code>Key</code> 是严格小于 <code>target</code> 的最大 <code>Key</code>。二分查找完成后跳到复活点处，按顺序恢复每个条目的键值，对比返回。</p>
<p>最后来看一个细节：<code>restart_index_</code> 只会在函数 <code>Prev</code> 里读取到，以确定上一个复活点的位置。如果仔细观察函数 <code>ParseNextKey</code> 中关于 <code>restart_index_</code> 的更新：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (restart_index_ + <span class="number">1</span> &lt; num_restarts_ &amp;&amp;</span><br><span class="line">       <span class="built_in">GetRestartPoint</span>(restart_index_ + <span class="number">1</span>) &lt; current_) &#123;</span><br><span class="line">  ++restart_index_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这里 <code>current_</code> 刚好到达复活点 <code>i</code>，<code>restart_index_</code> 仍然会保持在 <code>i - 1</code> 的，这样在执行 <code>Prev</code> 时 <code>while</code> 循环可以少做一次。Google 大佬实力可见一斑。但从语义的角度，这种做法比较容易让人困惑，我应该不会这么做（所以成不了 Google 大佬。</p>
<h3 id="5-迭代器链"><a href="#5-迭代器链" class="headerlink" title="5. 迭代器链"></a>5. 迭代器链</h3><p>上一节中分析了 Block 的迭代器实现，而对一个 Sorted Table 来说，还需要其他几种迭代器共同组成迭代器链，以高效地完成对 Sorted Table 的遍历和查找。首先来看 <code>IteratorWrapper</code> 的实现 <a href="https://github.com/google/leveldb/blob/master/table/iterator_wrapper.h"><code>table/iterator_wrapper</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A internal wrapper class with an interface similar to Iterator that</span></span><br><span class="line"><span class="comment">// caches the valid() and key() results for an underlying iterator.</span></span><br><span class="line"><span class="comment">// This can help avoid virtual function calls and also gives better</span></span><br><span class="line"><span class="comment">// cache locality.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorWrapper</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">IteratorWrapper</span>() : <span class="built_in">iter_</span>(<span class="literal">nullptr</span>), <span class="built_in">valid_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">IteratorWrapper</span><span class="params">(Iterator* iter)</span> : iter_(nullptr) &#123;</span> <span class="built_in">Set</span>(iter); &#125;</span><br><span class="line">  ~<span class="built_in">IteratorWrapper</span>() &#123; <span class="keyword">delete</span> iter_; &#125;</span><br><span class="line">  <span class="function">Iterator* <span class="title">iter</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> iter_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Takes ownership of &quot;iter&quot; and will delete it when destroyed, or</span></span><br><span class="line">  <span class="comment">// when Set() is invoked again.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(Iterator* iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> iter_;</span><br><span class="line">    iter_ = iter;</span><br><span class="line">    <span class="keyword">if</span> (iter_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      valid_ = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">Update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterator interface methods</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> valid_; &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> key_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> iter_-&gt;<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Methods below require iter() != nullptr</span></span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    <span class="keyword">return</span> iter_-&gt;<span class="built_in">status</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">Prev</span>();</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">Seek</span>(k);</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">SeekToFirst</span>();</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">SeekToLast</span>();</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    valid_ = iter_-&gt;<span class="built_in">Valid</span>();</span><br><span class="line">    <span class="keyword">if</span> (valid_) &#123;</span><br><span class="line">      key_ = iter_-&gt;<span class="built_in">key</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Iterator* iter_;</span><br><span class="line">  <span class="keyword">bool</span> valid_;</span><br><span class="line">  Slice key_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代器的简单包装，缓存了 <code>key_</code> 和 <code>valid_</code> 属性。按照注释所说的，可以减少虚函数的调用，并且提供更好的缓存局部性。前者很好理解，后者仍然有些困惑。接着来看二级迭代器 <code>TwoLevelIterator</code> 的实现 <a href="https://github.com/google/leveldb/blob/master/table/two_level_iterator.cc"><code>table/two_level_iterator.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/table.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;table/block.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;table/format.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;table/iterator_wrapper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Iterator* (*BlockFunction)(<span class="keyword">void</span>*, <span class="keyword">const</span> ReadOptions&amp;, <span class="keyword">const</span> Slice&amp;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoLevelIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TwoLevelIterator</span>(Iterator* index_iter, BlockFunction block_function,</span><br><span class="line">                   <span class="keyword">void</span>* arg, <span class="keyword">const</span> ReadOptions&amp; options);</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">TwoLevelIterator</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> data_iter_.<span class="built_in">Valid</span>(); &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> data_iter_.<span class="built_in">key</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> data_iter_.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// It&#x27;d be nice if status() returned a const Status&amp; instead of a Status</span></span><br><span class="line">    <span class="keyword">if</span> (!index_iter_.<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> index_iter_.<span class="built_in">status</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span> &amp;&amp; !data_iter_.<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> data_iter_.<span class="built_in">status</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> status_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SaveError</span><span class="params">(<span class="keyword">const</span> Status&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status_.<span class="built_in">ok</span>() &amp;&amp; !s.<span class="built_in">ok</span>()) status_ = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SkipEmptyDataBlocksForward</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SkipEmptyDataBlocksBackward</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetDataIterator</span><span class="params">(Iterator* data_iter)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">InitDataBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  BlockFunction block_function_;</span><br><span class="line">  <span class="keyword">void</span>* arg_;</span><br><span class="line">  <span class="keyword">const</span> ReadOptions options_;</span><br><span class="line">  Status status_;</span><br><span class="line">  IteratorWrapper index_iter_;</span><br><span class="line">  IteratorWrapper data_iter_;  <span class="comment">// May be nullptr</span></span><br><span class="line">  <span class="comment">// If data_iter_ is non-null, then &quot;data_block_handle_&quot; holds the</span></span><br><span class="line">  <span class="comment">// &quot;index_value&quot; passed to block_function_ to create the data_iter_.</span></span><br><span class="line">  std::string data_block_handle_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TwoLevelIterator::<span class="built_in">TwoLevelIterator</span>(Iterator* index_iter,</span><br><span class="line">                                   BlockFunction block_function, <span class="keyword">void</span>* arg,</span><br><span class="line">                                   <span class="keyword">const</span> ReadOptions&amp; options)</span><br><span class="line">    : <span class="built_in">block_function_</span>(block_function),</span><br><span class="line">      <span class="built_in">arg_</span>(arg),</span><br><span class="line">      <span class="built_in">options_</span>(options),</span><br><span class="line">      <span class="built_in">index_iter_</span>(index_iter),</span><br><span class="line">      <span class="built_in">data_iter_</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">TwoLevelIterator::~<span class="built_in">TwoLevelIterator</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> </span>&#123;</span><br><span class="line">  index_iter_.<span class="built_in">Seek</span>(target);</span><br><span class="line">  <span class="built_in">InitDataBlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">Seek</span>(target);</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksForward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SeekToFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  index_iter_.<span class="built_in">SeekToFirst</span>();</span><br><span class="line">  <span class="built_in">InitDataBlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">SeekToFirst</span>();</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksForward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SeekToLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  index_iter_.<span class="built_in">SeekToLast</span>();</span><br><span class="line">  <span class="built_in">InitDataBlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">SeekToLast</span>();</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksBackward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">  data_iter_.<span class="built_in">Next</span>();</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksForward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::Prev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">  data_iter_.<span class="built_in">Prev</span>();</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksBackward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SkipEmptyDataBlocksForward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (data_iter_.<span class="built_in">iter</span>() == <span class="literal">nullptr</span> || !data_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="comment">// Move to next block</span></span><br><span class="line">    <span class="keyword">if</span> (!index_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="built_in">SetDataIterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index_iter_.<span class="built_in">Next</span>();</span><br><span class="line">    <span class="built_in">InitDataBlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">SeekToFirst</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SkipEmptyDataBlocksBackward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (data_iter_.<span class="built_in">iter</span>() == <span class="literal">nullptr</span> || !data_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="comment">// Move to next block</span></span><br><span class="line">    <span class="keyword">if</span> (!index_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="built_in">SetDataIterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index_iter_.<span class="built_in">Prev</span>();</span><br><span class="line">    <span class="built_in">InitDataBlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">SeekToLast</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SetDataIterator</span><span class="params">(Iterator* data_iter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) <span class="built_in">SaveError</span>(data_iter_.<span class="built_in">status</span>());</span><br><span class="line">  data_iter_.<span class="built_in">Set</span>(data_iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::InitDataBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!index_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="built_in">SetDataIterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Slice handle = index_iter_.<span class="built_in">value</span>();</span><br><span class="line">    <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        handle.<span class="built_in">compare</span>(data_block_handle_) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// data_iter_ is already constructed with this iterator, so</span></span><br><span class="line">      <span class="comment">// no need to change anything</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Iterator* iter = (*block_function_)(arg_, options_, handle);</span><br><span class="line">      data_block_handle_.<span class="built_in">assign</span>(handle.<span class="built_in">data</span>(), handle.<span class="built_in">size</span>());</span><br><span class="line">      <span class="built_in">SetDataIterator</span>(iter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">NewTwoLevelIterator</span><span class="params">(Iterator* index_iter,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockFunction block_function, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">const</span> ReadOptions&amp; options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TwoLevelIterator</span>(index_iter, block_function, arg, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sorted Table 中存储了多个 Data Block，使用 Index Block 完成对 Data Block 的索引。二级迭代器的第一级 <code>index_iter_</code> 完成对 Index Block 的迭代，第二级 <code>data_iter_</code> 完成对 Data Block 的迭代。遍历时移动 <code>data_iter_</code>，并在 <code>data_iter_</code> 边界的地方使用函数 <code>SkipEmptyDataBlocksForward</code> 和 <code>SkipEmptyDataBlocksBackward</code> 实现 Data Block 的前后切换。查找时同样先在 <code>index_iter_</code> 上查找，Index Block 的每个条目存储了 Data Block 的 <code>max_key</code> 和位置大小信息，可以二分；确定 <code>index_iter_</code> 的位置后再读取对应的 Data Block 进一步二分查找。</p>
<p>总结来看 Sorted Table 使用的迭代器们组成的链路如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TwoLevelIterator -&gt; <span class="built_in">IteratorWrapper</span>(index_iter_) -&gt; Block::Iter</span><br><span class="line">                 -&gt; <span class="built_in">IteratorWrapper</span>(data_iter_) -&gt; Block::Iter</span><br></pre></td></tr></table></figure>

<p>另外还有一个合并迭代器 <a href="https://github.com/google/leveldb/blob/master/table/merger.cc"><code>MergingIterator</code></a>，将会在多 Sorted Table 文件的遍历中使用到。该迭代器管理 n<em>n</em> 个子迭代器，<code>Next</code> 和 <code>Seek</code> 操作时齐头并进、选择最小的那个，具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergingIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MergingIterator</span>(<span class="keyword">const</span> Comparator* comparator, Iterator** children, <span class="keyword">int</span> n)</span><br><span class="line">      : <span class="built_in">comparator_</span>(comparator),</span><br><span class="line">        <span class="built_in">children_</span>(<span class="keyword">new</span> IteratorWrapper[n]),</span><br><span class="line">        <span class="built_in">n_</span>(n),</span><br><span class="line">        <span class="built_in">current_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">        <span class="built_in">direction_</span>(kForward) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">Set</span>(children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">MergingIterator</span>() <span class="keyword">override</span> &#123; <span class="keyword">delete</span>[] children_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> (current_ != <span class="literal">nullptr</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">SeekToFirst</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">    direction_ = kForward;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">SeekToLast</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FindLargest</span>();</span><br><span class="line">    direction_ = kReverse;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">Seek</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">    direction_ = kForward;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that all children are positioned after key().</span></span><br><span class="line">    <span class="comment">// If we are moving in the forward direction, it is already</span></span><br><span class="line">    <span class="comment">// true for all of the non-current_ children since current_ is</span></span><br><span class="line">    <span class="comment">// the smallest child and key() == current_-&gt;key().  Otherwise,</span></span><br><span class="line">    <span class="comment">// we explicitly position the non-current_ children.</span></span><br><span class="line">    <span class="keyword">if</span> (direction_ != kForward) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">        IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">        <span class="keyword">if</span> (child != current_) &#123;</span><br><span class="line">          child-&gt;<span class="built_in">Seek</span>(<span class="built_in">key</span>());</span><br><span class="line">          <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>() &amp;&amp;</span><br><span class="line">              comparator_-&gt;<span class="built_in">Compare</span>(<span class="built_in">key</span>(), child-&gt;<span class="built_in">key</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">            child-&gt;<span class="built_in">Next</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      direction_ = kForward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current_-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that all children are positioned before key().</span></span><br><span class="line">    <span class="comment">// If we are moving in the reverse direction, it is already</span></span><br><span class="line">    <span class="comment">// true for all of the non-current_ children since current_ is</span></span><br><span class="line">    <span class="comment">// the largest child and key() == current_-&gt;key().  Otherwise,</span></span><br><span class="line">    <span class="comment">// we explicitly position the non-current_ children.</span></span><br><span class="line">    <span class="keyword">if</span> (direction_ != kReverse) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">        IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">        <span class="keyword">if</span> (child != current_) &#123;</span><br><span class="line">          child-&gt;<span class="built_in">Seek</span>(<span class="built_in">key</span>());</span><br><span class="line">          <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">            <span class="comment">// Child is at first entry &gt;= key().  Step back one to be &lt; key()</span></span><br><span class="line">            child-&gt;<span class="built_in">Prev</span>();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Child has no entries &gt;= key().  Position at last entry.</span></span><br><span class="line">            child-&gt;<span class="built_in">SeekToLast</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      direction_ = kReverse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current_-&gt;<span class="built_in">Prev</span>();</span><br><span class="line">    <span class="built_in">FindLargest</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> current_-&gt;<span class="built_in">key</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> current_-&gt;<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    Status status;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      status = children_[i].<span class="built_in">status</span>();</span><br><span class="line">      <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Which direction is the iterator moving?</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> &#123;</span> kForward, kReverse &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindSmallest</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindLargest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We might want to use a heap in case there are lots of children.</span></span><br><span class="line">  <span class="comment">// For now we use a simple array since we expect a very small number</span></span><br><span class="line">  <span class="comment">// of children in leveldb.</span></span><br><span class="line">  <span class="keyword">const</span> Comparator* comparator_;</span><br><span class="line">  IteratorWrapper* children_;</span><br><span class="line">  <span class="keyword">int</span> n_;</span><br><span class="line">  IteratorWrapper* current_;</span><br><span class="line">  Direction direction_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergingIterator::FindSmallest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  IteratorWrapper* smallest = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">    IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">    <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (smallest == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        smallest = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator_-&gt;<span class="built_in">Compare</span>(child-&gt;<span class="built_in">key</span>(), smallest-&gt;<span class="built_in">key</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        smallest = child;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  current_ = smallest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergingIterator::FindLargest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  IteratorWrapper* largest = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n_ - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">    <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (largest == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        largest = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator_-&gt;<span class="built_in">Compare</span>(child-&gt;<span class="built_in">key</span>(), largest-&gt;<span class="built_in">key</span>()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        largest = child;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  current_ = largest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-Table"><a href="#6-Table" class="headerlink" title="6. Table"></a>6. Table</h3><p>最后来看 Sorted Table 的实现 <a href="https://github.com/google/leveldb/blob/master/table/table.cc"><code>table/table.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Table</span>:</span>:Rep &#123;</span><br><span class="line">  ~<span class="built_in">Rep</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> filter;</span><br><span class="line">    <span class="keyword">delete</span>[] filter_data;</span><br><span class="line">    <span class="keyword">delete</span> index_block;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Options options;</span><br><span class="line">  Status status;</span><br><span class="line">  RandomAccessFile* file;</span><br><span class="line">  <span class="keyword">uint64_t</span> cache_id;</span><br><span class="line">  FilterBlockReader* filter;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* filter_data;</span><br><span class="line"></span><br><span class="line">  BlockHandle metaindex_handle;  <span class="comment">// Handle to metaindex_block: saved from footer</span></span><br><span class="line">  Block* index_block;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Table::Open</span><span class="params">(<span class="keyword">const</span> Options&amp; options, RandomAccessFile* file,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">uint64_t</span> size, Table** table)</span> </span>&#123;</span><br><span class="line">  *table = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &lt; Footer::kEncodedLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;file is too short to be an sstable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> footer_space[Footer::kEncodedLength];</span><br><span class="line">  Slice footer_input;</span><br><span class="line">  Status s = file-&gt;<span class="built_in">Read</span>(size - Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                        &amp;footer_input, footer_space);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">  Footer footer;</span><br><span class="line">  s = footer.<span class="built_in">DecodeFrom</span>(&amp;footer_input);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read the index block</span></span><br><span class="line">  BlockContents index_block_contents;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    ReadOptions opt;</span><br><span class="line">    <span class="keyword">if</span> (options.paranoid_checks) &#123;</span><br><span class="line">      opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="built_in">ReadBlock</span>(file, opt, footer.<span class="built_in">index_handle</span>(), &amp;index_block_contents);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// We&#x27;ve successfully read the footer and the index block: we&#x27;re</span></span><br><span class="line">    <span class="comment">// ready to serve requests.</span></span><br><span class="line">    Block* index_block = <span class="keyword">new</span> <span class="built_in">Block</span>(index_block_contents);</span><br><span class="line">    Rep* rep = <span class="keyword">new</span> Table::Rep;</span><br><span class="line">    rep-&gt;options = options;</span><br><span class="line">    rep-&gt;file = file;</span><br><span class="line">    rep-&gt;metaindex_handle = footer.<span class="built_in">metaindex_handle</span>();</span><br><span class="line">    rep-&gt;index_block = index_block;</span><br><span class="line">    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;<span class="built_in">NewId</span>() : <span class="number">0</span>);</span><br><span class="line">    rep-&gt;filter_data = <span class="literal">nullptr</span>;</span><br><span class="line">    rep-&gt;filter = <span class="literal">nullptr</span>;</span><br><span class="line">    *table = <span class="keyword">new</span> <span class="built_in">Table</span>(rep);</span><br><span class="line">    (*table)-&gt;<span class="built_in">ReadMeta</span>(footer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Table::ReadMeta</span><span class="params">(<span class="keyword">const</span> Footer&amp; footer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;options.filter_policy == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// Do not need any metadata</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(sanjay): Skip this if footer.metaindex_handle() size indicates</span></span><br><span class="line">  <span class="comment">// it is an empty block.</span></span><br><span class="line">  ReadOptions opt;</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;options.paranoid_checks) &#123;</span><br><span class="line">    opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  BlockContents contents;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ReadBlock</span>(rep_-&gt;file, opt, footer.<span class="built_in">metaindex_handle</span>(), &amp;contents).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Do not propagate errors since meta info is not needed for operation</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Block* meta = <span class="keyword">new</span> <span class="built_in">Block</span>(contents);</span><br><span class="line"></span><br><span class="line">  Iterator* iter = meta-&gt;<span class="built_in">NewIterator</span>(<span class="built_in">BytewiseComparator</span>());</span><br><span class="line">  std::string key = <span class="string">&quot;filter.&quot;</span>;</span><br><span class="line">  key.<span class="built_in">append</span>(rep_-&gt;options.filter_policy-&gt;<span class="built_in">Name</span>());</span><br><span class="line">  iter-&gt;<span class="built_in">Seek</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (iter-&gt;<span class="built_in">Valid</span>() &amp;&amp; iter-&gt;<span class="built_in">key</span>() == <span class="built_in">Slice</span>(key)) &#123;</span><br><span class="line">    <span class="built_in">ReadFilter</span>(iter-&gt;<span class="built_in">value</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  <span class="keyword">delete</span> meta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Table::ReadFilter</span><span class="params">(<span class="keyword">const</span> Slice&amp; filter_handle_value)</span> </span>&#123;</span><br><span class="line">  Slice v = filter_handle_value;</span><br><span class="line">  BlockHandle filter_handle;</span><br><span class="line">  <span class="keyword">if</span> (!filter_handle.<span class="built_in">DecodeFrom</span>(&amp;v).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We might want to unify with ReadBlock() if we start</span></span><br><span class="line">  <span class="comment">// requiring checksum verification in Table::Open.</span></span><br><span class="line">  ReadOptions opt;</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;options.paranoid_checks) &#123;</span><br><span class="line">    opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  BlockContents block;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ReadBlock</span>(rep_-&gt;file, opt, filter_handle, &amp;block).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (block.heap_allocated) &#123;</span><br><span class="line">    rep_-&gt;filter_data = block.data.<span class="built_in">data</span>();  <span class="comment">// Will need to delete later</span></span><br><span class="line">  &#125;</span><br><span class="line">  rep_-&gt;filter = <span class="keyword">new</span> <span class="built_in">FilterBlockReader</span>(rep_-&gt;options.filter_policy, block.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Table::~<span class="built_in">Table</span>() &#123; <span class="keyword">delete</span> rep_; &#125;</span><br></pre></td></tr></table></figure>

<p>开始部分依然是熟悉的 <code>pImpl</code> 范式，毕竟 <code>Table</code> 是对外的接口，需要保持稳定。<code>Table::Open</code> 时，首先读取文件尾部的 <code>Footer</code>，根据 <code>Footer::index_handle()</code> 读取 <code>index_block</code> 到内存中，并按需读取 <code>meta_block</code> 和 <code>filter</code>；这些析构时也会做对应的删除。接着看迭代器部分的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteCachedBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value)</span> </span>&#123;</span><br><span class="line">  Block* block = <span class="keyword">reinterpret_cast</span>&lt;Block*&gt;(value);</span><br><span class="line">  <span class="keyword">delete</span> block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReleaseBlock</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">void</span>* h)</span> </span>&#123;</span><br><span class="line">  Cache* cache = <span class="keyword">reinterpret_cast</span>&lt;Cache*&gt;(arg);</span><br><span class="line">  Cache::Handle* handle = <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(h);</span><br><span class="line">  cache-&gt;<span class="built_in">Release</span>(handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert an index iterator value (i.e., an encoded BlockHandle)</span></span><br><span class="line"><span class="comment">// into an iterator over the contents of the corresponding block.</span></span><br><span class="line"><span class="function">Iterator* <span class="title">Table::BlockReader</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> Slice&amp; index_value)</span> </span>&#123;</span><br><span class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;Table*&gt;(arg);</span><br><span class="line">  Cache* block_cache = table-&gt;rep_-&gt;options.block_cache;</span><br><span class="line">  Block* block = <span class="literal">nullptr</span>;</span><br><span class="line">  Cache::Handle* cache_handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  BlockHandle handle;</span><br><span class="line">  Slice input = index_value;</span><br><span class="line">  Status s = handle.<span class="built_in">DecodeFrom</span>(&amp;input);</span><br><span class="line">  <span class="comment">// We intentionally allow extra stuff in index_value so that we</span></span><br><span class="line">  <span class="comment">// can add more features in the future.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    BlockContents contents;</span><br><span class="line">    <span class="keyword">if</span> (block_cache != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> cache_key_buffer[<span class="number">16</span>];</span><br><span class="line">      <span class="built_in">EncodeFixed64</span>(cache_key_buffer, table-&gt;rep_-&gt;cache_id);</span><br><span class="line">      <span class="built_in">EncodeFixed64</span>(cache_key_buffer + <span class="number">8</span>, handle.<span class="built_in">offset</span>());</span><br><span class="line">      <span class="function">Slice <span class="title">key</span><span class="params">(cache_key_buffer, <span class="keyword">sizeof</span>(cache_key_buffer))</span></span>;</span><br><span class="line">      cache_handle = block_cache-&gt;<span class="built_in">Lookup</span>(key);</span><br><span class="line">      <span class="keyword">if</span> (cache_handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        block = <span class="keyword">reinterpret_cast</span>&lt;Block*&gt;(block_cache-&gt;<span class="built_in">Value</span>(cache_handle));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = <span class="built_in">ReadBlock</span>(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          block = <span class="keyword">new</span> <span class="built_in">Block</span>(contents);</span><br><span class="line">          <span class="keyword">if</span> (contents.cachable &amp;&amp; options.fill_cache) &#123;</span><br><span class="line">            cache_handle = block_cache-&gt;<span class="built_in">Insert</span>(key, block, block-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                               &amp;DeleteCachedBlock);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = <span class="built_in">ReadBlock</span>(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        block = <span class="keyword">new</span> <span class="built_in">Block</span>(contents);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Iterator* iter;</span><br><span class="line">  <span class="keyword">if</span> (block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    iter = block-&gt;<span class="built_in">NewIterator</span>(table-&gt;rep_-&gt;options.comparator);</span><br><span class="line">    <span class="keyword">if</span> (cache_handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      iter-&gt;<span class="built_in">RegisterCleanup</span>(&amp;DeleteBlock, block, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iter-&gt;<span class="built_in">RegisterCleanup</span>(&amp;ReleaseBlock, block_cache, cache_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iter = <span class="built_in">NewErrorIterator</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">Table::NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NewTwoLevelIterator</span>(</span><br><span class="line">      rep_-&gt;index_block-&gt;<span class="built_in">NewIterator</span>(rep_-&gt;options.comparator),</span><br><span class="line">      &amp;Table::BlockReader, <span class="keyword">const_cast</span>&lt;Table*&gt;(<span class="keyword">this</span>), options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Table::NewIterator</code> 中会构造一个二级迭代器，第一级自然是 <code>index_block</code> 的迭代器，并且提供了第二级迭代器的创建函数 <code>Table::BlockReader</code>。该函数的第一个参数实际上为 <code>Table</code> 对象的指针，第三个参数是 <code>index_block</code> 键值对中的 <code>Value</code>，也就是对应的 Data Block Handle。如果不考虑缓存部分，代码还是很容易理解的：首先解析对应的 <code>BlockHandle</code>，据此读取 <code>block</code>，创建迭代器并且注册迭代器清理函数 <code>DeleteBlock</code>，当删除迭代器时删除对应的 <code>block</code>。当考虑缓存时，可以回忆下系列第一篇介绍的 <code>LRUCache</code> 再来看代码：使用 <code>cache_id</code> 和 <code>handle.offset</code> 构建一个缓存的 <code>Key</code>，将 <code>block</code> 作为缓存的 <code>Value</code>，后者的清理函数为 <code>DeleteCachedBlock</code>；当前使用 <code>block</code> 创建迭代器增加了 <code>block</code> 的引用计数，当迭代器析构时需要调用 <code>ReleaseBlock</code> 以减少缓存的 <code>block</code> 的引用计数。这样就非常合理且高效了。</p>
<h3 id="7-Table-Cache"><a href="#7-Table-Cache" class="headerlink" title="7. Table Cache"></a>7. Table Cache</h3><p>LevelDB 中会使用 <code>file_number</code> 给 Sorted Table 编号。为了提高读取性能、简化使用，LevelDB 提供了 <code>TableCache</code> 用以缓存 Sorted Table 及对应的 <code>.ldb</code> 文件，定义于 <a href="https://github.com/google/leveldb/blob/master/db/table_cache.h"><code>db/table_cache.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableCache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TableCache</span>(<span class="keyword">const</span> std::string&amp; dbname, <span class="keyword">const</span> Options&amp; options, <span class="keyword">int</span> entries);</span><br><span class="line">  ~<span class="built_in">TableCache</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an iterator for the specified file number (the corresponding</span></span><br><span class="line">  <span class="comment">// file length must be exactly &quot;file_size&quot; bytes).  If &quot;tableptr&quot; is</span></span><br><span class="line">  <span class="comment">// non-null, also sets &quot;*tableptr&quot; to point to the Table object</span></span><br><span class="line">  <span class="comment">// underlying the returned iterator, or to nullptr if no Table object</span></span><br><span class="line">  <span class="comment">// underlies the returned iterator.  The returned &quot;*tableptr&quot; object is owned</span></span><br><span class="line">  <span class="comment">// by the cache and should not be deleted, and is valid for as long as the</span></span><br><span class="line">  <span class="comment">// returned iterator is live.</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">uint64_t</span> file_size, Table** tableptr = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a seek to internal key &quot;k&quot; in specified file finds an entry,</span></span><br><span class="line">  <span class="comment">// call (*handle_result)(arg, found_key, found_value).</span></span><br><span class="line">  <span class="function">Status <span class="title">Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">uint64_t</span> file_size, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;, <span class="keyword">const</span> Slice&amp;))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Evict any entry for the specified file number</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Evict</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">Status <span class="title">FindTable</span><span class="params">(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size, Cache::Handle**)</span></span>;</span><br><span class="line"></span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> std::string dbname_;</span><br><span class="line">  <span class="keyword">const</span> Options&amp; options_;</span><br><span class="line">  Cache* cache_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>核心接口 <code>TableCache::NewIterator</code>，只需要提供 <code>file_number</code> 和 <code>file_size</code>，就可以返回对应的 Sorted Table 对象及其迭代器。TableCache 封装了缓存和清理的逻辑，其实现也非常简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TableAndFile</span> &#123;</span></span><br><span class="line">  RandomAccessFile* file;</span><br><span class="line">  Table* table;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteEntry</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value)</span> </span>&#123;</span><br><span class="line">  TableAndFile* tf = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(value);</span><br><span class="line">  <span class="keyword">delete</span> tf-&gt;table;</span><br><span class="line">  <span class="keyword">delete</span> tf-&gt;file;</span><br><span class="line">  <span class="keyword">delete</span> tf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnrefEntry</span><span class="params">(<span class="keyword">void</span>* arg1, <span class="keyword">void</span>* arg2)</span> </span>&#123;</span><br><span class="line">  Cache* cache = <span class="keyword">reinterpret_cast</span>&lt;Cache*&gt;(arg1);</span><br><span class="line">  Cache::Handle* h = <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(arg2);</span><br><span class="line">  cache-&gt;<span class="built_in">Release</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TableCache::<span class="built_in">TableCache</span>(<span class="keyword">const</span> std::string&amp; dbname, <span class="keyword">const</span> Options&amp; options,</span><br><span class="line">                       <span class="keyword">int</span> entries)</span><br><span class="line">    : <span class="built_in">env_</span>(options.env),</span><br><span class="line">      <span class="built_in">dbname_</span>(dbname),</span><br><span class="line">      <span class="built_in">options_</span>(options),</span><br><span class="line">      <span class="built_in">cache_</span>(<span class="built_in">NewLRUCache</span>(entries)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">TableCache::~<span class="built_in">TableCache</span>() &#123; <span class="keyword">delete</span> cache_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TableCache::FindTable</span><span class="params">(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Cache::Handle** handle)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="built_in"><span class="keyword">sizeof</span></span>(file_number)];</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(buf, file_number);</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">(buf, <span class="keyword">sizeof</span>(buf))</span></span>;</span><br><span class="line">  *handle = cache_-&gt;<span class="built_in">Lookup</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (*handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    std::string fname = <span class="built_in">TableFileName</span>(dbname_, file_number);</span><br><span class="line">    RandomAccessFile* file = <span class="literal">nullptr</span>;</span><br><span class="line">    Table* table = <span class="literal">nullptr</span>;</span><br><span class="line">    s = env_-&gt;<span class="built_in">NewRandomAccessFile</span>(fname, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      std::string old_fname = <span class="built_in">SSTTableFileName</span>(dbname_, file_number);</span><br><span class="line">      <span class="keyword">if</span> (env_-&gt;<span class="built_in">NewRandomAccessFile</span>(old_fname, &amp;file).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        s = Status::<span class="built_in">OK</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = Table::<span class="built_in">Open</span>(options_, file, file_size, &amp;table);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(table == <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">delete</span> file;</span><br><span class="line">      <span class="comment">// We do not cache error results so that if the error is transient,</span></span><br><span class="line">      <span class="comment">// or somebody repairs the file, we recover automatically.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TableAndFile* tf = <span class="keyword">new</span> TableAndFile;</span><br><span class="line">      tf-&gt;file = file;</span><br><span class="line">      tf-&gt;table = table;</span><br><span class="line">      *handle = cache_-&gt;<span class="built_in">Insert</span>(key, tf, <span class="number">1</span>, &amp;DeleteEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">TableCache::NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Table** tableptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *tableptr = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  Status s = <span class="built_in">FindTable</span>(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewErrorIterator</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;<span class="built_in">Value</span>(handle))-&gt;table;</span><br><span class="line">  Iterator* result = table-&gt;<span class="built_in">NewIterator</span>(options);</span><br><span class="line">  result-&gt;<span class="built_in">RegisterCleanup</span>(&amp;UnrefEntry, cache_, handle);</span><br><span class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *tableptr = table;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TableCache::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">uint64_t</span> file_size, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="keyword">const</span> Slice&amp;))</span> </span>&#123;</span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  Status s = <span class="built_in">FindTable</span>(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    Table* t = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;<span class="built_in">Value</span>(handle))-&gt;table;</span><br><span class="line">    s = t-&gt;<span class="built_in">InternalGet</span>(options, k, arg, handle_result);</span><br><span class="line">    cache_-&gt;<span class="built_in">Release</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableCache::Evict</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="built_in"><span class="keyword">sizeof</span></span>(file_number)];</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(buf, file_number);</span><br><span class="line">  cache_-&gt;<span class="built_in">Erase</span>(<span class="built_in">Slice</span>(buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TableCache::FindTable</code> 中会根据 <code>file_number</code> 构建缓存的 Key，首先尝试在缓存中查找，如果找不到则手动的打开文件、构造 Table。对应迭代器的实现也很简单，只需要设定好对应的清理函数 <code>DeleteEntry</code> 和 <code>UnrefEntry</code>，就可以放心使用了。每多加一层封装，就多屏蔽一分底层实现的细节，对使用者来说就更易用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前后两篇完成了对 Sorted Table 代码的阅读和分析。当数据位于内存时，查找过程中随机访问的时间微乎其微；但当数据保存到硬盘后，将 Sorted Table 载入内存的 IO 时间就非常可观了。Sorted Table 使用多级迭代器来缓和这个问题，首先完整地读取了 Index Block 到内存中；进行查找时首先在 Index Block 上二分，确定 Data Block 的位置后再进行必要的 IO 读取，并且通过缓存 Data Block 的方式提升读取的性能。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码分析——8.版本管理</title>
    <url>/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%948.%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="八-版本管理"><a href="#八-版本管理" class="headerlink" title="八.版本管理"></a>八.版本管理</h2><p>本系列的上一篇介绍了 Sorted Table 的构建和读取过程。当 Sorted Table 不断构建出来时，需要使用适当的方式来组织、管理生成的 <code>.ldb</code> 文件。并且 LevelDB 支持快照，这需要 LevelDB 具有版本管理能力。本篇将分析 LevelDB 版本管理相关的代码。</p>
<h3 id="1-版本概述"><a href="#1-版本概述" class="headerlink" title="1. 版本概述"></a>1. 版本概述</h3><p>LevelDB 中的版本管理是针对 Sorted Table 文件的变化的。当有新的内存数据库转为 Sorted Table，或者发生 Compaction 导致有 Sorted Table 增删，都会触发版本的更新。版本管理可以类比 git：</p>
<ol>
<li>初始的时候是一个空的 repo（没有 Sorted Table 文件）；</li>
<li>当有文件增删时，会在之前的版本上做增量的 commit 记录（VersionEdit）；</li>
<li>根据之前的版本和 commit 记录，可以推断出现在的版本（Version）；</li>
<li>根据初始状态和所有 commit 记录可以推断出所有版本（VersionSet）；</li>
<li>使用 HEAD 指向当前使用的版本（CURRENT 文件）。</li>
</ol>
<h3 id="2-版本-Version"><a href="#2-版本-Version" class="headerlink" title="2. 版本 Version"></a>2. 版本 Version</h3><p>首先来看没有未知依赖的 <a href="https://github.com/google/leveldb/blob/master/db/version_edit.h"><code>db/version_edit.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></span><br><span class="line">  <span class="built_in">FileMetaData</span>() : <span class="built_in">refs</span>(<span class="number">0</span>), <span class="built_in">allowed_seeks</span>(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), <span class="built_in">file_size</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;  <span class="comment">// Seeks allowed until compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;    <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// Largest internal key served by table</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>FileMetaData</code> 记录了 <code>.ldb</code> 文件的元信息，包括允许查找的次数、文件编号 <code>number</code> 和大小 <code>file_size</code> 以及最小和最大的 Key。接下来是 <code>VersionEdit</code> 的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionEdit</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VersionEdit</span>() &#123; <span class="built_in">Clear</span>(); &#125;</span><br><span class="line">  ~<span class="built_in">VersionEdit</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetComparatorName</span><span class="params">(<span class="keyword">const</span> Slice&amp; name)</span> </span>&#123;</span><br><span class="line">    has_comparator_ = <span class="literal">true</span>;</span><br><span class="line">    comparator_ = name.<span class="built_in">ToString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetLogNumber</span><span class="params">(<span class="keyword">uint64_t</span> num)</span> </span>&#123;</span><br><span class="line">    has_log_number_ = <span class="literal">true</span>;</span><br><span class="line">    log_number_ = num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetPrevLogNumber</span><span class="params">(<span class="keyword">uint64_t</span> num)</span> </span>&#123;</span><br><span class="line">    has_prev_log_number_ = <span class="literal">true</span>;</span><br><span class="line">    prev_log_number_ = num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetNextFile</span><span class="params">(<span class="keyword">uint64_t</span> num)</span> </span>&#123;</span><br><span class="line">    has_next_file_number_ = <span class="literal">true</span>;</span><br><span class="line">    next_file_number_ = num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetLastSequence</span><span class="params">(SequenceNumber seq)</span> </span>&#123;</span><br><span class="line">    has_last_sequence_ = <span class="literal">true</span>;</span><br><span class="line">    last_sequence_ = seq;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetCompactPointer</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">const</span> InternalKey&amp; key)</span> </span>&#123;</span><br><span class="line">    compact_pointers_.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(level, key));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the specified file at the specified number.</span></span><br><span class="line">  <span class="comment">// REQUIRES: This version has not been saved (see VersionSet::SaveTo)</span></span><br><span class="line">  <span class="comment">// REQUIRES: &quot;smallest&quot; and &quot;largest&quot; are smallest and largest keys in file</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">const</span> InternalKey&amp; smallest, <span class="keyword">const</span> InternalKey&amp; largest)</span> </span>&#123;</span><br><span class="line">    FileMetaData f;</span><br><span class="line">    f.number = file;</span><br><span class="line">    f.file_size = file_size;</span><br><span class="line">    f.smallest = smallest;</span><br><span class="line">    f.largest = largest;</span><br><span class="line">    new_files_.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(level, f));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete the specified &quot;file&quot; from the specified &quot;level&quot;.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">DeleteFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file)</span> </span>&#123;</span><br><span class="line">    deleted_files_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(level, file));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">EncodeTo</span><span class="params">(std::string* dst)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">Status <span class="title">DecodeFrom</span><span class="params">(<span class="keyword">const</span> Slice&amp; src)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> std::set&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet;</span><br><span class="line"></span><br><span class="line">  std::string comparator_;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">  SequenceNumber last_sequence_;</span><br><span class="line">  <span class="keyword">bool</span> has_comparator_;</span><br><span class="line">  <span class="keyword">bool</span> has_log_number_;</span><br><span class="line">  <span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line">  <span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line">  <span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line">  DeletedFileSet deleted_files_;</span><br><span class="line">  std::vector&lt;std::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>VersionEdit</code> 包含了几项可编辑属性：</p>
<ol>
<li><code>comparator_</code>，比较器的名称；</li>
<li><code>log_number_</code>，日志编号；</li>
<li><code>prev_log_number_</code>，上一个日志编号；</li>
<li><code>next_file_number_</code>，下一个文件编号；</li>
<li><code>last_sequence_</code>，最后的序列号；</li>
<li><code>compact_pointers_</code>，暂时不清楚是什么；</li>
<li><code>delted_files_</code>，删除的文件，记录了 <code>level</code> 和文件号；</li>
<li><code>new_files_</code>，新增的文件，记录了 <code>level</code> 和 <code>FileMetaData</code>。</li>
</ol>
<p>上面几项属性有些还不清楚作用，先搁置不用慌。另外两个重要的接口 <code>EncodeTo</code> 和 <code>DecodeFrom</code> 负责编解码，实现在对应的 <a href="https://github.com/google/leveldb/blob/master/db/version_edit.cc"><code>.cc</code></a> 中，不在赘述。接下来，继续看 <code>Version</code> 的定义 <a href="https://github.com/google/leveldb/blob/master/db/version_set.h"><code>db/version_set.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Version</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Lookup the value for key.  If found, store it in *val and</span></span><br><span class="line">  <span class="comment">// return OK.  Else return a non-OK status.  Fills *stats.</span></span><br><span class="line">  <span class="comment">// REQUIRES: lock is not held</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">GetStats</span> &#123;</span></span><br><span class="line">    FileMetaData* seek_file;</span><br><span class="line">    <span class="keyword">int</span> seek_file_level;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append to *iters a sequence of iterators that will</span></span><br><span class="line">  <span class="comment">// yield the contents of this Version when merged together.</span></span><br><span class="line">  <span class="comment">// REQUIRES: This version has been saved (see VersionSet::SaveTo)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddIterators</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp;, std::vector&lt;Iterator*&gt;* iters)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp;, <span class="keyword">const</span> LookupKey&amp; key, std::string* val,</span></span></span><br><span class="line"><span class="params"><span class="function">             GetStats* stats)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Adds &quot;stats&quot; into the current state.  Returns true if a new</span></span><br><span class="line">  <span class="comment">// compaction may need to be triggered, false otherwise.</span></span><br><span class="line">  <span class="comment">// REQUIRES: lock is held</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">UpdateStats</span><span class="params">(<span class="keyword">const</span> GetStats&amp; stats)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record a sample of bytes read at the specified internal key.</span></span><br><span class="line">  <span class="comment">// Samples are taken approximately once every config::kReadBytesPeriod</span></span><br><span class="line">  <span class="comment">// bytes.  Returns true if a new compaction may need to be triggered.</span></span><br><span class="line">  <span class="comment">// REQUIRES: lock is held</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">RecordReadSample</span><span class="params">(Slice key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reference count management (so Versions do not disappear out from</span></span><br><span class="line">  <span class="comment">// under live iterators)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetOverlappingInputs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">int</span> level,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> InternalKey* begin,  <span class="comment">// nullptr means before all keys</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> InternalKey* end,    <span class="comment">// nullptr means after all keys</span></span></span></span><br><span class="line"><span class="params"><span class="function">      std::vector&lt;FileMetaData*&gt;* inputs)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff some file in the specified level overlaps</span></span><br><span class="line">  <span class="comment">// some part of [*smallest_user_key,*largest_user_key].</span></span><br><span class="line">  <span class="comment">// smallest_user_key==nullptr represents a key smaller than all the DB&#x27;s keys.</span></span><br><span class="line">  <span class="comment">// largest_user_key==nullptr represents a key largest than all the DB&#x27;s keys.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">OverlapInLevel</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">const</span> Slice* smallest_user_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">const</span> Slice* largest_user_key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the level at which we should place a new memtable compaction</span></span><br><span class="line">  <span class="comment">// result that covers the range [smallest_user_key,largest_user_key].</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">PickLevelForMemTableOutput</span><span class="params">(<span class="keyword">const</span> Slice&amp; smallest_user_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">const</span> Slice&amp; largest_user_key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">NumFiles</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> files_[level].<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a human readable string that describes this version&#x27;s contents.</span></span><br><span class="line">  <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Compaction</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LevelFileNumIterator</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Version</span><span class="params">(VersionSet* vset)</span></span></span><br><span class="line"><span class="function">      : vset_(vset),</span></span><br><span class="line"><span class="function">        next_(this),</span></span><br><span class="line"><span class="function">        prev_(this),</span></span><br><span class="line"><span class="function">        refs_(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        file_to_compact_(nullptr),</span></span><br><span class="line"><span class="function">        file_to_compact_level_(<span class="number">-1</span>),</span></span><br><span class="line"><span class="function">        compaction_score_(<span class="number">-1</span>),</span></span><br><span class="line"><span class="function">        compaction_level_(<span class="number">-1</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Version</span>(<span class="keyword">const</span> Version&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Version&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Version&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Version</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewConcatenatingIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp;, <span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call func(arg, level, f) for every file that overlaps user_key in</span></span><br><span class="line">  <span class="comment">// order from newest to oldest.  If an invocation of func returns</span></span><br><span class="line">  <span class="comment">// false, makes no more calls.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// REQUIRES: user portion of internal_key == user_key.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">bool</span> (*func)(<span class="keyword">void</span>*, <span class="keyword">int</span>, FileMetaData*))</span></span>;</span><br><span class="line"></span><br><span class="line">  VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">  Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">  Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line">  <span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// List of files per level</span></span><br><span class="line">  std::vector&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">  FileMetaData* file_to_compact_;</span><br><span class="line">  <span class="keyword">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line">  <span class="comment">// Score &lt; 1 means compaction is not strictly needed.  These fields</span></span><br><span class="line">  <span class="comment">// are initialized by Finalize().</span></span><br><span class="line">  <span class="keyword">double</span> compaction_score_;</span><br><span class="line">  <span class="keyword">int</span> compaction_level_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先把属性列出来：</p>
<ol>
<li><code>vset_</code>，<code>VersionSet</code> 对象指针，该类下文再介绍，搁置；</li>
<li><code>next_</code> 和 <code>prev_</code>，成对出现，双向链表无疑；</li>
<li><code>refs_</code>，引用计数；</li>
<li><code>files_</code>，每一个 <code>level</code> 中的文件元信息列表；</li>
<li><code>file_to_compact_</code> 和 <code>file_to_compact_level_</code>，准备合并的文件及其 <code>level</code>，搁置；</li>
<li><code>compaction_score_</code> 和 <code>compaction_level_</code>，需要执行合并的 <code>level</code> 及打分，搁置。</li>
</ol>
<p>对属性有一个印象就好。接下来拆开来看这个类成员函数的实现 <a href="https://github.com/google/leveldb/blob/master/db/version_set.cc"><code>db/version_set.cc</code></a>，首先看迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return the smallest index i such that files[i]-&gt;largest &gt;= key.</span></span><br><span class="line"><span class="comment">// Return files.size() if there is no such file.</span></span><br><span class="line"><span class="comment">// REQUIRES: &quot;files&quot; contains a sorted list of non-overlapping files.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindFile</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; files, <span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> right = files.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> FileMetaData* f = files[mid];</span><br><span class="line">    <span class="keyword">if</span> (icmp.InternalKeyComparator::<span class="built_in">Compare</span>(f-&gt;largest.<span class="built_in">Encode</span>(), key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Key at &quot;mid.largest&quot; is &lt; &quot;target&quot;.  Therefore all</span></span><br><span class="line">      <span class="comment">// files at or before &quot;mid&quot; are uninteresting.</span></span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Key at &quot;mid.largest&quot; is &gt;= &quot;target&quot;.  Therefore all files</span></span><br><span class="line">      <span class="comment">// after &quot;mid&quot; are uninteresting.</span></span><br><span class="line">      right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An internal iterator.  For a given version/level pair, yields</span></span><br><span class="line"><span class="comment">// information about the files in the level.  For a given entry, key()</span></span><br><span class="line"><span class="comment">// is the largest key that occurs in the file, and value() is an</span></span><br><span class="line"><span class="comment">// 16-byte value containing the file number and file size, both</span></span><br><span class="line"><span class="comment">// encoded using EncodeFixed64.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Version</span>:</span>:LevelFileNumIterator : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LevelFileNumIterator</span>(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span><br><span class="line">                       <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;* flist)</span><br><span class="line">      : <span class="built_in">icmp_</span>(icmp), <span class="built_in">flist_</span>(flist), <span class="built_in">index_</span>(flist-&gt;<span class="built_in">size</span>()) &#123;  <span class="comment">// Marks as invalid</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> index_ &lt; flist_-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    index_ = <span class="built_in">FindFile</span>(icmp_, *flist_, target);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; index_ = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    index_ = flist_-&gt;<span class="built_in">empty</span>() ? <span class="number">0</span> : flist_-&gt;<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    index_++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">if</span> (index_ == <span class="number">0</span>) &#123;</span><br><span class="line">      index_ = flist_-&gt;<span class="built_in">size</span>();  <span class="comment">// Marks as invalid</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      index_--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> (*flist_)[index_]-&gt;largest.<span class="built_in">Encode</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="built_in">EncodeFixed64</span>(value_buf_, (*flist_)[index_]-&gt;number);</span><br><span class="line">    <span class="built_in">EncodeFixed64</span>(value_buf_ + <span class="number">8</span>, (*flist_)[index_]-&gt;file_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(value_buf_, <span class="built_in"><span class="keyword">sizeof</span></span>(value_buf_));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> Status::<span class="built_in">OK</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator icmp_;</span><br><span class="line">  <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;* <span class="keyword">const</span> flist_;</span><br><span class="line">  <span class="keyword">uint32_t</span> index_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Backing store for value().  Holds the file number and size.</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="keyword">char</span> value_buf_[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Iterator* <span class="title">GetFileIterator</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">const</span> Slice&amp; file_value)</span> </span>&#123;</span><br><span class="line">  TableCache* cache = <span class="keyword">reinterpret_cast</span>&lt;TableCache*&gt;(arg);</span><br><span class="line">  <span class="keyword">if</span> (file_value.<span class="built_in">size</span>() != <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewErrorIterator</span>(</span><br><span class="line">        Status::<span class="built_in">Corruption</span>(<span class="string">&quot;FileReader invoked with unexpected value&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cache-&gt;<span class="built_in">NewIterator</span>(options, <span class="built_in">DecodeFixed64</span>(file_value.<span class="built_in">data</span>()),</span><br><span class="line">                              <span class="built_in">DecodeFixed64</span>(file_value.<span class="built_in">data</span>() + <span class="number">8</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">Version::NewConcatenatingIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="keyword">int</span> level)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NewTwoLevelIterator</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">LevelFileNumIterator</span>(vset_-&gt;icmp_, &amp;files_[level]), &amp;GetFileIterator,</span><br><span class="line">      vset_-&gt;table_cache_, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::AddIterators</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::vector&lt;Iterator*&gt;* iters)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Merge all level zero files together since they may overlap</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    iters-&gt;<span class="built_in">push_back</span>(vset_-&gt;table_cache_-&gt;<span class="built_in">NewIterator</span>(</span><br><span class="line">        options, files_[<span class="number">0</span>][i]-&gt;number, files_[<span class="number">0</span>][i]-&gt;file_size));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For levels &gt; 0, we can use a concatenating iterator that sequentially</span></span><br><span class="line">  <span class="comment">// walks through the non-overlapping files in the level, opening them</span></span><br><span class="line">  <span class="comment">// lazily.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">1</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!files_[level].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      iters-&gt;<span class="built_in">push_back</span>(<span class="built_in">NewConcatenatingIterator</span>(options, level));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FindFile</code> 函数实现了一个简单的二分查找，可以在文件信息列表里快速找到第一个 <code>largest_key &gt;= key</code> 的文件信息编号。而后这里定义了一个文件信息列表的迭代器 <code>Version::LevelFileNumIterator</code>，其实现的功能是将 <code>largest_key</code> 作为 Key，文件编号和大小作为 Value，遍历和检索文件信息列表。该函数将在 <code>Version::NewConcatenatingIterator</code> 中作为第一级迭代器，对应的第二级便是其 Value 对应的 Sorted Table 文件的迭代器 <code>GetFileIterator</code>。这样就可以根据某个 Level 的文件信息列表，生成该 Level 下所有 Sorted Table 数据的迭代器。这还没结束，<code>Version::AddIterators</code> 会将所有 Level 的迭代器组合成一个列表，用来生成一个 <code>MergingIterator</code> 以遍历所有 Level 的数据（实现位于 <a href="https://github.com/google/leveldb/blob/master/db/db_impl.cc#L1088"><code>DBImpl::NewInternalIterator</code></a>）。仔细体会这个精妙的设计，然后继续来看 <code>Version::Get</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Callback from TableCache::Get()</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SaverState</span> &#123;</span></span><br><span class="line">  kNotFound,</span><br><span class="line">  kFound,</span><br><span class="line">  kDeleted,</span><br><span class="line">  kCorrupt,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Saver</span> &#123;</span></span><br><span class="line">  SaverState state;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp;</span><br><span class="line">  Slice user_key;</span><br><span class="line">  std::string* value;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveValue</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> Slice&amp; ikey, <span class="keyword">const</span> Slice&amp; v)</span> </span>&#123;</span><br><span class="line">  Saver* s = <span class="keyword">reinterpret_cast</span>&lt;Saver*&gt;(arg);</span><br><span class="line">  ParsedInternalKey parsed_key;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ParseInternalKey</span>(ikey, &amp;parsed_key)) &#123;</span><br><span class="line">    s-&gt;state = kCorrupt;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;ucmp-&gt;<span class="built_in">Compare</span>(parsed_key.user_key, s-&gt;user_key) == <span class="number">0</span>) &#123;</span><br><span class="line">      s-&gt;state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;</span><br><span class="line">      <span class="keyword">if</span> (s-&gt;state == kFound) &#123;</span><br><span class="line">        s-&gt;value-&gt;<span class="built_in">assign</span>(v.<span class="built_in">data</span>(), v.<span class="built_in">size</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">NewestFirst</span><span class="params">(FileMetaData* a, FileMetaData* b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a-&gt;number &gt; b-&gt;number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">bool</span> (*func)(<span class="keyword">void</span>*, <span class="keyword">int</span>, FileMetaData*))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp = vset_-&gt;icmp_.<span class="built_in">user_comparator</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search level-0 in order from newest to oldest.</span></span><br><span class="line">  std::vector&lt;FileMetaData*&gt; tmp;</span><br><span class="line">  tmp.<span class="built_in">reserve</span>(files_[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    FileMetaData* f = files_[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">if</span> (ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;smallest.<span class="built_in">user_key</span>()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;largest.<span class="built_in">user_key</span>()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      tmp.<span class="built_in">push_back</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tmp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), NewestFirst);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(*func)(arg, <span class="number">0</span>, tmp[i])) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search other levels.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">1</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> num_files = files_[level].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary search to find earliest index whose largest key &gt;= internal_key.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index = <span class="built_in">FindFile</span>(vset_-&gt;icmp_, files_[level], internal_key);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; num_files) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][index];</span><br><span class="line">      <span class="keyword">if</span> (ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;smallest.<span class="built_in">user_key</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// All of &quot;f&quot; is past any data for user_key</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(*func)(arg, level, f)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Version::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> LookupKey&amp; k,</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::string* value, GetStats* stats)</span> </span>&#123;</span><br><span class="line">  stats-&gt;seek_file = <span class="literal">nullptr</span>;</span><br><span class="line">  stats-&gt;seek_file_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    Saver saver;</span><br><span class="line">    GetStats* stats;</span><br><span class="line">    <span class="keyword">const</span> ReadOptions* options;</span><br><span class="line">    Slice ikey;</span><br><span class="line">    FileMetaData* last_file_read;</span><br><span class="line">    <span class="keyword">int</span> last_file_read_level;</span><br><span class="line"></span><br><span class="line">    VersionSet* vset;</span><br><span class="line">    Status s;</span><br><span class="line">    <span class="keyword">bool</span> found;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">      State* state = <span class="keyword">reinterpret_cast</span>&lt;State*&gt;(arg);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">          state-&gt;last_file_read != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></span><br><span class="line">        state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;</span><br><span class="line">        state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      state-&gt;last_file_read = f;</span><br><span class="line">      state-&gt;last_file_read_level = level;</span><br><span class="line"></span><br><span class="line">      state-&gt;s = state-&gt;vset-&gt;table_cache_-&gt;<span class="built_in">Get</span>(*state-&gt;options, f-&gt;number,</span><br><span class="line">                                                f-&gt;file_size, state-&gt;ikey,</span><br><span class="line">                                                &amp;state-&gt;saver, SaveValue);</span><br><span class="line">      <span class="keyword">if</span> (!state-&gt;s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in"><span class="keyword">switch</span></span> (state-&gt;saver.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> kNotFound:</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Keep searching in other files</span></span><br><span class="line">        <span class="keyword">case</span> kFound:</span><br><span class="line">          state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">case</span> kDeleted:</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">case</span> kCorrupt:</span><br><span class="line">          state-&gt;s =</span><br><span class="line">              Status::<span class="built_in">Corruption</span>(<span class="string">&quot;corrupted key for &quot;</span>, state-&gt;saver.user_key);</span><br><span class="line">          state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  State state;</span><br><span class="line">  state.found = <span class="literal">false</span>;</span><br><span class="line">  state.stats = stats;</span><br><span class="line">  state.last_file_read = <span class="literal">nullptr</span>;</span><br><span class="line">  state.last_file_read_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  state.options = &amp;options;</span><br><span class="line">  state.ikey = k.<span class="built_in">internal_key</span>();</span><br><span class="line">  state.vset = vset_;</span><br><span class="line"></span><br><span class="line">  state.saver.state = kNotFound;</span><br><span class="line">  state.saver.ucmp = vset_-&gt;icmp_.<span class="built_in">user_comparator</span>();</span><br><span class="line">  state.saver.user_key = k.<span class="built_in">user_key</span>();</span><br><span class="line">  state.saver.value = value;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ForEachOverlapping</span>(state.saver.user_key, state.ikey, &amp;state, &amp;State::Match);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state.found ? state.s : Status::<span class="built_in">NotFound</span>(<span class="built_in">Slice</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名空间中声明了枚举类 <code>SaverState</code>，为查找操作的四种状态：未找到，找到，删除和中断。<code>Saver</code> 负责记录输入的比较器和 <code>user_key</code>，以及输出的 <code>SaverState</code> 和查找得到的 <code>value</code>。<code>SaveValue</code> 作为查找操作的回调函数，将会在 Seek 操作完成后执行，其参数为 <code>SaverState</code> 及键值对。通过判断 <code>user_key</code> 是否一致，对 <code>SaverState</code> 进行更新。</p>
<p>再来看 <code>Version::Get</code>，其调用的 <code>Version::ForEachOverlapping</code> 会根据 <code>smallest_key</code> 和 <code>largest_key</code> 筛选出要查找的文件，再通过回调函数调用 <code>table_cache_-&gt;Get</code> 进行查找，如果找到合法的结果则调用回调函数 <code>SaveValue</code>，如果回调得到的结果是 <code>kFound</code>，就可以提前返回了。Level 0 的文件由于可能存在重叠，所以每个文件都需要进行判断；而 Level 1 及以上的文件可以使用 <code>FindFile</code> 二分查找了。</p>
<h3 id="3-版本集-VersionSet"><a href="#3-版本集-VersionSet" class="headerlink" title="3. 版本集 VersionSet"></a>3. 版本集 VersionSet</h3><p>首先来看 <code>VersionSet::Builder</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A helper class so we can efficiently apply a whole sequence</span></span><br><span class="line"><span class="comment">// of edits to a particular state without creating intermediate</span></span><br><span class="line"><span class="comment">// Versions that contain full copies of the intermediate state.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>:</span>:Builder &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Helper to sort by v-&gt;files_[file_number].smallest</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BySmallestKey</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> InternalKeyComparator* internal_comparator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FileMetaData* f1, FileMetaData* f2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> r = internal_comparator-&gt;<span class="built_in">Compare</span>(f1-&gt;smallest, f2-&gt;smallest);</span><br><span class="line">      <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (r &lt; <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Break ties by file number</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (f1-&gt;number &lt; f2-&gt;number);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> std::set&lt;FileMetaData*, BySmallestKey&gt; FileSet;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LevelState</span> &#123;</span></span><br><span class="line">    std::set&lt;<span class="keyword">uint64_t</span>&gt; deleted_files;</span><br><span class="line">    FileSet* added_files;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  VersionSet* vset_;</span><br><span class="line">  Version* base_;</span><br><span class="line">  LevelState levels_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize a builder with the files from *base and other info from *vset</span></span><br><span class="line">  <span class="built_in">Builder</span>(VersionSet* vset, Version* base) : <span class="built_in">vset_</span>(vset), <span class="built_in">base_</span>(base) &#123;</span><br><span class="line">    base_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    BySmallestKey cmp;</span><br><span class="line">    cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">      levels_[level].added_files = <span class="keyword">new</span> <span class="built_in">FileSet</span>(cmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Builder</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">      <span class="keyword">const</span> FileSet* added = levels_[level].added_files;</span><br><span class="line">      std::vector&lt;FileMetaData*&gt; to_unref;</span><br><span class="line">      to_unref.<span class="built_in">reserve</span>(added-&gt;<span class="built_in">size</span>());</span><br><span class="line">      <span class="keyword">for</span> (FileSet::const_iterator it = added-&gt;<span class="built_in">begin</span>(); it != added-&gt;<span class="built_in">end</span>();</span><br><span class="line">           ++it) &#123;</span><br><span class="line">        to_unref.<span class="built_in">push_back</span>(*it);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> added;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; to_unref.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        FileMetaData* f = to_unref[i];</span><br><span class="line">        f-&gt;refs--;</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">delete</span> f;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    base_-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Apply all of the edits in *edit to the current state.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Update compaction pointers</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">      vset_-&gt;compact_pointer_[level] =</span><br><span class="line">          edit-&gt;compact_pointers_[i].second.<span class="built_in">Encode</span>().<span class="built_in">ToString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete files</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">      levels_[level].deleted_files.<span class="built_in">insert</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add new files</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">      FileMetaData* f = <span class="keyword">new</span> <span class="built_in">FileMetaData</span>(edit-&gt;new_files_[i].second);</span><br><span class="line">      f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We arrange to automatically compact this file after</span></span><br><span class="line">      <span class="comment">// a certain number of seeks.  Let&#x27;s assume:</span></span><br><span class="line">      <span class="comment">//   (1) One seek costs 10ms</span></span><br><span class="line">      <span class="comment">//   (2) Writing or reading 1MB costs 10ms (100MB/s)</span></span><br><span class="line">      <span class="comment">//   (3) A compaction of 1MB does 25MB of IO:</span></span><br><span class="line">      <span class="comment">//         1MB read from this level</span></span><br><span class="line">      <span class="comment">//         10-12MB read from next level (boundaries may be misaligned)</span></span><br><span class="line">      <span class="comment">//         10-12MB written to next level</span></span><br><span class="line">      <span class="comment">// This implies that 25 seeks cost the same as the compaction</span></span><br><span class="line">      <span class="comment">// of 1MB of data.  I.e., one seek costs approximately the</span></span><br><span class="line">      <span class="comment">// same as the compaction of 40KB of data.  We are a little</span></span><br><span class="line">      <span class="comment">// conservative and allow approximately one seek for every 16KB</span></span><br><span class="line">      <span class="comment">// of data before triggering a compaction.</span></span><br><span class="line">      f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>));</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">      levels_[level].deleted_files.<span class="built_in">erase</span>(f-&gt;number);</span><br><span class="line">      levels_[level].added_files-&gt;<span class="built_in">insert</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the current state in *v.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SaveTo</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">    BySmallestKey cmp;</span><br><span class="line">    cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">      <span class="comment">// Merge the set of added files with the set of pre-existing files.</span></span><br><span class="line">      <span class="comment">// Drop any deleted files.  Store the result in *v.</span></span><br><span class="line">      <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];</span><br><span class="line">      std::vector&lt;FileMetaData*&gt;::const_iterator base_iter = base_files.<span class="built_in">begin</span>();</span><br><span class="line">      std::vector&lt;FileMetaData*&gt;::const_iterator base_end = base_files.<span class="built_in">end</span>();</span><br><span class="line">      <span class="keyword">const</span> FileSet* added_files = levels_[level].added_files;</span><br><span class="line">      v-&gt;files_[level].<span class="built_in">reserve</span>(base_files.<span class="built_in">size</span>() + added_files-&gt;<span class="built_in">size</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; added_file : *added_files) &#123;</span><br><span class="line">        <span class="comment">// Add all smaller files listed in base_</span></span><br><span class="line">        <span class="keyword">for</span> (std::vector&lt;FileMetaData*&gt;::const_iterator bpos =</span><br><span class="line">                 std::<span class="built_in">upper_bound</span>(base_iter, base_end, added_file, cmp);</span><br><span class="line">             base_iter != bpos; ++base_iter) &#123;</span><br><span class="line">          <span class="built_in">MaybeAddFile</span>(v, level, *base_iter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">MaybeAddFile</span>(v, level, added_file);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add remaining base files</span></span><br><span class="line">      <span class="keyword">for</span> (; base_iter != base_end; ++base_iter) &#123;</span><br><span class="line">        <span class="built_in">MaybeAddFile</span>(v, level, *base_iter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">      <span class="comment">// Make sure there is no overlap in levels &gt; 0</span></span><br><span class="line">      <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">1</span>; i &lt; v-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> InternalKey&amp; prev_end = v-&gt;files_[level][i - <span class="number">1</span>]-&gt;largest;</span><br><span class="line">          <span class="keyword">const</span> InternalKey&amp; this_begin = v-&gt;files_[level][i]-&gt;smallest;</span><br><span class="line">          <span class="keyword">if</span> (vset_-&gt;icmp_.<span class="built_in">Compare</span>(prev_end, this_begin) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;overlapping ranges in same level %s vs. %s\n&quot;</span>,</span><br><span class="line">                    prev_end.<span class="built_in">DebugString</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">                    this_begin.<span class="built_in">DebugString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MaybeAddFile</span><span class="params">(Version* v, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (levels_[level].deleted_files.<span class="built_in">count</span>(f-&gt;number) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// File is deleted: do nothing</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::vector&lt;FileMetaData*&gt;* files = &amp;v-&gt;files_[level];</span><br><span class="line">      <span class="keyword">if</span> (level &gt; <span class="number">0</span> &amp;&amp; !files-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// Must not overlap</span></span><br><span class="line">        <span class="built_in">assert</span>(vset_-&gt;icmp_.<span class="built_in">Compare</span>((*files)[files-&gt;<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;largest,</span><br><span class="line">                                    f-&gt;smallest) &lt; <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      f-&gt;refs++;</span><br><span class="line">      files-&gt;<span class="built_in">push_back</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>VersionSet::Builder</code> 中首先定义了一个比较器 <code>BySmallestKey</code>，其会按照文件信息中的 <code>smallest</code> 对文件信息集合 <code>FileSet</code> 中存储的 <code>FileMetaData</code> 排序；定义的结构体 <code>LevelState</code> 中则包括删除的文件编号列表 <code>deleted_files</code> 和新增的文件集合 <code>added_files</code>，<code>VersionSet::Builder</code> 的成员 <code>levels_</code> 则储存所有 Level 的 <code>LevelState</code>。<code>Builder</code> 的构造和析构完成必要的内存申请和释放，成员还包括版本集 <code>vset_</code> 和基础版本 <code>base</code>，核心接口为 <code>Apply</code> 和 <code>SaveTo</code>。<code>Apply</code> 函数中先忽略 <code>compact_pointer_</code> 相关的操作，剩下的就是将 <code>edit</code> 中的增删文件信息插入到 <code>Builder::levels_</code> 里；而 <code>SaveTo</code> 则是将基础版本 <code>base</code> 中的文件信息和 <code>edit</code> 中的增删文件信息合并，按顺序插入到新版本 <code>v</code> 里。</p>
<p>接着来看 <code>VersionSet</code> 的定义 <a href="https://github.com/google/leveldb/blob/master/db/version_set.h"><code>db/version_set.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VersionSet</span>(<span class="keyword">const</span> std::string&amp; dbname, <span class="keyword">const</span> Options* options,</span><br><span class="line">             TableCache* table_cache, <span class="keyword">const</span> InternalKeyComparator*);</span><br><span class="line">  <span class="built_in">VersionSet</span>(<span class="keyword">const</span> VersionSet&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  VersionSet&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> VersionSet&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">VersionSet</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Apply *edit to the current version to form a new descriptor that</span></span><br><span class="line">  <span class="comment">// is both saved to persistent state and installed as the new</span></span><br><span class="line">  <span class="comment">// current version.  Will release *mu while actually writing to the file.</span></span><br><span class="line">  <span class="comment">// REQUIRES: *mu is held on entry.</span></span><br><span class="line">  <span class="comment">// REQUIRES: no other thread concurrently calls LogAndApply()</span></span><br><span class="line">  <span class="function">Status <span class="title">LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span></span></span><br><span class="line"><span class="function">      <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mu)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recover the last saved descriptor from persistent storage.</span></span><br><span class="line">  <span class="function">Status <span class="title">Recover</span><span class="params">(<span class="keyword">bool</span>* save_manifest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the current version.</span></span><br><span class="line">  <span class="function">Version* <span class="title">current</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> current_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the current manifest file number</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">ManifestFileNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> manifest_file_number_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate and return a new file number</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">NewFileNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> next_file_number_++; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Arrange to reuse &quot;file_number&quot; unless a newer file number has</span></span><br><span class="line">  <span class="comment">// already been allocated.</span></span><br><span class="line">  <span class="comment">// REQUIRES: &quot;file_number&quot; was returned by a call to NewFileNumber().</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReuseFileNumber</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (next_file_number_ == file_number + <span class="number">1</span>) &#123;</span><br><span class="line">      next_file_number_ = file_number;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the number of Table files at the specified level.</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">NumLevelFiles</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the combined file size of all files at the specified level.</span></span><br><span class="line">  <span class="function"><span class="keyword">int64_t</span> <span class="title">NumLevelBytes</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the last sequence number.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">LastSequence</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> last_sequence_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the last sequence number to s.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetLastSequence</span><span class="params">(<span class="keyword">uint64_t</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(s &gt;= last_sequence_);</span><br><span class="line">    last_sequence_ = s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark the specified file number as used.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MarkFileNumberUsed</span><span class="params">(<span class="keyword">uint64_t</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the current log file number.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">LogNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> log_number_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the log file number for the log file that is currently</span></span><br><span class="line">  <span class="comment">// being compacted, or zero if there is no such log file.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">PrevLogNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> prev_log_number_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick level and inputs for a new compaction.</span></span><br><span class="line">  <span class="comment">// Returns nullptr if there is no compaction to be done.</span></span><br><span class="line">  <span class="comment">// Otherwise returns a pointer to a heap-allocated object that</span></span><br><span class="line">  <span class="comment">// describes the compaction.  Caller should delete the result.</span></span><br><span class="line">  <span class="function">Compaction* <span class="title">PickCompaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a compaction object for compacting the range [begin,end] in</span></span><br><span class="line">  <span class="comment">// the specified level.  Returns nullptr if there is nothing in that</span></span><br><span class="line">  <span class="comment">// level that overlaps the specified range.  Caller should delete</span></span><br><span class="line">  <span class="comment">// the result.</span></span><br><span class="line">  <span class="function">Compaction* <span class="title">CompactRange</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">const</span> InternalKey* begin,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> InternalKey* end)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the maximum overlapping data (in bytes) at next level for any</span></span><br><span class="line">  <span class="comment">// file at a level &gt;= 1.</span></span><br><span class="line">  <span class="function"><span class="keyword">int64_t</span> <span class="title">MaxNextLevelOverlappingBytes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an iterator that reads over the compaction inputs for &quot;*c&quot;.</span></span><br><span class="line">  <span class="comment">// The caller should delete the iterator when no longer needed.</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">MakeInputIterator</span><span class="params">(Compaction* c)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff some level needs a compaction.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Version* v = current_;</span><br><span class="line">    <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add all files listed in any live version to *live.</span></span><br><span class="line">  <span class="comment">// May also mutate some internal state.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddLiveFiles</span><span class="params">(std::set&lt;<span class="keyword">uint64_t</span>&gt;* live)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the approximate offset in the database of the data for</span></span><br><span class="line">  <span class="comment">// &quot;key&quot; as of version &quot;v&quot;.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">ApproximateOffsetOf</span><span class="params">(Version* v, <span class="keyword">const</span> InternalKey&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a human-readable short (single-line) summary of the number</span></span><br><span class="line">  <span class="comment">// of files per level.  Uses *scratch as backing store.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LevelSummaryStorage</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">LevelSummary</span><span class="params">(LevelSummaryStorage* scratch)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Compaction</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Version</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ReuseManifest</span><span class="params">(<span class="keyword">const</span> std::string&amp; dscname, <span class="keyword">const</span> std::string&amp; dscbase)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Finalize</span><span class="params">(Version* v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetRange</span><span class="params">(<span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; inputs, InternalKey* smallest,</span></span></span><br><span class="line"><span class="params"><span class="function">                InternalKey* largest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetRange2</span><span class="params">(<span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; inputs1,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; inputs2,</span></span></span><br><span class="line"><span class="params"><span class="function">                 InternalKey* smallest, InternalKey* largest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetupOtherInputs</span><span class="params">(Compaction* c)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save current contents to *log</span></span><br><span class="line">  <span class="function">Status <span class="title">WriteSnapshot</span><span class="params">(log::Writer* log)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AppendVersion</span><span class="params">(Version* v)</span></span>;</span><br><span class="line"></span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> std::string dbname_;</span><br><span class="line">  <span class="keyword">const</span> Options* <span class="keyword">const</span> options_;</span><br><span class="line">  TableCache* <span class="keyword">const</span> table_cache_;</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator icmp_;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> manifest_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence_;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Opened lazily</span></span><br><span class="line">  WritableFile* descriptor_file_;</span><br><span class="line">  log::Writer* descriptor_log_;</span><br><span class="line">  Version dummy_versions_;  <span class="comment">// Head of circular doubly-linked list of versions.</span></span><br><span class="line">  Version* current_;        <span class="comment">// == dummy_versions_.prev_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Per-level key at which the next compaction at that level should start.</span></span><br><span class="line">  <span class="comment">// Either an empty string, or a valid InternalKey.</span></span><br><span class="line">  std::string compact_pointer_[config::kNumLevels];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义很长，先放着，继续看实现的部分（顺序经过重排）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::Ref</span><span class="params">()</span> </span>&#123; ++refs_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::Unref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="keyword">this</span> != &amp;vset_-&gt;dummy_versions_);</span><br><span class="line">  <span class="built_in">assert</span>(refs_ &gt;= <span class="number">1</span>);</span><br><span class="line">  --refs_;</span><br><span class="line">  <span class="keyword">if</span> (refs_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Version::~<span class="built_in">Version</span>() &#123;</span><br><span class="line">  <span class="built_in">assert</span>(refs_ == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove from linked list</span></span><br><span class="line">  prev_-&gt;next_ = next_;</span><br><span class="line">  next_-&gt;prev_ = prev_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop references to files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][i];</span><br><span class="line">      <span class="built_in">assert</span>(f-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">      f-&gt;refs--;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VersionSet::<span class="built_in">VersionSet</span>(<span class="keyword">const</span> std::string&amp; dbname, <span class="keyword">const</span> Options* options,</span><br><span class="line">                       TableCache* table_cache,</span><br><span class="line">                       <span class="keyword">const</span> InternalKeyComparator* cmp)</span><br><span class="line">    : <span class="built_in">env_</span>(options-&gt;env),</span><br><span class="line">      <span class="built_in">dbname_</span>(dbname),</span><br><span class="line">      <span class="built_in">options_</span>(options),</span><br><span class="line">      <span class="built_in">table_cache_</span>(table_cache),</span><br><span class="line">      <span class="built_in">icmp_</span>(*cmp),</span><br><span class="line">      <span class="built_in">next_file_number_</span>(<span class="number">2</span>),</span><br><span class="line">      <span class="built_in">manifest_file_number_</span>(<span class="number">0</span>),  <span class="comment">// Filled by Recover()</span></span><br><span class="line">      <span class="built_in">last_sequence_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">log_number_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">prev_log_number_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">descriptor_file_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">descriptor_log_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">dummy_versions_</span>(<span class="keyword">this</span>),</span><br><span class="line">      <span class="built_in">current_</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="built_in">AppendVersion</span>(<span class="keyword">new</span> <span class="built_in">Version</span>(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VersionSet::~<span class="built_in">VersionSet</span>() &#123;</span><br><span class="line">  current_-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="built_in">assert</span>(dummy_versions_.next_ == &amp;dummy_versions_);  <span class="comment">// List must be empty</span></span><br><span class="line">  <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">  <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::AppendVersion</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make &quot;v&quot; current</span></span><br><span class="line">  <span class="built_in">assert</span>(v-&gt;refs_ == <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">assert</span>(v != current_);</span><br><span class="line">  <span class="keyword">if</span> (current_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    current_-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  current_ = v;</span><br><span class="line">  v-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append to linked list</span></span><br><span class="line">  v-&gt;prev_ = dummy_versions_.prev_;</span><br><span class="line">  v-&gt;next_ = &amp;dummy_versions_;</span><br><span class="line">  v-&gt;prev_-&gt;next_ = v;</span><br><span class="line">  v-&gt;next_-&gt;prev_ = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>VersionSet</code> 构造函数的参数包括数据库的 <code>name</code> 和 <code>options</code>，缓存 <code>table_cache</code> 以及内部比较器 <code>cmp</code>。大部分成员变量都初始化为 0 或 <code>nullptr</code>，值得注意的是 <code>next_file_number_=2</code>，还有 <code>dummy_versions_(this)</code>。<code>dummpy_versions_</code> 注释中说明了是版本双向链表的头部，不会有其他实际功能。构造函数中会执行 <code>AppendVersion</code> 增加一个新版本，也就是在双向链表的尾部插入版本 <code>v</code>，并且将 <code>current_</code> 指向这个最新的版本；而析构函数中会要求当 <code>current_</code> 降低引用计数、完成可能的析构后，<code>dummy_versions_</code> 所指向的双向链表为空。继续看：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (edit-&gt;has_log_number_) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">    <span class="built_in">assert</span>(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    edit-&gt;<span class="built_in">SetLogNumber</span>(log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line">    edit-&gt;<span class="built_in">SetPrevLogNumber</span>(prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  edit-&gt;<span class="built_in">SetNextFile</span>(next_file_number_);</span><br><span class="line">  edit-&gt;<span class="built_in">SetLastSequence</span>(last_sequence_);</span><br><span class="line"></span><br><span class="line">  Version* v = <span class="keyword">new</span> <span class="built_in">Version</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">    builder.<span class="built_in">Apply</span>(edit);</span><br><span class="line">    builder.<span class="built_in">SaveTo</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Finalize</span>(v);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line">  <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line">  std::string new_manifest_file;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">    <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">    <span class="built_in">assert</span>(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">    new_manifest_file = <span class="built_in">DescriptorFileName</span>(dbname_, manifest_file_number_);</span><br><span class="line">    edit-&gt;<span class="built_in">SetNextFile</span>(next_file_number_);</span><br><span class="line">    s = env_-&gt;<span class="built_in">NewWritableFile</span>(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      descriptor_log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(descriptor_file_);</span><br><span class="line">      s = <span class="built_in">WriteSnapshot</span>(descriptor_log_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">  &#123;</span><br><span class="line">    mu-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      std::string record;</span><br><span class="line">      edit-&gt;<span class="built_in">EncodeTo</span>(&amp;record);</span><br><span class="line">      s = descriptor_log_-&gt;<span class="built_in">AddRecord</span>(record);</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        s = descriptor_file_-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="built_in">Log</span>(options_-&gt;info_log, <span class="string">&quot;MANIFEST write: %s\n&quot;</span>, s.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">    <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; !new_manifest_file.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      s = <span class="built_in">SetCurrentFile</span>(env_, dbname_, manifest_file_number_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install the new version</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">AppendVersion</span>(v);</span><br><span class="line">    log_number_ = edit-&gt;log_number_;</span><br><span class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">    <span class="keyword">if</span> (!new_manifest_file.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">      descriptor_log_ = <span class="literal">nullptr</span>;</span><br><span class="line">      descriptor_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">      env_-&gt;<span class="built_in">DeleteFile</span>(new_manifest_file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(config::kL0_CompactionTrigger);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = <span class="built_in">TotalFileSize</span>(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / <span class="built_in">MaxBytesForLevel</span>(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心接口 <code>LogAndApply</code> 会根据当前版本 <code>current_</code> 和修订部分 <code>edit</code>，合成一个新版本 <code>v</code>，而后将修订的记录写入 Manifest 文件中，最后将新版本 <code>AppendVersion</code> 到版本集中作为新的 <code>current_</code>，这样就完成了一个新版本的构建。而 <code>Recover</code> 则对应从 Manifest 中恢复版本的过程。由于 <code>Manifest</code> 记录了所有的版本变更信息，使用 <code>VersionSet::Builder</code> 逐个 <code>Apply</code> 就可以获得存储的最新版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::Recover</span><span class="params">(<span class="keyword">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LogReporter</span> :</span> <span class="keyword">public</span> log::Reader::Reporter &#123;</span><br><span class="line">    Status* status;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">const</span> Status&amp; s)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;status-&gt;<span class="built_in">ok</span>()) *<span class="keyword">this</span>-&gt;status = s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read &quot;CURRENT&quot; file, which contains a pointer to the current manifest file</span></span><br><span class="line">  std::string current;</span><br><span class="line">  Status s = <span class="built_in">ReadFileToString</span>(env_, <span class="built_in">CurrentFileName</span>(dbname_), &amp;current);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (current.<span class="built_in">empty</span>() || current[current.<span class="built_in">size</span>() - <span class="number">1</span>] != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;CURRENT file does not end with newline&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  current.<span class="built_in">resize</span>(current.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  std::string dscname = dbname_ + <span class="string">&quot;/&quot;</span> + current;</span><br><span class="line">  SequentialFile* file;</span><br><span class="line">  s = env_-&gt;<span class="built_in">NewSequentialFile</span>(dscname, &amp;file);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">IsNotFound</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;CURRENT points to a non-existent file&quot;</span>,</span><br><span class="line">                                s.<span class="built_in">ToString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> have_log_number = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> have_prev_log_number = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> have_next_file = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> have_last_sequence = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number = <span class="number">0</span>;</span><br><span class="line">  <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    LogReporter reporter;</span><br><span class="line">    reporter.status = &amp;s;</span><br><span class="line">    <span class="function">log::Reader <span class="title">reader</span><span class="params">(file, &amp;reporter, <span class="literal">true</span> <span class="comment">/*checksum*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="number">0</span> <span class="comment">/*initial_offset*/</span>)</span></span>;</span><br><span class="line">    Slice record;</span><br><span class="line">    std::string scratch;</span><br><span class="line">    <span class="keyword">while</span> (reader.<span class="built_in">ReadRecord</span>(&amp;record, &amp;scratch) &amp;&amp; s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      VersionEdit edit;</span><br><span class="line">      s = edit.<span class="built_in">DecodeFrom</span>(record);</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edit.has_comparator_ &amp;&amp;</span><br><span class="line">            edit.comparator_ != icmp_.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Name</span>()) &#123;</span><br><span class="line">          s = Status::<span class="built_in">InvalidArgument</span>(</span><br><span class="line">              edit.comparator_ + <span class="string">&quot; does not match existing comparator &quot;</span>,</span><br><span class="line">              icmp_.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Name</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        builder.<span class="built_in">Apply</span>(&amp;edit);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (edit.has_log_number_) &#123;</span><br><span class="line">        log_number = edit.log_number_;</span><br><span class="line">        have_log_number = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (edit.has_prev_log_number_) &#123;</span><br><span class="line">        prev_log_number = edit.prev_log_number_;</span><br><span class="line">        have_prev_log_number = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (edit.has_next_file_number_) &#123;</span><br><span class="line">        next_file = edit.next_file_number_;</span><br><span class="line">        have_next_file = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (edit.has_last_sequence_) &#123;</span><br><span class="line">        last_sequence = edit.last_sequence_;</span><br><span class="line">        have_last_sequence = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> file;</span><br><span class="line">  file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!have_next_file) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;no meta-nextfile entry in descriptor&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_log_number) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;no meta-lognumber entry in descriptor&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_last_sequence) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;no last-sequence-number entry in descriptor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_prev_log_number) &#123;</span><br><span class="line">      prev_log_number = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MarkFileNumberUsed</span>(prev_log_number);</span><br><span class="line">    <span class="built_in">MarkFileNumberUsed</span>(log_number);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    Version* v = <span class="keyword">new</span> <span class="built_in">Version</span>(<span class="keyword">this</span>);</span><br><span class="line">    builder.<span class="built_in">SaveTo</span>(v);</span><br><span class="line">    <span class="comment">// Install recovered version</span></span><br><span class="line">    <span class="built_in">Finalize</span>(v);</span><br><span class="line">    <span class="built_in">AppendVersion</span>(v);</span><br><span class="line">    manifest_file_number_ = next_file;</span><br><span class="line">    next_file_number_ = next_file + <span class="number">1</span>;</span><br><span class="line">    last_sequence_ = last_sequence;</span><br><span class="line">    log_number_ = log_number;</span><br><span class="line">    prev_log_number_ = prev_log_number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if we can reuse the existing MANIFEST file.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ReuseManifest</span>(dscname, current)) &#123;</span><br><span class="line">      <span class="comment">// No need to save new manifest</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VersionSet::ReuseManifest</span><span class="params">(<span class="keyword">const</span> std::string&amp; dscname,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> std::string&amp; dscbase)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!options_-&gt;reuse_logs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  FileType manifest_type;</span><br><span class="line">  <span class="keyword">uint64_t</span> manifest_number;</span><br><span class="line">  <span class="keyword">uint64_t</span> manifest_size;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ParseFileName</span>(dscbase, &amp;manifest_number, &amp;manifest_type) ||</span><br><span class="line">      manifest_type != kDescriptorFile ||</span><br><span class="line">      !env_-&gt;<span class="built_in">GetFileSize</span>(dscname, &amp;manifest_size).<span class="built_in">ok</span>() ||</span><br><span class="line">      <span class="comment">// Make new compacted MANIFEST if old one is too big</span></span><br><span class="line">      manifest_size &gt;= <span class="built_in">TargetFileSize</span>(options_)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(descriptor_log_ == <span class="literal">nullptr</span>);</span><br><span class="line">  Status r = env_-&gt;<span class="built_in">NewAppendableFile</span>(dscname, &amp;descriptor_file_);</span><br><span class="line">  <span class="keyword">if</span> (!r.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">Log</span>(options_-&gt;info_log, <span class="string">&quot;Reuse MANIFEST: %s\n&quot;</span>, r.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">assert</span>(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Log</span>(options_-&gt;info_log, <span class="string">&quot;Reusing MANIFEST %s\n&quot;</span>, dscname.<span class="built_in">c_str</span>());</span><br><span class="line">  descriptor_log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(descriptor_file_, manifest_size);</span><br><span class="line">  manifest_file_number_ = manifest_number;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::MarkFileNumberUsed</span><span class="params">(<span class="keyword">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (next_file_number_ &lt;= number) &#123;</span><br><span class="line">    next_file_number_ = number + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇分析了版本管理相关的代码，包括 <code>VersionEdit</code>、<code>Version</code> 和 <code>VersionSet</code> 的实现。<code>VersionSet</code> 还有一大部分代码是与 Compaction 相关的，将会在下篇中继续分析。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
      </tags>
  </entry>
</search>
