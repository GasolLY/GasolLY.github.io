<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2021/06/17/About-Me/</url>
    <content><![CDATA[<blockquote>
<p>Done is better than perfect.</p>
</blockquote>
<p>姓名：潘许飞 - Gasol</p>
<p>学习/工作：HUST - WNLO</p>
<p>邮箱：<a href="mailto:&#49;&#49;&#x34;&#x32;&#x38;&#49;&#50;&#53;&#x32;&#x35;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#109;">&#49;&#49;&#x34;&#x32;&#x38;&#49;&#50;&#53;&#x32;&#x35;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#109;</a></p>
<p><img src="https://pic.imgdb.cn/item/60cb0de4844ef46bb21f61a5.jpg"></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>SPDK调研</title>
    <url>/2021/06/17/SPDK%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="一．SPDK简介"><a href="#一．SPDK简介" class="headerlink" title="一．SPDK简介"></a>一．SPDK简介</h2><h3 id="1-SPDK的起源"><a href="#1-SPDK的起源" class="headerlink" title="1.SPDK的起源"></a>1.SPDK的起源</h3><p>固态存储设备正在取代数据中心。目前这一代的闪存存储，比起传统的磁盘设备，在性能（performance）、功耗（power consumption）和机架密度（rack density）上具有显著的优势。这些优势将会继续增大，使闪存存储作为下一代存储设备进入市场。</p>
<p>用户使用现在的固态设备，比如Intel® SSD DC P3700 Series Non-Volatile Memory Express（NVMe）驱动，面临一个主要的挑战：因为吞吐量和延迟性能比传统的磁盘好太多，现在总的处理时间中，存储软件占用了更大的比例。换句话说，存储软件栈的性能和效率在整个存储系统中越来越重要。随着存储设备继续发展，它将面临远远超过正在使用的软件体系结构的风险（即存储设备受制于相关软件的不足而不能发挥全部性能），在接下来的几年中，存储设备将会继续发展到一个令人难以置信的地步。</p>
<p>为了帮助存储OEM（设备代工厂）和ISV（独立软件开发商）整合硬件，Intel构造了一系列驱动，以及一个完善的、端对端的参考存储体系结构，被命名为Storage Performance Development Kit（SPDK）。SPDK的目标是通过同时使用Intel的网络技术，处理技术和存储技术来提高突出显著的效率和性能。通过运行为硬件设计的软件，SPDK已经证明很容易达到每秒钟数百万次I/O读取，通过使用许多处理器核心和许多NVMe驱动去存储，而不需要额外卸载硬件。Intel在BSD license许可协议下通过Github分发提供其全部的Linux参考架构的源代码。博客、邮件列表和额外文档可以在spdk.io中找到。</p>
<span id="more"></span>
<h3 id="2-SPDK的整体架构"><a href="#2-SPDK的整体架构" class="headerlink" title="2.SPDK的整体架构"></a>2.SPDK的整体架构</h3><p>下图为SPDK的整体架构图：</p>
<p><img src="https://pic.imgdb.cn/item/60cb0904844ef46bb2ee63d9.png" alt="SPDK架构图"></p>
<p>按照自底层向上层的顺序，分为：</p>
<ul>
<li><p>硬件驱动</p>
<blockquote>
<p>NVMe Driver：SPDK的基础组件，这个高优化无锁的驱动提供了高扩展性，高效性和高性能。</p>
</blockquote>
<blockquote>
<p>Inter QuickData Technology：也称为Intel I/O Acceleration Technology（Inter IOAT，英特尔I/O加速技术），这是一种基于Xeon处理器平台上的copy offload引擎。通过提供用户空间访问，减少了DMA数据移动的阈值，允许对小尺寸I/O或NTB的更好利用。</p>
</blockquote>
</li>
<li><p>后端块设备</p>
<blockquote>
<p>NVMe over Fabrics（NVMe-oF）initiator：从程序员的角度来看，本地SPDK NVMe驱动和NVMe-oF启动器共享一套共同的API命令。这意味着，本地/远程复制非常容易实现。</p>
</blockquote>
<blockquote>
<p>Ceph RADOS Block Device（RBD）：使Ceph成为SPDK的后端设备，比如这可能允许Ceph用作另一个存储层。</p>
</blockquote>
<blockquote>
<p>Blobstore Block Device：由SPDK Blobstore分配的块设备，是虚拟机或数据库可以与之交互的虚拟设备。这些设备享有SPDK基础架构的优势，这意味着零锁定和令人难以置信的可扩展性能。</p>
</blockquote>
<blockquote>
<p>Linux Asynchrounous I/O（AIO）：允许SPDK与内核设备（比如机械硬盘）交互。</p>
</blockquote>
</li>
<li><p>存储服务</p>
<blockquote>
<p>Block device abstration layer（bdev）：这种通用的块设备抽象是连接到各种不同设备驱动和块设备的存储协议的粘合剂。还在块层中提供灵活的API用于额外的用户功能（磁盘阵列，压缩，去冗等等）。</p>
</blockquote>
<blockquote>
<p>Blobstore：为SPDK实现一个高精简的文件式语义（非POSIX）。这可以为数据库，容器，虚拟机或其他不依赖于大部分POSIX文件系统功能集（比如用户访问控制）的工作负载提供高性能基础。</p>
</blockquote>
</li>
<li><p>存储协议</p>
<blockquote>
<p>iSCSI target：建立了通过以太网的块流量规范，大约是内核LIO效率的两倍。现在的版本默认使用内核TCP/IP协议栈。</p>
</blockquote>
<blockquote>
<p>NVMe-oF target：实现了新NVMe-oF规范。虽然这取决于RDMA硬件，NVMe-oF的目标可以为每个CPU核提供高达40Gbps的流量。</p>
</blockquote>
<blockquote>
<p>vhost-scsi target：KVM/QEMU的功能利用了SPDK NVMe驱动，使得访客虚拟机访问存储设备时延迟更低，使得I/O密集型工作负载的整体CPU负载减低。</p>
</blockquote>
</li>
</ul>
<h2 id="二、SPDK的主要优势与关键技术"><a href="#二、SPDK的主要优势与关键技术" class="headerlink" title="二、SPDK的主要优势与关键技术"></a>二、SPDK的主要优势与关键技术</h2><h3 id="1-SPDK的主要优势与关键技术"><a href="#1-SPDK的主要优势与关键技术" class="headerlink" title="1.SPDK的主要优势与关键技术"></a>1.SPDK的主要优势与关键技术</h3><p>SPDK具有的优势主要包括：</p>
<blockquote>
<p>高性能、高拓展性、零拷贝、高度并行的访问、可以从用户空间直接访问SSD。</p>
</blockquote>
<p>SPDK通过使用多种关键技术来实现高性能：</p>
<ul>
<li><p>将所有必要的驱动程序移到用户空间中，这避免了系统调用，并允许从应用程序进行零拷贝访问。</p>
</li>
<li><p>通过轮询硬件来完成而不是依赖中断，这可以降低总延迟和延迟差异。</p>
</li>
<li><p>避免所有在I / O路径中的锁，而是依靠消息传递。</p>
</li>
</ul>
<p>SPDK的基础是用户空间，轮询模式，异步，无锁的NVMe驱动程序。这提供了零拷贝，高度并行的访问，可从用户空间应用程序直接访问SSD。该驱动程序被编写为具有单个公共标头的C库。</p>
<p>SPDK还提供了完整的块堆栈作为用户空间库，该库执行与操作系统中的块堆栈相同的许多操作。这包括统一不同存储设备之间的接口，排队以处理诸如内存不足或I / O挂起之类的情况以及逻辑卷管理。</p>
<p>最后，SPDK在这些组件之上提供了NVMe-oF，iSCSI和虚拟主机服务器，这些服务器能够通过网络或其他进程为磁盘提供服务。用于NVMe-oF和iSCSI的标准Linux内核启动器可与这些目标以及具有vhost的QEMU进行交互。与其他实现相比，这些服务器的CPU效率最高可提高一个数量级。这些目标可以用作如何实现高性能存储目标的示例，也可以用作生产部署的基础。</p>
<p><img src="https://pic.imgdb.cn/item/60cb0920844ef46bb2ef7f97.png" alt="SPDK IO Stack"></p>
<h2 id="三．SPDK关键技术介绍"><a href="#三．SPDK关键技术介绍" class="headerlink" title="三．SPDK关键技术介绍"></a>三．SPDK关键技术介绍</h2><h3 id="1-NVMe-Driver"><a href="#1-NVMe-Driver" class="headerlink" title="1.NVMe Driver"></a>1.NVMe Driver</h3><p>（1）NVMe Driver整体情况介绍</p>
<p>NVMe驱动程序是一个C语言库，可以直接链接到一个应用程序中，该应用程序对外提供与NVMe SSD的直接的、零拷贝数据传输。它是完全被动的，这意味着它不产生任何线程，并且仅响应于来自应用程序本身的函数调用而执行操作。该库通过直接将PCI BAR映射到本地进程并执行MMIO来控制NVMe设备。I / O是通过队列对异步提交的。</p>
<p>最近，对该库进行了改进，使其还可以通过基于Fabric的NVMe连接到远程NVMe设备。用户现在既可以通过本地PCI总线也可以通过NVMe over Fabrics，调用spdk_nvme_probe（），发现设备。</p>
<p>NVMe Driver的公共接口声明于spdk/nvme.h中。主要包括如下命令：</p>
<p><img src="https://pic.imgdb.cn/item/60cb093d844ef46bb2f0a087.png" alt="SPDK NVMe API"></p>
<p>（2）NVMe Driver关于IO提交的设计</p>
<p>NVMe Driver使用nvme_ns_cmd_xxx命令将IO提交到NVMe命名空间。NVMe驱动程序在命令中指定的队列对上将I / O请求作为NVMe提交队列条目提交。函数会立即返回，在IO命令完成之前就已经返回。应用程序必须通过调用<code>spdk_nvme_qpair_process_completions()</code>函数轮询队列对，以接收完成回调。</p>
<p>（3）NVMe Driver对于拓展性的支持</p>
<p>NVMe队列对（结构spdk_nvme_qpair）为I / O提供并行提交路径。I / O可以同时从不同的线程在多个队列对上提交。队列对不包含锁或原子，因此，给定的队列对一次只能由单个线程使用。NVMe驱动程序不强制执行此要求（这样做将需要锁定），并且违反此要求将导致未定义的行为。</p>
<p>允许的队列对数由NVMe SSD本身决定。该规范可以支持数千个，但是大多数设备支持32至128个。该规范不能保证每个队列对的性能，但是实际上，仅使用一个队列对就几乎可以实现设备的全部性能。例如，如果设备声称能够在队列深度128的情况下，每秒达到450,000 I / O，那么实际上驱动程序使用的是4个队列对（每个队列深度为32）还是单个队列对（队列深度为） 128则无关紧要。</p>
<p>鉴于以上所述，使用SPDK的应用程序最简单的线程模型是在池中生成固定数量的线程，并将单个NVMe队列对专用于每个线程。进一步的改进是将每个线程固定到一个单独的CPU内核，并且SPDK文档通常会互换使用“ CPU内核”和“线程”，因为我们牢记了这种线程模型。</p>
<p>NVMe驱动程序不对I / O路径进行任何锁定，因此只要每个新线程专用一个队列对和CPU内核，它就可以根据每个线程的性能进行线性扩展。为了充分利用这种扩展，应用程序应考虑组织其内部数据结构，以便将数据专门分配给单个线程。所有需要数据的操作都应通过向拥有线程发送请求来完成。与锁定体系结构相比，这导致了消息传递体系结构，并且将导致跨CPU内核的出色扩展。</p>
<h2 id="四．参考资料"><a href="#四．参考资料" class="headerlink" title="四．参考资料"></a>四．参考资料</h2><blockquote>
<p>1.Intel官网：《Introduction to the Storage Performance Development Kit (SPDK)》；链接：<a href="https://software.intel.com/content/www/cn/zh/develop/articles/introduction-to-the-storage-performance-development-kit-spdk.html?wapkw=spdk">https://software.intel.com/content/www/cn/zh/develop/articles/introduction-to-the-storage-performance-development-kit-spdk.html?wapkw=spdk</a></p>
</blockquote>
<blockquote>
<p>2.SPDK文档；链接：<a href="https://spdk.io/doc/about.html">https://spdk.io/doc/about.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>SPDK</category>
      </categories>
      <tags>
        <tag>SPDK</tag>
        <tag>OCSSD</tag>
        <tag>用户态IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtual OCSSD 环境搭建</title>
    <url>/2021/06/17/Virtual-OCSSD-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="一、Virtual-OpenChannel-SSD-环境配置"><a href="#一、Virtual-OpenChannel-SSD-环境配置" class="headerlink" title="一、Virtual OpenChannel SSD 环境配置"></a>一、Virtual OpenChannel SSD 环境配置</h2><p>1.下载Qemu-nvme的源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/OpenChannelSSD/qemu-nvme</span><br></pre></td></tr></table></figure>

<p>2.进入qemu-nvme目录下，运行配置脚本，make编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> qemu-nvme</span><br><span class="line">./configure --target-list=x86_64-softmmu --prefix=<span class="variable">$HOME</span>/qemu-nvme</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>3.在完成上述步骤后，开始正式配置环境。首先，在物理机上创建一个ocssd格式的文件，例如ocssd.img。</p>
<blockquote>
<p>（若提示ocssd参数无效等报错，可能是因为实际使用的是物理机内置的qemu-img，而不是qemu-nvme make编译后生成的qemu-img。将下列命令的qemu-img更改为qemu-nvme/qemu-img代替即可。）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-img create -f ocssd -o num_grp=2,num_pu=4,num_chk=60 ocssd.img</span><br></pre></td></tr></table></figure>

<p>4.创建一个文件，作为模拟的磁盘，用来安装linux系统。</p>
<blockquote>
<p>（在物理机上运行qemu虚拟机，虚拟机内加载模拟磁盘的文件与模拟ocssd的文件。最终的实验环境是在qemu虚拟机内部的linux子系统上运行。）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo qemu-img create -f raw /home/gasol/qemu-nvme/ubuntu40.raw 40G</span><br></pre></td></tr></table></figure>

<p>5.下载ubuntu镜像，并在第4步建立的模拟磁盘的文件中，安装ubuntu系统。</p>
<blockquote>
<p>（此时可能会提示qemu-system-x86_64: warning: host doesn’t support requested feature: CPUID.80000001H:ECX.svm [bit 2]。这是正常的，忽略即可。正常情况下，在输出提示信息后，会弹出新的安装窗口，点击安装即可）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-x86_64 -cdrom /home/polarsparc/ubuntu-18.04.1-desktop-amd64.iso -drive format=raw,file=/home/polarsparc/Downloads/VMs/vm-disk-1.raw -enable-kvm -m 2G -name vm-ubuntu-1</span><br></pre></td></tr></table></figure>

<p>6.在物理机系统上，挂载ocssd,并启动虚拟机。</p>
<blockquote>
<p>(注意：使用路径qemu-nvme/bin/下的qemu-system-x86_64运行，而不是采用系统内置的qemu-system-x86_64 )</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./bin/qemu-system-x86_64 -m 8G -enable-kvm ubuntu40.raw -blockdev ocssd,node-name=nvme01,file.driver=file,file.filename=ocssd.img -device nvme,drive=nvme01,serial=deadbeef,id=lnvm -cpu host</span><br></pre></td></tr></table></figure>

<p>7.在第6步虚拟机启动的情况下，利用VNC viewer连接，弹出窗口显示虚拟机运行情况。</p>
<blockquote>
<p>（若提示无vncviewer，安装对应包即可）（命令中连接的IP和端口与第6步的提示IP和端口相同）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vncviewer 127.0.0.1:5900</span><br></pre></td></tr></table></figure>

<p>8.在虚拟机启动后，可以通过运行以下命令，查看是否成功挂载ocssd设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nvme lnvm list</span><br></pre></td></tr></table></figure>

<h2 id="二、SPDK安装配置"><a href="#二、SPDK安装配置" class="headerlink" title="二、SPDK安装配置"></a>二、SPDK安装配置</h2><p>0.参考文档：<a href="https://spdk.io/doc/getting_started.html">https://spdk.io/doc/getting_started.html</a></p>
<p>1.按参考文档Getting started部分运行，即可编译安装SPDK，并可以通过运行<code>build/examples/identify</code>脚本列出系统上有效的NVME设备。</p>
<blockquote>
<p>（通过该脚本可以验证SPDK是否成功识别挂载的虚拟OCSSD）</p>
</blockquote>
<h2 id="三、关于可能遇到的git-clone与git-submodule速度过慢问题的解决方案"><a href="#三、关于可能遇到的git-clone与git-submodule速度过慢问题的解决方案" class="headerlink" title="三、关于可能遇到的git clone与git submodule速度过慢问题的解决方案"></a>三、关于可能遇到的git clone与git submodule速度过慢问题的解决方案</h2><p>0.参考文档：<a href="https://www.cnblogs.com/zhuchengchao/p/12076153.html">https://www.cnblogs.com/zhuchengchao/p/12076153.html</a></p>
<p>1.按照文档中的介绍，通过国内的gitee.com网站进行git clone，可以大幅度提升git clone的速率。</p>
<p>2.对于git submodule速度过慢的问题:</p>
<blockquote>
<p>例如在git clone spdk的代码后，若需要git submodule，只需打开spdk/.gitmodules，将其中需要下载的库通过gitee.com下载到本地，并修改.gitmodules内部的路径即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>QEMU</category>
      </categories>
      <tags>
        <tag>OCSSD</tag>
        <tag>QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/06/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>LevelDB源码分析——1.基本的数据结构</title>
    <url>/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="一．基本的数据结构"><a href="#一．基本的数据结构" class="headerlink" title="一．基本的数据结构"></a>一．基本的数据结构</h2><p>为了督促自己认真的阅读LevelDB源码，同时记录下相关的收获，避免阅后即忘，因此在Blog中记录下LevelDB源码分析的相关内容。</p>
<p>本文会介绍 LevelDB 中的基本数据结构，包括 <code>Slice</code>、<code>Hash</code>、<code>LRUCache</code>。</p>
<h3 id="1-字符串封装-Slice"><a href="#1-字符串封装-Slice" class="headerlink" title="1. 字符串封装 Slice"></a>1. 字符串封装 Slice</h3><p>Slice 定义于 <a href="https://github.com/google/leveldb/blob/master/include/leveldb/slice.h"><code>include/leveldb/slice.h</code></a>，源码不过百行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Slice is a simple structure containing a pointer into some external</span></span><br><span class="line"><span class="comment">// storage and a size.  The user of a Slice must ensure that the slice</span></span><br><span class="line"><span class="comment">// is not used after the corresponding external storage has been</span></span><br><span class="line"><span class="comment">// deallocated.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Multiple threads can invoke const methods on a Slice without</span></span><br><span class="line"><span class="comment">// external synchronization, but if any of the threads may call a</span></span><br><span class="line"><span class="comment">// non-const method, all threads accessing the same Slice must use</span></span><br><span class="line"><span class="comment">// external synchronization.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STORAGE_LEVELDB_INCLUDE_SLICE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORAGE_LEVELDB_INCLUDE_SLICE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/export.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"><span class="comment">//字符串处理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Slice</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create an empty slice.</span></span><br><span class="line">  <span class="built_in">Slice</span>() : <span class="built_in">data_</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">size_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to d[0,n-1].</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> <span class="keyword">char</span>* d, <span class="keyword">size_t</span> n) : <span class="built_in">data_</span>(d), <span class="built_in">size_</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to the contents of &quot;s&quot;</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> std::string&amp; s) : <span class="built_in">data_</span>(s.<span class="built_in">data</span>()), <span class="built_in">size_</span>(s.<span class="built_in">size</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to s[0,strlen(s)-1]</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s) : <span class="built_in">data_</span>(s), <span class="built_in">size_</span>(<span class="built_in">strlen</span>(s)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Intentionally copyable.</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> Slice&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  Slice&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Slice&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a pointer to the beginning of the referenced data</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the length (in bytes) of the referenced data</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true iff the length of the referenced data is zero</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_ == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the ith byte in the referenced data.</span></span><br><span class="line">  <span class="comment">// REQUIRES: n &lt; size()</span></span><br><span class="line">  <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &lt; <span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> data_[n];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Change this slice to refer to an empty array</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    size_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//移除数据的前n位</span></span><br><span class="line">  <span class="comment">// Drop the first &quot;n&quot; bytes from this slice.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove_prefix</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &lt;= <span class="built_in">size</span>());</span><br><span class="line">    data_ += n;</span><br><span class="line">    size_ -= n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a string that contains the copy of the referenced data.</span></span><br><span class="line">  <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">string</span>(data_, size_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Three-way comparison.  Returns value:</span></span><br><span class="line">  <span class="comment">//   &lt;  0 iff &quot;*this&quot; &lt;  &quot;b&quot;,</span></span><br><span class="line">  <span class="comment">//   == 0 iff &quot;*this&quot; == &quot;b&quot;,</span></span><br><span class="line">  <span class="comment">//   &gt;  0 iff &quot;*this&quot; &gt;  &quot;b&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//判断参数x是否是该slice的前缀</span></span><br><span class="line">  <span class="comment">// Return true iff &quot;x&quot; is a prefix of &quot;*this&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">starts_with</span><span class="params">(<span class="keyword">const</span> Slice&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((size_ &gt;= x.size_) &amp;&amp; (<span class="built_in">memcmp</span>(data_, x.data_, x.size_) == <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//成员变量：data_存储数据地址;size_记录数据长度</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;</span><br><span class="line">  <span class="keyword">size_t</span> size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">return</span></span> ((x.<span class="built_in">size</span>() == y.<span class="built_in">size</span>()) &amp;&amp;</span><br><span class="line">          (<span class="built_in">memcmp</span>(x.<span class="built_in">data</span>(), y.<span class="built_in">data</span>(), x.<span class="built_in">size</span>()) == <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123; <span class="keyword">return</span> !(x == y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Slice::compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> min_len = (size_ &lt; b.size_) ? size_ : b.size_;</span><br><span class="line">  <span class="keyword">int</span> r = <span class="built_in">memcmp</span>(data_, b.data_, min_len);</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size_ &lt; b.size_)</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_ &gt; b.size_)</span><br><span class="line">      r = +<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// STORAGE_LEVELDB_INCLUDE_SLICE_H_</span></span></span><br></pre></td></tr></table></figure>

<p>没有外部依赖，代码也非常清晰易懂。整个定义可以分为四个部分：构造、获取、修改和比较。</p>
<p><strong>构造</strong>：默认构造为空字符串，字符串构造提供了带长度和不带长度，并且支持默认的复制构造函数和赋值操作符（毕竟只有 <code>data_</code> 和 <code>size_</code> 两个属性）。</p>
<p><strong>获取</strong>：获取 <code>Slice</code> 的基本信息，支持导出为 <code>std::string</code>。</p>
<p><strong>修改</strong>：支持 <code>clear</code> 操作字符串清空，也支持 <code>remove_prefix</code> 将指定长度的前缀去除。注意 <code>data_</code> 的类型为 <code>const char *</code>，对应的字符串内容是不可修改的，<code>Slice</code> 只能修改字符串的起始位置。</p>
<p><strong>比较</strong>：<code>Slice::compare</code> 实现了非常严谨的字符串比较，返回 0/1/-1。注意为了提高性能，<code>operator==</code> 并没有直接调用 <code>Slice::compare</code>。</p>
<p>值得注意的是，<code>Slice</code> 本身并没有任何内存管理，仅仅是 C 风格字符串及其长度的封装。</p>
<h3 id="2-哈希函数-Hash"><a href="#2-哈希函数-Hash" class="headerlink" title="2. 哈希函数 Hash"></a>2. 哈希函数 Hash</h3><p>哈希函数定义于 <a href="https://github.com/google/leveldb/blob/master/util/hash.cc"><code>util/hash.[h/cc]</code></a>，源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/hash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/coding.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The FALLTHROUGH_INTENDED macro can be used to annotate implicit fall-through</span></span><br><span class="line"><span class="comment">// between switch labels. The real definition should be provided externally.</span></span><br><span class="line"><span class="comment">// This one is a fallback version for unsupported compilers.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FALLTHROUGH_INTENDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALLTHROUGH_INTENDED \</span></span><br><span class="line"><span class="meta">  do &#123;                       \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次按照四字节长度读取字节流中的数据 w，并使用普通的哈希函数计算哈希值。</span></span><br><span class="line"><span class="comment"> * 计算过程中使用 uint32_t 的自然溢出特性。四字节读取则为了加速，最终可能剩下 3/2/1 个多余的字节，</span></span><br><span class="line"><span class="comment"> * 使用 switch 语句补充计算，以实现最好的性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> n, <span class="keyword">uint32_t</span> seed)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Similar to murmur hash</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> m = <span class="number">0xc6a4a793</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> r = <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* limit = data + n;</span><br><span class="line">  <span class="keyword">uint32_t</span> h = seed ^ (n * m);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick up four bytes at a time</span></span><br><span class="line">  <span class="keyword">while</span> (data + <span class="number">4</span> &lt;= limit) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> w = <span class="built_in">DecodeFixed32</span>(data);</span><br><span class="line">    data += <span class="number">4</span>;</span><br><span class="line">    h += w;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= (h &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick up remaining bytes</span></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (limit - data) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">      FALLTHROUGH_INTENDED;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">      FALLTHROUGH_INTENDED;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">0</span>]);</span><br><span class="line">      h *= m;</span><br><span class="line">      h ^= (h &gt;&gt; r);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p>每次按照四字节长度读取字节流中的数据 <code>w</code>，并使用普通的哈希函数计算哈希值。计算过程中使用 <code>uint32_t</code> 的自然溢出特性。四字节读取则为了加速，最终可能剩下 3/2/1 个多余的字节，使用 <code>switch</code> 语句补充计算，以实现最好的性能。</p>
<p>这里 <code>FALLTHROUGH_INTENDED</code> 宏并无实际作用，仅仅作为一种“我确定我这里想跳过”的标志。<code>do &#123;&#125; while(0)</code> 对代码无影响，这种写法也会出现在一些多行的宏定义里（见<a href="https://stackoverflow.com/questions/257418/do-while-0-what-is-it-good-for">链接</a>）。</p>
<p>LevelDB 中哈希表和布隆过滤器会使用到该哈希函数。</p>
<h3 id="3-缓存-LRUCache"><a href="#3-缓存-LRUCache" class="headerlink" title="3. 缓存 LRUCache"></a>3. 缓存 LRUCache</h3><p>LevelDB 中使用的是 Least Recently Used Cache，即最近最少使用缓存。缓存接口定义于 <a href="https://github.com/google/leveldb/blob/master/include/leveldb/cache.h"><code>include/leveldb/cache.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Cache is an interface that maps keys to values.  It has internal</span></span><br><span class="line"><span class="comment">// synchronization and may be safely accessed concurrently from</span></span><br><span class="line"><span class="comment">// multiple threads.  It may automatically evict entries to make room</span></span><br><span class="line"><span class="comment">// for new entries.  Values have a specified charge against the cache</span></span><br><span class="line"><span class="comment">// capacity.  For example, a cache where the values are variable</span></span><br><span class="line"><span class="comment">// length strings, may use the length of the string as the charge for</span></span><br><span class="line"><span class="comment">// the string.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A builtin cache implementation with a least-recently-used eviction</span></span><br><span class="line"><span class="comment">// policy is provided.  Clients may use their own implementations if</span></span><br><span class="line"><span class="comment">// they want something more sophisticated (like scan-resistance, a</span></span><br><span class="line"><span class="comment">// custom eviction policy, variable cache sizing, etc.)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STORAGE_LEVELDB_INCLUDE_CACHE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORAGE_LEVELDB_INCLUDE_CACHE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/export.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/slice.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//仅依赖Slice</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Cache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new cache with a fixed size capacity.  This implementation</span></span><br><span class="line"><span class="comment">// of Cache uses a least-recently-used eviction policy.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认采用LRU替换策略</span></span><br><span class="line"><span class="function">LEVELDB_EXPORT Cache* <span class="title">NewLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Cache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cache</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//=delete表示编译器不生成默认构造函数。作用是，避免以下2个函数被调用，避免拷贝</span></span><br><span class="line">  <span class="built_in">Cache</span>(<span class="keyword">const</span> Cache&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Cache&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Cache&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Destroys all existing entries by calling the &quot;deleter&quot;</span></span><br><span class="line">  <span class="comment">// function that was passed to the constructor.</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Cache</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Opaque handle to an entry stored in the cache.</span></span><br><span class="line">  <span class="comment">//定义的 Handle 仅作为指针类型使用，实际上使用 void * 也并无区别，Handle 增加语意而已</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Handle</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert a mapping from key-&gt;value into the cache and assign it</span></span><br><span class="line">  <span class="comment">// the specified charge against the total cache capacity.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Returns a handle that corresponds to the mapping.  The caller</span></span><br><span class="line">  <span class="comment">// must call this-&gt;Release(handle) when the returned mapping is no</span></span><br><span class="line">  <span class="comment">// longer needed.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// When the inserted entry is no longer needed, the key and</span></span><br><span class="line">  <span class="comment">// value will be passed to &quot;deleter&quot;.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the cache has no mapping for &quot;key&quot;, returns nullptr.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Else return a handle that corresponds to the mapping.  The caller</span></span><br><span class="line">  <span class="comment">// must call this-&gt;Release(handle) when the returned mapping is no</span></span><br><span class="line">  <span class="comment">// longer needed.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release a mapping returned by a previous Lookup().</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must not have been released yet.</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must have been returned by a method on *this.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Release</span><span class="params">(Handle* handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the value encapsulated in a handle returned by a</span></span><br><span class="line">  <span class="comment">// successful Lookup().</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must not have been released yet.</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must have been returned by a method on *this.</span></span><br><span class="line">  <span class="comment">// 获取lookup()操作成功返回的Handle指向的表项中的Value</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">Value</span><span class="params">(Handle* handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the cache contains entry for key, erase it.  Note that the</span></span><br><span class="line">  <span class="comment">// underlying entry will be kept around until all existing handles</span></span><br><span class="line">  <span class="comment">// to it have been released.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a new numeric id.  May be used by multiple clients who are</span></span><br><span class="line">  <span class="comment">// sharing the same cache to partition the key space.  Typically the</span></span><br><span class="line">  <span class="comment">// client will allocate a new id at startup and prepend the id to</span></span><br><span class="line">  <span class="comment">// its cache keys.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span> <span class="title">NewId</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove all cache entries that are not actively in use.  Memory-constrained</span></span><br><span class="line">  <span class="comment">// applications may wish to call this method to reduce memory usage.</span></span><br><span class="line">  <span class="comment">// Default implementation of Prune() does nothing.  Subclasses are strongly</span></span><br><span class="line">  <span class="comment">// encouraged to override the default implementation.  A future release of</span></span><br><span class="line">  <span class="comment">// leveldb may change Prune() to a pure abstract method.</span></span><br><span class="line">  <span class="comment">// 修建所有不活跃的表项。适合对内存有限制的应用</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an estimate of the combined charges of all elements stored in the</span></span><br><span class="line">  <span class="comment">// cache.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// STORAGE_LEVELDB_INCLUDE_CACHE_H_</span></span></span><br></pre></td></tr></table></figure>

<p>接口仅依赖 <code>Slice</code>，接口也很容易看懂。<code>Cache</code> 中定义的 <code>Handle</code> 仅作为指针类型使用，实际上使用 <code>void *</code> 也并无区别，<code>Handle</code> 增加语意而已。</p>
<p><code>NewLRUCache</code> 作为工厂函数，可以生产一个 <code>LRUCache</code>，其定义于 <a href="https://github.com/google/leveldb/blob/master/util/cache.cc"><code>util/cache.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cache* <span class="title">NewLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ShardedLRUCache</span>(capacity); &#125;</span><br></pre></td></tr></table></figure>

<p><code>LRUCahce</code> 的实现依靠双向环形链表和哈希表。其中双向环形链表维护 <code>Recently</code> 属性，哈希表维护 <code>Used</code> 属性。双向环形链表和哈希表的节点信息都存储于 <code>LRUHandle</code> 结构中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUHandle</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>* value;</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*deleter)(<span class="keyword">const</span> Slice&amp;, <span class="keyword">void</span>* value);</span><br><span class="line">  LRUHandle* next_hash;</span><br><span class="line">  LRUHandle* next;</span><br><span class="line">  LRUHandle* prev;</span><br><span class="line">  <span class="keyword">size_t</span> charge;  <span class="comment">// TODO(opt): Only allow uint32_t?</span></span><br><span class="line">  <span class="keyword">size_t</span> key_length;</span><br><span class="line">  <span class="keyword">bool</span> in_cache;     <span class="comment">// Whether entry is in the cache.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> refs;     <span class="comment">// References, including cache reference, if present.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hash;     <span class="comment">// Hash of key(); used for fast sharding and comparisons</span></span><br><span class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next_ is only equal to this if the LRU handle is the list head of an</span></span><br><span class="line">    <span class="comment">// empty list. List heads never have meaningful keys.</span></span><br><span class="line">    <span class="built_in">assert</span>(next != <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>依次解释每一项属性：</p>
<ol>
<li><code>value</code> 为缓存存储的数据，类型无关；</li>
<li><code>deleter</code> 为键值对的析构函数指针；</li>
<li><code>next_hash</code> 为开放式哈希表中同一个桶下存储链表时使用的指针；</li>
<li><code>next</code> 和 <code>prev</code> 自然是双向环形链接的前后指针；</li>
<li><code>charge</code> 为当前节点的缓存费用，比如一个字符串的费用可能就是它的长度；</li>
<li><code>key_length</code> 为 <code>key</code> 的长度；</li>
<li><code>in_cache</code> 为节点是否在缓存里的标志；</li>
<li><code>refs</code> 为引用计数，当计数为 0 时则可以用 <code>deleter</code> 清理掉；</li>
<li><code>hash</code> 为 <code>key</code> 的哈希值；</li>
<li><code>key_data</code> 为变长的 <code>key</code> 数据，最小长度为 1，<code>malloc</code> 时动态指定长度。</li>
</ol>
<p>接着看哈希表的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">HandleTable</span>() : <span class="built_in">length_</span>(<span class="number">0</span>), <span class="built_in">elems_</span>(<span class="number">0</span>), <span class="built_in">list_</span>(<span class="literal">nullptr</span>) &#123; <span class="built_in">Resize</span>(); &#125;</span><br><span class="line">  ~<span class="built_in">HandleTable</span>() &#123; <span class="keyword">delete</span>[] list_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = <span class="built_in">FindPointer</span>(h-&gt;<span class="built_in">key</span>(), h-&gt;hash);</span><br><span class="line">    LRUHandle* old = *ptr;</span><br><span class="line">    h-&gt;next_hash = (old == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;next_hash);</span><br><span class="line">    *ptr = h;</span><br><span class="line">    <span class="keyword">if</span> (old == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      ++elems_;</span><br><span class="line">      <span class="keyword">if</span> (elems_ &gt; length_) &#123;</span><br><span class="line">        <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">        <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">        <span class="built_in">Resize</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = <span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">    LRUHandle* result = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      *ptr = result-&gt;next_hash;</span><br><span class="line">      --elems_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The table consists of an array of buckets where each bucket is</span></span><br><span class="line">  <span class="comment">// a linked list of cache entries that hash into the bucket.</span></span><br><span class="line">  <span class="comment">// 这个表由一个存储桶数组组成，每个存储桶是一个散列到存储桶中的缓存条目的链表。</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length_;   <span class="comment">//存储桶的数量</span></span><br><span class="line">  <span class="keyword">uint32_t</span> elems_;    <span class="comment">//当前哈希表的实际元素个数</span></span><br><span class="line">  LRUHandle** list_;  <span class="comment">//桶数组。实际存储的数据内容，底层结构</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a pointer to slot that points to a cache entry that</span></span><br><span class="line">  <span class="comment">// matches key/hash.  If there is no such cache entry, return a</span></span><br><span class="line">  <span class="comment">// pointer to the trailing slot in the corresponding linked list.</span></span><br><span class="line">  <span class="comment">// 根据指定的key与hash，返回对应的双重指针。</span></span><br><span class="line">  <span class="comment">// (先根据Hash值与存储桶数目length_，找到list_中对应的桶，然后再根据hash与key寻找，避免hash冲突)</span></span><br><span class="line">  <span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="literal">nullptr</span> &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;<span class="built_in">key</span>())) &#123;</span><br><span class="line">      ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Resize 则根据存储的节点数，对哈希表进行缩放。</span></span><br><span class="line"><span class="comment">   * 如果不缩放，这样的结构会退化到链表的复杂度。</span></span><br><span class="line"><span class="comment">   * 使用 2 的幂可以规避掉哈希值的模除，同样可以加速。</span></span><br><span class="line"><span class="comment">   * Resize时会遍历节点，将其从原位置取出，重新计算哈希值放到新位置，</span></span><br><span class="line"><span class="comment">   * 每次会加到桶中链表的头部。Resize 过程中链表需要拒绝其他请求。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 值得注意的是：新的桶的数目（新的length_）是根据 现有的存储的实际数据的个数 来决定的。</span></span><br><span class="line"><span class="comment">   * 使得new_length &gt;= 实际元素个数。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> new_length = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (new_length &lt; elems_) &#123;</span><br><span class="line">      new_length *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LRUHandle** new_list = <span class="keyword">new</span> LRUHandle*[new_length];</span><br><span class="line">    <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) &#123;</span><br><span class="line">      LRUHandle* h = list_[i];</span><br><span class="line">      <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        LRUHandle* next = h-&gt;next_hash;</span><br><span class="line">        <span class="keyword">uint32_t</span> hash = h-&gt;hash;</span><br><span class="line">        LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)];</span><br><span class="line">        h-&gt;next_hash = *ptr;</span><br><span class="line">        *ptr = h;</span><br><span class="line">        h = next;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(elems_ == count);</span><br><span class="line">    <span class="keyword">delete</span>[] list_;</span><br><span class="line">    list_ = new_list;</span><br><span class="line">    length_ = new_length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个标准的开放式哈希实现。属性中 <code>length_</code> 存储桶的数量，<code>elems_</code> 存储哈希表中节点数，<code>list_</code> 则为桶数组。每一个桶里存储 <code>hash</code> 值相同的一系列节点，这些节点构成一个链表，通过 <code>next_hash</code> 属性连接。</p>
<p><code>FindPointer</code> 函数返回一个二级指针。无论是 <code>list_[i]</code> 还是 <code>entry-&gt;next_hash</code>，均为 <code>LRUHandle *</code>，那么一个节点总会有一个正确的 <code>LRUHandle *</code> 变量指向它，该函数就返回这个变量的指针。说起来有点绕，仔细看懂就好。</p>
<p>看懂后，理解 <code>Insert</code> 和 <code>Remove</code> 都不难。<code>Resize</code> 则根据存储的节点数，对哈希表进行缩放。如果不缩放，这样的结构会退化到链表的复杂度。使用 2 的幂可以规避掉哈希值的模除，同样可以加速。<code>Resize</code> 时会遍历每一个节点，将其从原位置取出，重新计算哈希值放到新位置，每次会加到桶中链表的头部。<code>Resize</code> 过程中链表需要拒绝其他请求。</p>
<p>最后看 <code>LRUCache</code> 的实现就很简单了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A single shard of sharded cache.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LRUCache</span>();</span><br><span class="line">  ~<span class="built_in">LRUCache</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Separate from constructor so caller can easily make an array of LRUCache</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetCapacity</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> </span>&#123; capacity_ = capacity; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Like Cache methods, but with an extra &quot;hash&quot; parameter.</span></span><br><span class="line">  <span class="function">Cache::Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span></span>;</span><br><span class="line">  <span class="function">Cache::Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Cache::Handle* handle)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> usage_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Remove</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Append</span><span class="params">(LRUHandle* list, LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">FinishErase</span><span class="params">(LRUHandle* e)</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialized before use.</span></span><br><span class="line">  <span class="comment">// 初始化的容量</span></span><br><span class="line">  <span class="keyword">size_t</span> capacity_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mutex_ protects the following state.</span></span><br><span class="line">  <span class="comment">// 锁,用来保护下列的状态</span></span><br><span class="line">  <span class="keyword">mutable</span> port::Mutex mutex_;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> usage_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * LRUCache 中存储了两条链表，lru_ 和 in_use_，</span></span><br><span class="line"><span class="comment">   * 分别记录普通节点和外部正在使用中的节点。外部正在使用中的节点是不可删除的，</span></span><br><span class="line"><span class="comment">   * 将二者区分开也方便做对应的清理。Ref 和 Unref 分别增删引用计数，</span></span><br><span class="line"><span class="comment">   * 并完成节点在 lru_ 和 in_use_ 的交换，以及计数为 0 时做最后的删除。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 双向链表，会将最新使用的节点放到链表的末端。这样在容量超标时，</span></span><br><span class="line"><span class="comment">   * 删除链表头部的、长时间未用的节点即可。该逻辑实现于 Insert 函数的结尾。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dummy head of LRU list.</span></span><br><span class="line">  <span class="comment">// lru.prev is newest entry, lru.next is oldest entry.</span></span><br><span class="line">  <span class="comment">// Entries have refs==1 and in_cache==true.</span></span><br><span class="line">  <span class="function">LRUHandle lru_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dummy head of in-use list.</span></span><br><span class="line">  <span class="comment">// Entries are in use by clients, and have refs &gt;= 2 and in_cache==true.</span></span><br><span class="line">  <span class="function">LRUHandle in_use_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">HandleTable table_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache::<span class="built_in">LRUCache</span>() : <span class="built_in">capacity_</span>(<span class="number">0</span>), <span class="built_in">usage_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Make empty circular linked lists.</span></span><br><span class="line">  lru_.next = &amp;lru_;</span><br><span class="line">  lru_.prev = &amp;lru_;</span><br><span class="line">  in_use_.next = &amp;in_use_;</span><br><span class="line">  in_use_.prev = &amp;in_use_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRUCache::~<span class="built_in">LRUCache</span>() &#123;</span><br><span class="line">  <span class="built_in">assert</span>(in_use_.next == &amp;in_use_);  <span class="comment">// Error if caller has an unreleased handle</span></span><br><span class="line">  <span class="keyword">for</span> (LRUHandle* e = lru_.next; e != &amp;lru_;) &#123;</span><br><span class="line">    LRUHandle* next = e-&gt;next;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;in_cache);</span><br><span class="line">    e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;refs == <span class="number">1</span>);  <span class="comment">// Invariant of lru_ list.</span></span><br><span class="line">    <span class="built_in">Unref</span>(e);</span><br><span class="line">    e = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加引用计数。</span></span><br><span class="line"><span class="comment">// 若引用计数为1且in_cache==true，则将其从原链表中移除，添加到in_use链表的末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Ref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">1</span> &amp;&amp; e-&gt;in_cache) &#123;  <span class="comment">// If on lru_ list, move to in_use_ list.</span></span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;in_use_, e);</span><br><span class="line">  &#125;</span><br><span class="line">  e-&gt;refs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少引用计数。</span></span><br><span class="line"><span class="comment">// 若减少后引用计数为0，则删除对应空间。否则，将其从原链表中移除，添加到lru_链表的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Unref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(e-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">  e-&gt;refs--;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">0</span>) &#123;  <span class="comment">// Deallocate.</span></span><br><span class="line">    <span class="built_in">assert</span>(!e-&gt;in_cache);</span><br><span class="line">    (*e-&gt;deleter)(e-&gt;<span class="built_in">key</span>(), e-&gt;value);</span><br><span class="line">    <span class="built_in">free</span>(e);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;in_cache &amp;&amp; e-&gt;refs == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// No longer in use; move to lru_ list.</span></span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;lru_, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Remove</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  e-&gt;next-&gt;prev = e-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Append</span><span class="params">(LRUHandle* list, LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make &quot;e&quot; newest entry by inserting just before *list</span></span><br><span class="line">  e-&gt;next = list;</span><br><span class="line">  e-&gt;prev = list-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e;</span><br><span class="line">  e-&gt;next-&gt;prev = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过HandleTable哈希表查询，并添加引用计数</span></span><br><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  LRUHandle* e = table_.<span class="built_in">Lookup</span>(key, hash);</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">Ref</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减少引用计数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Release</span><span class="params">(Cache::Handle* handle)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">Unref</span>(<span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">void</span>* value))</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  LRUHandle* e =</span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  e-&gt;deleter = deleter;</span><br><span class="line">  e-&gt;charge = charge;</span><br><span class="line">  e-&gt;key_length = key.<span class="built_in">size</span>();</span><br><span class="line">  e-&gt;hash = hash;</span><br><span class="line">  e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">  e-&gt;refs = <span class="number">1</span>;  <span class="comment">// for the returned handle.</span></span><br><span class="line">  std::<span class="built_in">memcpy</span>(e-&gt;key_data, key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (capacity_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    e-&gt;refs++;  <span class="comment">// for the cache&#x27;s reference.</span></span><br><span class="line">    e-&gt;in_cache = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;in_use_, e);</span><br><span class="line">    usage_ += charge;</span><br><span class="line">    <span class="comment">//在哈希表HandleTable中插入新节点，同时在链表中删除 table_.Insert()返回的旧节点</span></span><br><span class="line">    <span class="built_in">FinishErase</span>(table_.<span class="built_in">Insert</span>(e));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// don&#x27;t cache. (capacity_==0 is supported and turns off caching.)</span></span><br><span class="line">    <span class="comment">// next is read by key() in an assert, so it must be initialized</span></span><br><span class="line">    e-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 双向链表，会将最新使用的节点放到链表的末端。</span></span><br><span class="line">  <span class="comment">// 这样在容量超标时，删除链表头部的、长时间未用的节点即可。</span></span><br><span class="line">  <span class="keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123;</span><br><span class="line">    LRUHandle* old = lru_.next;</span><br><span class="line">    <span class="built_in">assert</span>(old-&gt;refs == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//若容量超标，在哈希表与链表中都删除对应的节点</span></span><br><span class="line">    <span class="keyword">bool</span> erased = <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(old-&gt;<span class="built_in">key</span>(), old-&gt;hash));</span><br><span class="line">    <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">      <span class="built_in">assert</span>(erased);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If e != nullptr, finish removing *e from the cache; it has already been</span></span><br><span class="line"><span class="comment">// removed from the hash table.  Return whether e != nullptr.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LRUCache::FinishErase</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;in_cache);</span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">    usage_ -= e-&gt;charge;</span><br><span class="line">    <span class="built_in">Unref</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> e != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(key, hash));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Prune</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (lru_.next != &amp;lru_) &#123;</span><br><span class="line">    LRUHandle* e = lru_.next;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;refs == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> erased = <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(e-&gt;<span class="built_in">key</span>(), e-&gt;hash));</span><br><span class="line">    <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">      <span class="built_in">assert</span>(erased);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LRUCache</code> 中存储了两条链表，<code>lru_</code> 和 <code>in_use_</code>，分别记录普通节点和外部正在使用中的节点。外部正在使用中的节点是不可删除的，将二者区分开也方便做对应的清理。<code>Ref</code> 和 <code>Unref</code> 分别增删引用计数，并完成节点在 <code>lru_</code> 和 <code>in_use_</code> 的交换，以及计数为 0 时做最后的删除。</p>
<p>双向链表，会将最新使用的节点放到链表的末端。这样在容量超标时，删除链表头部的、长时间未用的节点即可。该逻辑实现于 <code>Insert</code> 函数的结尾。</p>
<p><code>LRUCache</code> 中在添删查操作中均使用互斥锁完成额外同步。<code>LevelDB</code> 中的锁将在后续文章中详细介绍。</p>
<p>最后看分片 <code>ShardedLRUCache</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShardBits = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShards = <span class="number">1</span> &lt;&lt; kNumShardBits;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分片LRUCache</span></span><br><span class="line"><span class="comment">// LevelDB 默认将 LRUCache 分为2^4块，取哈希值的高 4 位作为分片的位置。</span></span><br><span class="line"><span class="comment">// 分片可以提高查询和插入的速度，减少锁的压力，是提高缓存性能的常用方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//LRUCache的数组，包含2^4=16个LRUCache</span></span><br><span class="line">  LRUCache shard_[kNumShards];</span><br><span class="line">  port::Mutex id_mutex_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_id_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对Slice进行Hash操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">HashSlice</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Hash</span>(s.<span class="built_in">data</span>(), s.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对hash值进行右移，仅保留高4位作为分片的位置</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">Shard</span><span class="params">(<span class="keyword">uint32_t</span> hash)</span> </span>&#123; <span class="keyword">return</span> hash &gt;&gt; (<span class="number">32</span> - kNumShardBits); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ShardedLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> : last_id_(<span class="number">0</span>) &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> per_shard = (capacity + (kNumShards - <span class="number">1</span>)) / kNumShards;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].<span class="built_in">SetCapacity</span>(per_shard);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">ShardedLRUCache</span>() <span class="keyword">override</span> &#123;&#125;</span><br><span class="line">  <span class="function">Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">    <span class="keyword">return</span> shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Insert</span>(key, hash, value, charge, deleter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">    <span class="keyword">return</span> shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Lookup</span>(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Handle* handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    LRUHandle* h = <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle);</span><br><span class="line">    shard_[<span class="built_in">Shard</span>(h-&gt;hash)].<span class="built_in">Release</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">    shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Erase</span>(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">Value</span><span class="params">(Handle* handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle)-&gt;value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">NewId</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;id_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ++(last_id_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].<span class="built_in">Prune</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      total += shard_[s].<span class="built_in">TotalCharge</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>LevelDB</code> 默认将 <code>LRUCache</code> 分为 2^424 块，取哈希值的高 4 位作为分片的位置。分片可以提高查询和插入的速度，减少锁的压力，是提高缓存性能的常用方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文简单介绍了 <code>LevelDB</code> 中的 <code>Slice</code>、<code>Hash</code> 和 <code>LRUCache</code> 的实现。慢慢会觉得代码中的每个细节都是有意义的，不可忽略。<code>LevelDB</code> 源代码不超过 2万行，非常推荐学习 C++ 的同学阅读。建议可以先读 <code>util</code> 部分，这里是通用的数据结构，没有太多依赖。</p>
<p>下一篇会继续介绍 <code>LevelDB</code> 中的其他数据结构，包括布隆过滤器、内存池和跳表。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>LevelDB</category>
      </categories>
      <tags>
        <tag>LevelDB</tag>
        <tag>KVStore</tag>
      </tags>
  </entry>
</search>
