<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>LevelDB源码分析——7.Sorted String Table续 |  Gasol</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
    <link rel="alternate" href="/atom.xml" title="Gasol" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-LevelDB源码分析——7.Sorted String Table续"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  LevelDB源码分析——7.Sorted String Table续
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%947.Sorted%20String%20Table%E7%BB%AD/" class="article-date">
  <time datetime="2022-02-10T06:30:30.000Z" itemprop="datePublished">2022-02-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/LevelDB/">LevelDB</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">6.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">32 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="七-Sorted-String-Table续"><a href="#七-Sorted-String-Table续" class="headerlink" title="七.Sorted String Table续"></a>七.Sorted String Table续</h2><p>本系列的上一篇介绍了 Sorted Table 的构建过程，本篇就继续分析 Sorted Table 的读取、解析过程。</p>
<h3 id="4-Block"><a href="#4-Block" class="headerlink" title="4. Block"></a>4. Block</h3><p>根据依赖关系，首先来看 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/table/format.cc"><code>table/format.cc</code></a> 中 <code>ReadBlock</code> 函数的实现：</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlockContents</span> &#123;</span></span><br><span class="line">  Slice data;           <span class="comment">// Actual contents of data</span></span><br><span class="line">  <span class="keyword">bool</span> cachable;        <span class="comment">// True iff data can be cached</span></span><br><span class="line">  <span class="keyword">bool</span> heap_allocated;  <span class="comment">// True iff caller should delete[] data.data()</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the block identified by &quot;handle&quot; from &quot;file&quot;.  On failure</span></span><br><span class="line"><span class="comment">// return non-OK.  On success fill *result and return OK.</span></span><br><span class="line"><span class="function">Status <span class="title">ReadBlock</span><span class="params">(RandomAccessFile* file, <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">const</span> BlockHandle&amp; handle, BlockContents* result)</span> </span>&#123;</span><br><span class="line">  result-&gt;data = <span class="built_in">Slice</span>();</span><br><span class="line">  result-&gt;cachable = <span class="literal">false</span>;</span><br><span class="line">  result-&gt;heap_allocated = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read the block contents as well as the type/crc footer.</span></span><br><span class="line">  <span class="comment">// See table_builder.cc for the code that built this structure.</span></span><br><span class="line">  <span class="keyword">size_t</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(handle.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">char</span>[n + kBlockTrailerSize];</span><br><span class="line">  Slice contents;</span><br><span class="line">  Status s = file-&gt;<span class="built_in">Read</span>(handle.<span class="built_in">offset</span>(), n + kBlockTrailerSize, &amp;contents, buf);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (contents.<span class="built_in">size</span>() != n + kBlockTrailerSize) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;truncated block read&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check the crc of the type and the block contents</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data = contents.<span class="built_in">data</span>();  <span class="comment">// Pointer to where Read put the data</span></span><br><span class="line">  <span class="keyword">if</span> (options.verify_checksums) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> crc = crc32c::<span class="built_in">Unmask</span>(<span class="built_in">DecodeFixed32</span>(data + n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> actual = crc32c::<span class="built_in">Value</span>(data, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (actual != crc) &#123;</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;block checksum mismatch&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (data[n]) &#123;</span><br><span class="line">    <span class="keyword">case</span> kNoCompression:</span><br><span class="line">      <span class="keyword">if</span> (data != buf) &#123;</span><br><span class="line">        <span class="comment">// File implementation gave us pointer to some other data.</span></span><br><span class="line">        <span class="comment">// Use it directly under the assumption that it will be live</span></span><br><span class="line">        <span class="comment">// while the file is open.</span></span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        result-&gt;data = <span class="built_in">Slice</span>(data, n);</span><br><span class="line">        result-&gt;heap_allocated = <span class="literal">false</span>;</span><br><span class="line">        result-&gt;cachable = <span class="literal">false</span>;  <span class="comment">// Do not double-cache</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result-&gt;data = <span class="built_in">Slice</span>(buf, n);</span><br><span class="line">        result-&gt;heap_allocated = <span class="literal">true</span>;</span><br><span class="line">        result-&gt;cachable = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ok</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kSnappyCompression: &#123;</span><br><span class="line">      <span class="keyword">size_t</span> ulength = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (!port::<span class="built_in">Snappy_GetUncompressedLength</span>(data, n, &amp;ulength)) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;corrupted compressed block contents&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">char</span>* ubuf = <span class="keyword">new</span> <span class="keyword">char</span>[ulength];</span><br><span class="line">      <span class="keyword">if</span> (!port::<span class="built_in">Snappy_Uncompress</span>(data, n, ubuf)) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        <span class="keyword">delete</span>[] ubuf;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;corrupted compressed block contents&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      result-&gt;data = <span class="built_in">Slice</span>(ubuf, ulength);</span><br><span class="line">      result-&gt;heap_allocated = <span class="literal">true</span>;</span><br><span class="line">      result-&gt;cachable = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad block type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于已经存储的 Sorted Table 文件，提供 <code>ReadOptions</code> 和 <code>BlockHandle</code> 后，可以将 <code>handle</code> 对应的 Block 内容读取到 <code>BlockContents</code> 中。该结构体储存 Block 的字节流，以及能否缓存、是否需要手动清理的标记。<code>ReadBlock</code> 的实现非常直接，读取文件对应位置的字节流，进行必要的校验和解压缩。继续看 <code>Block</code> 的解析部分 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/table/block.h"><code>table/block.h</code></a> ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlockContents</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize the block with the specified contents.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Block</span><span class="params">(<span class="keyword">const</span> BlockContents&amp; contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Block</span>(<span class="keyword">const</span> Block&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Block&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Block&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Block</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">(<span class="keyword">const</span> Comparator* comparator)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iter</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">NumRestarts</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;</span><br><span class="line">  <span class="keyword">size_t</span> size_;</span><br><span class="line">  <span class="keyword">uint32_t</span> restart_offset_;  <span class="comment">// Offset in data_ of restart array</span></span><br><span class="line">  <span class="keyword">bool</span> owned_;               <span class="comment">// Block owns data_[]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接口的核心部分自然是迭代器。迭代器提供 Block 中键值对数据的遍历和查找。继续看对应函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">Block::NumRestarts</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(size_ &gt;= <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">DecodeFixed32</span>(data_ + size_ - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Block::<span class="built_in">Block</span>(<span class="keyword">const</span> BlockContents&amp; contents)</span><br><span class="line">    : <span class="built_in">data_</span>(contents.data.<span class="built_in">data</span>()),</span><br><span class="line">      <span class="built_in">size_</span>(contents.data.<span class="built_in">size</span>()),</span><br><span class="line">      <span class="built_in">owned_</span>(contents.heap_allocated) &#123;</span><br><span class="line">  <span class="keyword">if</span> (size_ &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>)) &#123;</span><br><span class="line">    size_ = <span class="number">0</span>;  <span class="comment">// Error marker</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">size_t</span> max_restarts_allowed = (size_ - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>)) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NumRestarts</span>() &gt; max_restarts_allowed) &#123;</span><br><span class="line">      <span class="comment">// The size is too small for NumRestarts()</span></span><br><span class="line">      size_ = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      restart_offset_ = size_ - (<span class="number">1</span> + <span class="built_in">NumRestarts</span>()) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Block::~<span class="built_in">Block</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (owned_) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] data_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper routine: decode the next block entry starting at &quot;p&quot;,</span></span><br><span class="line"><span class="comment">// storing the number of shared key bytes, non_shared key bytes,</span></span><br><span class="line"><span class="comment">// and the length of the value in &quot;*shared&quot;, &quot;*non_shared&quot;, and</span></span><br><span class="line"><span class="comment">// &quot;*value_length&quot;, respectively.  Will not dereference past &quot;limit&quot;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If any errors are detected, returns nullptr.  Otherwise, returns a</span></span><br><span class="line"><span class="comment">// pointer to the key delta (just past the three decoded values).</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">DecodeEntry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">uint32_t</span>* shared, <span class="keyword">uint32_t</span>* non_shared,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">uint32_t</span>* value_length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (limit - p &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  *shared = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p)[<span class="number">0</span>];</span><br><span class="line">  *non_shared = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p)[<span class="number">1</span>];</span><br><span class="line">  *value_length = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p)[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> ((*shared | *non_shared | *value_length) &lt; <span class="number">128</span>) &#123;</span><br><span class="line">    <span class="comment">// Fast path: all three values are encoded in one byte each</span></span><br><span class="line">    p += <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, shared)) == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, non_shared)) == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">GetVarint32Ptr</span>(p, limit, value_length)) == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(limit - p) &lt; (*non_shared + *value_length)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照之前描述的 Block 存储结构，最后 4 字节存储复活点的数量，如 <code>NumRestarts</code> 实现。构造时进行必要的判断，在 <code>restart_offset_</code> 中存储复活点列表的位置。解析条目时，首先假设 <code>shared</code>、<code>non_shared</code> 和 <code>value_length</code> 都小于 128，尝试按照按字节读取长度以提高解析速度。在大部分情况下该规则都是满足的，当少数情况出现超长的串时，会回退到普通的 <code>GetVarint32Ptr</code>。继续看迭代器的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span>:</span>:Iter : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> Comparator* <span class="keyword">const</span> comparator_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> data_;       <span class="comment">// underlying block contents</span></span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="keyword">const</span> restarts_;      <span class="comment">// Offset of restart array (list of fixed32)</span></span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="keyword">const</span> num_restarts_;  <span class="comment">// Number of uint32_t entries in restart array</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// current_ is offset in data_ of current entry.  &gt;= restarts_ if !Valid</span></span><br><span class="line">  <span class="keyword">uint32_t</span> current_;</span><br><span class="line">  <span class="keyword">uint32_t</span> restart_index_;  <span class="comment">// Index of restart block in which current_ falls</span></span><br><span class="line">  std::string key_;</span><br><span class="line">  Slice value_;</span><br><span class="line">  Status status_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; a, <span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparator_-&gt;<span class="built_in">Compare</span>(a, b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the offset in data_ just past the end of the current entry.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">NextEntryOffset</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value_.<span class="built_in">data</span>() + value_.<span class="built_in">size</span>()) - data_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">GetRestartPoint</span><span class="params">(<span class="keyword">uint32_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(index &lt; num_restarts_);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DecodeFixed32</span>(data_ + restarts_ + index * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToRestartPoint</span><span class="params">(<span class="keyword">uint32_t</span> index)</span> </span>&#123;</span><br><span class="line">    key_.<span class="built_in">clear</span>();</span><br><span class="line">    restart_index_ = index;</span><br><span class="line">    <span class="comment">// current_ will be fixed by ParseNextKey();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ParseNextKey() starts at the end of value_, so set value_ accordingly</span></span><br><span class="line">    <span class="keyword">uint32_t</span> offset = <span class="built_in">GetRestartPoint</span>(index);</span><br><span class="line">    value_ = <span class="built_in">Slice</span>(data_ + offset, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Iter</span>(<span class="keyword">const</span> Comparator* comparator, <span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">uint32_t</span> restarts,</span><br><span class="line">       <span class="keyword">uint32_t</span> num_restarts)</span><br><span class="line">      : <span class="built_in">comparator_</span>(comparator),</span><br><span class="line">        <span class="built_in">data_</span>(data),</span><br><span class="line">        <span class="built_in">restarts_</span>(restarts),</span><br><span class="line">        <span class="built_in">num_restarts_</span>(num_restarts),</span><br><span class="line">        <span class="built_in">current_</span>(restarts_),</span><br><span class="line">        <span class="built_in">restart_index_</span>(num_restarts_) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(num_restarts_ &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> current_ &lt; restarts_; &#125;</span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> status_; &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> key_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> value_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="built_in">ParseNextKey</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan backwards to a restart point before current_</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> original = current_;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetRestartPoint</span>(restart_index_) &gt;= original) &#123;</span><br><span class="line">      <span class="keyword">if</span> (restart_index_ == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// No more entries</span></span><br><span class="line">        current_ = restarts_;</span><br><span class="line">        restart_index_ = num_restarts_;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      restart_index_--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SeekToRestartPoint</span>(restart_index_);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// Loop until end of current entry hits the start of original entry</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">ParseNextKey</span>() &amp;&amp; <span class="built_in">NextEntryOffset</span>() &lt; original);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SeekToRestartPoint</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ParseNextKey</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SeekToRestartPoint</span>(num_restarts_ - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">ParseNextKey</span>() &amp;&amp; <span class="built_in">NextEntryOffset</span>() &lt; restarts_) &#123;</span><br><span class="line">      <span class="comment">// Keep skipping</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CorruptionError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    current_ = restarts_;</span><br><span class="line">    restart_index_ = num_restarts_;</span><br><span class="line">    status_ = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad entry in block&quot;</span>);</span><br><span class="line">    key_.<span class="built_in">clear</span>();</span><br><span class="line">    value_.<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ParseNextKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    current_ = <span class="built_in">NextEntryOffset</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p = data_ + current_;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* limit = data_ + restarts_;  <span class="comment">// Restarts come right after data</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= limit) &#123;</span><br><span class="line">      <span class="comment">// No more entries to return.  Mark as invalid.</span></span><br><span class="line">      current_ = restarts_;</span><br><span class="line">      restart_index_ = num_restarts_;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode next entry</span></span><br><span class="line">    <span class="keyword">uint32_t</span> shared, non_shared, value_length;</span><br><span class="line">    p = <span class="built_in">DecodeEntry</span>(p, limit, &amp;shared, &amp;non_shared, &amp;value_length);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || key_.<span class="built_in">size</span>() &lt; shared) &#123;</span><br><span class="line">      <span class="built_in">CorruptionError</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      key_.<span class="built_in">resize</span>(shared);</span><br><span class="line">      key_.<span class="built_in">append</span>(p, non_shared);</span><br><span class="line">      value_ = <span class="built_in">Slice</span>(p + non_shared, value_length);</span><br><span class="line">      <span class="keyword">while</span> (restart_index_ + <span class="number">1</span> &lt; num_restarts_ &amp;&amp;</span><br><span class="line">             <span class="built_in">GetRestartPoint</span>(restart_index_ + <span class="number">1</span>) &lt; current_) &#123;</span><br><span class="line">        ++restart_index_;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">Block::NewIterator</span><span class="params">(<span class="keyword">const</span> Comparator* comparator)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size_ &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewErrorIterator</span>(Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad block contents&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> num_restarts = <span class="built_in">NumRestarts</span>();</span><br><span class="line">  <span class="keyword">if</span> (num_restarts == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewEmptyIterator</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Iter</span>(comparator, data_, restart_offset_, num_restarts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看成员变量：</p>
<ol>
<li>Block 的字节流存储于 <code>data_</code> 中；</li>
<li><code>restarts_</code> 和 <code>num_restarts_</code> 存储复活点列表的偏移和数量；</li>
<li><code>current_</code> 存储当前迭代器的偏移，<code>restart_index_</code> 存储 <code>current_</code> 前面最近的复活点偏移；</li>
<li><code>key_</code> 和 <code>value_</code> 存储键值对。注意 <code>key_</code> 是 <code>std::string</code>，因为有共享前缀，需要存储中间恢复的 <code>Key</code>，而 <code>value_</code> 可以直接从 <code>data_</code> 中截取。</li>
</ol>
<p>函数 <code>NextEntryOffset</code> 根据当前的 <code>value</code> 的位置和大小计算下一个键值对的起始位置，因为每个条目最后存储的是 <code>value</code>。函数 <code>GetRestartPoint</code> 读取第 <code>index</code> 个复活点的位置，函数 <code>SeekToRestartPoint</code> 将当前的 <code>key_</code> 清空、设定 <code>restart_index_</code> 并将 <code>value_</code> 设为复活点前的空串，以便于执行 <code>NextEntryOffset</code> 时获得对应复活点偏移。跳到函数 <code>ParseNextKey</code>，将 <code>current_</code> 设为下一个键值对的起点，通过 <code>DecodeEntry</code> 解析得到需要的长度信息，恢复 <code>key_</code> 并读取 <code>value_</code>。</p>
<p>迭代器存储的状态信息包括 <code>key_</code> 存储的共享前缀，和 <code>value_</code> 存储的下个条目起点。当发生起始点的切换时，需要先执行函数 <code>SeekToRestartPoint</code> 清空当前存储的状态信息，再执行函数 <code>ParseNextKey</code> 解析下一个键值对。按照这个过程读函数 <code>Prev</code>、<code>SeekToFirst</code> 和 <code>SeekToLast</code> 就非常轻松了。最后来看函数 <code>Seek</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Binary search in restart array to find the last restart point</span></span><br><span class="line">  <span class="comment">// with a key &lt; target</span></span><br><span class="line">  <span class="keyword">uint32_t</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> right = num_restarts_ - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> region_offset = <span class="built_in">GetRestartPoint</span>(mid);</span><br><span class="line">    <span class="keyword">uint32_t</span> shared, non_shared, value_length;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr =</span><br><span class="line">      <span class="built_in">DecodeEntry</span>(data_ + region_offset, data_ + restarts_, &amp;shared,</span><br><span class="line">                  &amp;non_shared, &amp;value_length);</span><br><span class="line">    <span class="keyword">if</span> (key_ptr == <span class="literal">nullptr</span> || (shared != <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="built_in">CorruptionError</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Slice <span class="title">mid_key</span><span class="params">(key_ptr, non_shared)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Compare</span>(mid_key, target) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Key at &quot;mid&quot; is smaller than &quot;target&quot;.  Therefore all</span></span><br><span class="line">      <span class="comment">// blocks before &quot;mid&quot; are uninteresting.</span></span><br><span class="line">      left = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Key at &quot;mid&quot; is &gt;= &quot;target&quot;.  Therefore all blocks at or</span></span><br><span class="line">      <span class="comment">// after &quot;mid&quot; are uninteresting.</span></span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linear search (within restart block) for first key &gt;= target</span></span><br><span class="line">  <span class="built_in">SeekToRestartPoint</span>(left);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ParseNextKey</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Compare</span>(key_, target) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在复活点上做二分查找，这里实现的二分查找的结果就是 <code>left</code> 对应的复活点 <code>Key</code> 是严格小于 <code>target</code> 的最大 <code>Key</code>。二分查找完成后跳到复活点处，按顺序恢复每个条目的键值，对比返回。</p>
<p>最后来看一个细节：<code>restart_index_</code> 只会在函数 <code>Prev</code> 里读取到，以确定上一个复活点的位置。如果仔细观察函数 <code>ParseNextKey</code> 中关于 <code>restart_index_</code> 的更新：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (restart_index_ + <span class="number">1</span> &lt; num_restarts_ &amp;&amp;</span><br><span class="line">       <span class="built_in">GetRestartPoint</span>(restart_index_ + <span class="number">1</span>) &lt; current_) &#123;</span><br><span class="line">  ++restart_index_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这里 <code>current_</code> 刚好到达复活点 <code>i</code>，<code>restart_index_</code> 仍然会保持在 <code>i - 1</code> 的，这样在执行 <code>Prev</code> 时 <code>while</code> 循环可以少做一次。Google 大佬实力可见一斑。但从语义的角度，这种做法比较容易让人困惑，我应该不会这么做（所以成不了 Google 大佬。</p>
<h3 id="5-迭代器链"><a href="#5-迭代器链" class="headerlink" title="5. 迭代器链"></a>5. 迭代器链</h3><p>上一节中分析了 Block 的迭代器实现，而对一个 Sorted Table 来说，还需要其他几种迭代器共同组成迭代器链，以高效地完成对 Sorted Table 的遍历和查找。首先来看 <code>IteratorWrapper</code> 的实现 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/table/iterator_wrapper.h"><code>table/iterator_wrapper</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A internal wrapper class with an interface similar to Iterator that</span></span><br><span class="line"><span class="comment">// caches the valid() and key() results for an underlying iterator.</span></span><br><span class="line"><span class="comment">// This can help avoid virtual function calls and also gives better</span></span><br><span class="line"><span class="comment">// cache locality.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorWrapper</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">IteratorWrapper</span>() : <span class="built_in">iter_</span>(<span class="literal">nullptr</span>), <span class="built_in">valid_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">IteratorWrapper</span><span class="params">(Iterator* iter)</span> : iter_(nullptr) &#123;</span> <span class="built_in">Set</span>(iter); &#125;</span><br><span class="line">  ~<span class="built_in">IteratorWrapper</span>() &#123; <span class="keyword">delete</span> iter_; &#125;</span><br><span class="line">  <span class="function">Iterator* <span class="title">iter</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> iter_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Takes ownership of &quot;iter&quot; and will delete it when destroyed, or</span></span><br><span class="line">  <span class="comment">// when Set() is invoked again.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(Iterator* iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> iter_;</span><br><span class="line">    iter_ = iter;</span><br><span class="line">    <span class="keyword">if</span> (iter_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      valid_ = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">Update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterator interface methods</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> valid_; &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> key_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> iter_-&gt;<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Methods below require iter() != nullptr</span></span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    <span class="keyword">return</span> iter_-&gt;<span class="built_in">status</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">Prev</span>();</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">Seek</span>(k);</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">SeekToFirst</span>();</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(iter_);</span><br><span class="line">    iter_-&gt;<span class="built_in">SeekToLast</span>();</span><br><span class="line">    <span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    valid_ = iter_-&gt;<span class="built_in">Valid</span>();</span><br><span class="line">    <span class="keyword">if</span> (valid_) &#123;</span><br><span class="line">      key_ = iter_-&gt;<span class="built_in">key</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Iterator* iter_;</span><br><span class="line">  <span class="keyword">bool</span> valid_;</span><br><span class="line">  Slice key_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代器的简单包装，缓存了 <code>key_</code> 和 <code>valid_</code> 属性。按照注释所说的，可以减少虚函数的调用，并且提供更好的缓存局部性。前者很好理解，后者仍然有些困惑。接着来看二级迭代器 <code>TwoLevelIterator</code> 的实现 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/table/two_level_iterator.cc"><code>table/two_level_iterator.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/table.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;table/block.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;table/format.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;table/iterator_wrapper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Iterator* (*BlockFunction)(<span class="keyword">void</span>*, <span class="keyword">const</span> ReadOptions&amp;, <span class="keyword">const</span> Slice&amp;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoLevelIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TwoLevelIterator</span>(Iterator* index_iter, BlockFunction block_function,</span><br><span class="line">                   <span class="keyword">void</span>* arg, <span class="keyword">const</span> ReadOptions&amp; options);</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">TwoLevelIterator</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> data_iter_.<span class="built_in">Valid</span>(); &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> data_iter_.<span class="built_in">key</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> data_iter_.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// It&#x27;d be nice if status() returned a const Status&amp; instead of a Status</span></span><br><span class="line">    <span class="keyword">if</span> (!index_iter_.<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> index_iter_.<span class="built_in">status</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span> &amp;&amp; !data_iter_.<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> data_iter_.<span class="built_in">status</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> status_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SaveError</span><span class="params">(<span class="keyword">const</span> Status&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status_.<span class="built_in">ok</span>() &amp;&amp; !s.<span class="built_in">ok</span>()) status_ = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SkipEmptyDataBlocksForward</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SkipEmptyDataBlocksBackward</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetDataIterator</span><span class="params">(Iterator* data_iter)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">InitDataBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  BlockFunction block_function_;</span><br><span class="line">  <span class="keyword">void</span>* arg_;</span><br><span class="line">  <span class="keyword">const</span> ReadOptions options_;</span><br><span class="line">  Status status_;</span><br><span class="line">  IteratorWrapper index_iter_;</span><br><span class="line">  IteratorWrapper data_iter_;  <span class="comment">// May be nullptr</span></span><br><span class="line">  <span class="comment">// If data_iter_ is non-null, then &quot;data_block_handle_&quot; holds the</span></span><br><span class="line">  <span class="comment">// &quot;index_value&quot; passed to block_function_ to create the data_iter_.</span></span><br><span class="line">  std::string data_block_handle_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TwoLevelIterator::<span class="built_in">TwoLevelIterator</span>(Iterator* index_iter,</span><br><span class="line">                                   BlockFunction block_function, <span class="keyword">void</span>* arg,</span><br><span class="line">                                   <span class="keyword">const</span> ReadOptions&amp; options)</span><br><span class="line">    : <span class="built_in">block_function_</span>(block_function),</span><br><span class="line">      <span class="built_in">arg_</span>(arg),</span><br><span class="line">      <span class="built_in">options_</span>(options),</span><br><span class="line">      <span class="built_in">index_iter_</span>(index_iter),</span><br><span class="line">      <span class="built_in">data_iter_</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">TwoLevelIterator::~<span class="built_in">TwoLevelIterator</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> </span>&#123;</span><br><span class="line">  index_iter_.<span class="built_in">Seek</span>(target);</span><br><span class="line">  <span class="built_in">InitDataBlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">Seek</span>(target);</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksForward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SeekToFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  index_iter_.<span class="built_in">SeekToFirst</span>();</span><br><span class="line">  <span class="built_in">InitDataBlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">SeekToFirst</span>();</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksForward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SeekToLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  index_iter_.<span class="built_in">SeekToLast</span>();</span><br><span class="line">  <span class="built_in">InitDataBlock</span>();</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">SeekToLast</span>();</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksBackward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">  data_iter_.<span class="built_in">Next</span>();</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksForward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::Prev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">  data_iter_.<span class="built_in">Prev</span>();</span><br><span class="line">  <span class="built_in">SkipEmptyDataBlocksBackward</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SkipEmptyDataBlocksForward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (data_iter_.<span class="built_in">iter</span>() == <span class="literal">nullptr</span> || !data_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="comment">// Move to next block</span></span><br><span class="line">    <span class="keyword">if</span> (!index_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="built_in">SetDataIterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index_iter_.<span class="built_in">Next</span>();</span><br><span class="line">    <span class="built_in">InitDataBlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">SeekToFirst</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SkipEmptyDataBlocksBackward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (data_iter_.<span class="built_in">iter</span>() == <span class="literal">nullptr</span> || !data_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="comment">// Move to next block</span></span><br><span class="line">    <span class="keyword">if</span> (!index_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="built_in">SetDataIterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index_iter_.<span class="built_in">Prev</span>();</span><br><span class="line">    <span class="built_in">InitDataBlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) data_iter_.<span class="built_in">SeekToLast</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::SetDataIterator</span><span class="params">(Iterator* data_iter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span>) <span class="built_in">SaveError</span>(data_iter_.<span class="built_in">status</span>());</span><br><span class="line">  data_iter_.<span class="built_in">Set</span>(data_iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TwoLevelIterator::InitDataBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!index_iter_.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="built_in">SetDataIterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Slice handle = index_iter_.<span class="built_in">value</span>();</span><br><span class="line">    <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        handle.<span class="built_in">compare</span>(data_block_handle_) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// data_iter_ is already constructed with this iterator, so</span></span><br><span class="line">      <span class="comment">// no need to change anything</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Iterator* iter = (*block_function_)(arg_, options_, handle);</span><br><span class="line">      data_block_handle_.<span class="built_in">assign</span>(handle.<span class="built_in">data</span>(), handle.<span class="built_in">size</span>());</span><br><span class="line">      <span class="built_in">SetDataIterator</span>(iter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">NewTwoLevelIterator</span><span class="params">(Iterator* index_iter,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockFunction block_function, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">const</span> ReadOptions&amp; options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TwoLevelIterator</span>(index_iter, block_function, arg, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sorted Table 中存储了多个 Data Block，使用 Index Block 完成对 Data Block 的索引。二级迭代器的第一级 <code>index_iter_</code> 完成对 Index Block 的迭代，第二级 <code>data_iter_</code> 完成对 Data Block 的迭代。遍历时移动 <code>data_iter_</code>，并在 <code>data_iter_</code> 边界的地方使用函数 <code>SkipEmptyDataBlocksForward</code> 和 <code>SkipEmptyDataBlocksBackward</code> 实现 Data Block 的前后切换。查找时同样先在 <code>index_iter_</code> 上查找，Index Block 的每个条目存储了 Data Block 的 <code>max_key</code> 和位置大小信息，可以二分；确定 <code>index_iter_</code> 的位置后再读取对应的 Data Block 进一步二分查找。</p>
<p>总结来看 Sorted Table 使用的迭代器们组成的链路如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TwoLevelIterator -&gt; <span class="built_in">IteratorWrapper</span>(index_iter_) -&gt; Block::Iter</span><br><span class="line">                 -&gt; <span class="built_in">IteratorWrapper</span>(data_iter_) -&gt; Block::Iter</span><br></pre></td></tr></table></figure>

<p>另外还有一个合并迭代器 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/table/merger.cc"><code>MergingIterator</code></a>，将会在多 Sorted Table 文件的遍历中使用到。该迭代器管理 n<em>n</em> 个子迭代器，<code>Next</code> 和 <code>Seek</code> 操作时齐头并进、选择最小的那个，具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergingIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MergingIterator</span>(<span class="keyword">const</span> Comparator* comparator, Iterator** children, <span class="keyword">int</span> n)</span><br><span class="line">      : <span class="built_in">comparator_</span>(comparator),</span><br><span class="line">        <span class="built_in">children_</span>(<span class="keyword">new</span> IteratorWrapper[n]),</span><br><span class="line">        <span class="built_in">n_</span>(n),</span><br><span class="line">        <span class="built_in">current_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">        <span class="built_in">direction_</span>(kForward) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">Set</span>(children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">MergingIterator</span>() <span class="keyword">override</span> &#123; <span class="keyword">delete</span>[] children_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> (current_ != <span class="literal">nullptr</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">SeekToFirst</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">    direction_ = kForward;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">SeekToLast</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FindLargest</span>();</span><br><span class="line">    direction_ = kReverse;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      children_[i].<span class="built_in">Seek</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">    direction_ = kForward;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that all children are positioned after key().</span></span><br><span class="line">    <span class="comment">// If we are moving in the forward direction, it is already</span></span><br><span class="line">    <span class="comment">// true for all of the non-current_ children since current_ is</span></span><br><span class="line">    <span class="comment">// the smallest child and key() == current_-&gt;key().  Otherwise,</span></span><br><span class="line">    <span class="comment">// we explicitly position the non-current_ children.</span></span><br><span class="line">    <span class="keyword">if</span> (direction_ != kForward) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">        IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">        <span class="keyword">if</span> (child != current_) &#123;</span><br><span class="line">          child-&gt;<span class="built_in">Seek</span>(<span class="built_in">key</span>());</span><br><span class="line">          <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>() &amp;&amp;</span><br><span class="line">              comparator_-&gt;<span class="built_in">Compare</span>(<span class="built_in">key</span>(), child-&gt;<span class="built_in">key</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">            child-&gt;<span class="built_in">Next</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      direction_ = kForward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current_-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that all children are positioned before key().</span></span><br><span class="line">    <span class="comment">// If we are moving in the reverse direction, it is already</span></span><br><span class="line">    <span class="comment">// true for all of the non-current_ children since current_ is</span></span><br><span class="line">    <span class="comment">// the largest child and key() == current_-&gt;key().  Otherwise,</span></span><br><span class="line">    <span class="comment">// we explicitly position the non-current_ children.</span></span><br><span class="line">    <span class="keyword">if</span> (direction_ != kReverse) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">        IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">        <span class="keyword">if</span> (child != current_) &#123;</span><br><span class="line">          child-&gt;<span class="built_in">Seek</span>(<span class="built_in">key</span>());</span><br><span class="line">          <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">            <span class="comment">// Child is at first entry &gt;= key().  Step back one to be &lt; key()</span></span><br><span class="line">            child-&gt;<span class="built_in">Prev</span>();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Child has no entries &gt;= key().  Position at last entry.</span></span><br><span class="line">            child-&gt;<span class="built_in">SeekToLast</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      direction_ = kReverse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current_-&gt;<span class="built_in">Prev</span>();</span><br><span class="line">    <span class="built_in">FindLargest</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> current_-&gt;<span class="built_in">key</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> current_-&gt;<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    Status status;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">      status = children_[i].<span class="built_in">status</span>();</span><br><span class="line">      <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Which direction is the iterator moving?</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> &#123;</span> kForward, kReverse &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindSmallest</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindLargest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We might want to use a heap in case there are lots of children.</span></span><br><span class="line">  <span class="comment">// For now we use a simple array since we expect a very small number</span></span><br><span class="line">  <span class="comment">// of children in leveldb.</span></span><br><span class="line">  <span class="keyword">const</span> Comparator* comparator_;</span><br><span class="line">  IteratorWrapper* children_;</span><br><span class="line">  <span class="keyword">int</span> n_;</span><br><span class="line">  IteratorWrapper* current_;</span><br><span class="line">  Direction direction_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergingIterator::FindSmallest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  IteratorWrapper* smallest = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">    IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">    <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (smallest == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        smallest = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator_-&gt;<span class="built_in">Compare</span>(child-&gt;<span class="built_in">key</span>(), smallest-&gt;<span class="built_in">key</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        smallest = child;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  current_ = smallest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergingIterator::FindLargest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  IteratorWrapper* largest = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n_ - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">    <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (largest == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        largest = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator_-&gt;<span class="built_in">Compare</span>(child-&gt;<span class="built_in">key</span>(), largest-&gt;<span class="built_in">key</span>()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        largest = child;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  current_ = largest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-Table"><a href="#6-Table" class="headerlink" title="6. Table"></a>6. Table</h3><p>最后来看 Sorted Table 的实现 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/table/table.cc"><code>table/table.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Table</span>:</span>:Rep &#123;</span><br><span class="line">  ~<span class="built_in">Rep</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> filter;</span><br><span class="line">    <span class="keyword">delete</span>[] filter_data;</span><br><span class="line">    <span class="keyword">delete</span> index_block;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Options options;</span><br><span class="line">  Status status;</span><br><span class="line">  RandomAccessFile* file;</span><br><span class="line">  <span class="keyword">uint64_t</span> cache_id;</span><br><span class="line">  FilterBlockReader* filter;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* filter_data;</span><br><span class="line"></span><br><span class="line">  BlockHandle metaindex_handle;  <span class="comment">// Handle to metaindex_block: saved from footer</span></span><br><span class="line">  Block* index_block;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Table::Open</span><span class="params">(<span class="keyword">const</span> Options&amp; options, RandomAccessFile* file,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">uint64_t</span> size, Table** table)</span> </span>&#123;</span><br><span class="line">  *table = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &lt; Footer::kEncodedLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;file is too short to be an sstable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> footer_space[Footer::kEncodedLength];</span><br><span class="line">  Slice footer_input;</span><br><span class="line">  Status s = file-&gt;<span class="built_in">Read</span>(size - Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                        &amp;footer_input, footer_space);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">  Footer footer;</span><br><span class="line">  s = footer.<span class="built_in">DecodeFrom</span>(&amp;footer_input);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read the index block</span></span><br><span class="line">  BlockContents index_block_contents;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    ReadOptions opt;</span><br><span class="line">    <span class="keyword">if</span> (options.paranoid_checks) &#123;</span><br><span class="line">      opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="built_in">ReadBlock</span>(file, opt, footer.<span class="built_in">index_handle</span>(), &amp;index_block_contents);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// We&#x27;ve successfully read the footer and the index block: we&#x27;re</span></span><br><span class="line">    <span class="comment">// ready to serve requests.</span></span><br><span class="line">    Block* index_block = <span class="keyword">new</span> <span class="built_in">Block</span>(index_block_contents);</span><br><span class="line">    Rep* rep = <span class="keyword">new</span> Table::Rep;</span><br><span class="line">    rep-&gt;options = options;</span><br><span class="line">    rep-&gt;file = file;</span><br><span class="line">    rep-&gt;metaindex_handle = footer.<span class="built_in">metaindex_handle</span>();</span><br><span class="line">    rep-&gt;index_block = index_block;</span><br><span class="line">    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;<span class="built_in">NewId</span>() : <span class="number">0</span>);</span><br><span class="line">    rep-&gt;filter_data = <span class="literal">nullptr</span>;</span><br><span class="line">    rep-&gt;filter = <span class="literal">nullptr</span>;</span><br><span class="line">    *table = <span class="keyword">new</span> <span class="built_in">Table</span>(rep);</span><br><span class="line">    (*table)-&gt;<span class="built_in">ReadMeta</span>(footer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Table::ReadMeta</span><span class="params">(<span class="keyword">const</span> Footer&amp; footer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;options.filter_policy == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// Do not need any metadata</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(sanjay): Skip this if footer.metaindex_handle() size indicates</span></span><br><span class="line">  <span class="comment">// it is an empty block.</span></span><br><span class="line">  ReadOptions opt;</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;options.paranoid_checks) &#123;</span><br><span class="line">    opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  BlockContents contents;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ReadBlock</span>(rep_-&gt;file, opt, footer.<span class="built_in">metaindex_handle</span>(), &amp;contents).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// Do not propagate errors since meta info is not needed for operation</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Block* meta = <span class="keyword">new</span> <span class="built_in">Block</span>(contents);</span><br><span class="line"></span><br><span class="line">  Iterator* iter = meta-&gt;<span class="built_in">NewIterator</span>(<span class="built_in">BytewiseComparator</span>());</span><br><span class="line">  std::string key = <span class="string">&quot;filter.&quot;</span>;</span><br><span class="line">  key.<span class="built_in">append</span>(rep_-&gt;options.filter_policy-&gt;<span class="built_in">Name</span>());</span><br><span class="line">  iter-&gt;<span class="built_in">Seek</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (iter-&gt;<span class="built_in">Valid</span>() &amp;&amp; iter-&gt;<span class="built_in">key</span>() == <span class="built_in">Slice</span>(key)) &#123;</span><br><span class="line">    <span class="built_in">ReadFilter</span>(iter-&gt;<span class="built_in">value</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  <span class="keyword">delete</span> meta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Table::ReadFilter</span><span class="params">(<span class="keyword">const</span> Slice&amp; filter_handle_value)</span> </span>&#123;</span><br><span class="line">  Slice v = filter_handle_value;</span><br><span class="line">  BlockHandle filter_handle;</span><br><span class="line">  <span class="keyword">if</span> (!filter_handle.<span class="built_in">DecodeFrom</span>(&amp;v).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We might want to unify with ReadBlock() if we start</span></span><br><span class="line">  <span class="comment">// requiring checksum verification in Table::Open.</span></span><br><span class="line">  ReadOptions opt;</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;options.paranoid_checks) &#123;</span><br><span class="line">    opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  BlockContents block;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ReadBlock</span>(rep_-&gt;file, opt, filter_handle, &amp;block).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (block.heap_allocated) &#123;</span><br><span class="line">    rep_-&gt;filter_data = block.data.<span class="built_in">data</span>();  <span class="comment">// Will need to delete later</span></span><br><span class="line">  &#125;</span><br><span class="line">  rep_-&gt;filter = <span class="keyword">new</span> <span class="built_in">FilterBlockReader</span>(rep_-&gt;options.filter_policy, block.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Table::~<span class="built_in">Table</span>() &#123; <span class="keyword">delete</span> rep_; &#125;</span><br></pre></td></tr></table></figure>

<p>开始部分依然是熟悉的 <code>pImpl</code> 范式，毕竟 <code>Table</code> 是对外的接口，需要保持稳定。<code>Table::Open</code> 时，首先读取文件尾部的 <code>Footer</code>，根据 <code>Footer::index_handle()</code> 读取 <code>index_block</code> 到内存中，并按需读取 <code>meta_block</code> 和 <code>filter</code>；这些析构时也会做对应的删除。接着看迭代器部分的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteCachedBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value)</span> </span>&#123;</span><br><span class="line">  Block* block = <span class="keyword">reinterpret_cast</span>&lt;Block*&gt;(value);</span><br><span class="line">  <span class="keyword">delete</span> block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReleaseBlock</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">void</span>* h)</span> </span>&#123;</span><br><span class="line">  Cache* cache = <span class="keyword">reinterpret_cast</span>&lt;Cache*&gt;(arg);</span><br><span class="line">  Cache::Handle* handle = <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(h);</span><br><span class="line">  cache-&gt;<span class="built_in">Release</span>(handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert an index iterator value (i.e., an encoded BlockHandle)</span></span><br><span class="line"><span class="comment">// into an iterator over the contents of the corresponding block.</span></span><br><span class="line"><span class="function">Iterator* <span class="title">Table::BlockReader</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> Slice&amp; index_value)</span> </span>&#123;</span><br><span class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;Table*&gt;(arg);</span><br><span class="line">  Cache* block_cache = table-&gt;rep_-&gt;options.block_cache;</span><br><span class="line">  Block* block = <span class="literal">nullptr</span>;</span><br><span class="line">  Cache::Handle* cache_handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  BlockHandle handle;</span><br><span class="line">  Slice input = index_value;</span><br><span class="line">  Status s = handle.<span class="built_in">DecodeFrom</span>(&amp;input);</span><br><span class="line">  <span class="comment">// We intentionally allow extra stuff in index_value so that we</span></span><br><span class="line">  <span class="comment">// can add more features in the future.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    BlockContents contents;</span><br><span class="line">    <span class="keyword">if</span> (block_cache != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> cache_key_buffer[<span class="number">16</span>];</span><br><span class="line">      <span class="built_in">EncodeFixed64</span>(cache_key_buffer, table-&gt;rep_-&gt;cache_id);</span><br><span class="line">      <span class="built_in">EncodeFixed64</span>(cache_key_buffer + <span class="number">8</span>, handle.<span class="built_in">offset</span>());</span><br><span class="line">      <span class="function">Slice <span class="title">key</span><span class="params">(cache_key_buffer, <span class="keyword">sizeof</span>(cache_key_buffer))</span></span>;</span><br><span class="line">      cache_handle = block_cache-&gt;<span class="built_in">Lookup</span>(key);</span><br><span class="line">      <span class="keyword">if</span> (cache_handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        block = <span class="keyword">reinterpret_cast</span>&lt;Block*&gt;(block_cache-&gt;<span class="built_in">Value</span>(cache_handle));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = <span class="built_in">ReadBlock</span>(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          block = <span class="keyword">new</span> <span class="built_in">Block</span>(contents);</span><br><span class="line">          <span class="keyword">if</span> (contents.cachable &amp;&amp; options.fill_cache) &#123;</span><br><span class="line">            cache_handle = block_cache-&gt;<span class="built_in">Insert</span>(key, block, block-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                               &amp;DeleteCachedBlock);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = <span class="built_in">ReadBlock</span>(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        block = <span class="keyword">new</span> <span class="built_in">Block</span>(contents);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Iterator* iter;</span><br><span class="line">  <span class="keyword">if</span> (block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    iter = block-&gt;<span class="built_in">NewIterator</span>(table-&gt;rep_-&gt;options.comparator);</span><br><span class="line">    <span class="keyword">if</span> (cache_handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      iter-&gt;<span class="built_in">RegisterCleanup</span>(&amp;DeleteBlock, block, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iter-&gt;<span class="built_in">RegisterCleanup</span>(&amp;ReleaseBlock, block_cache, cache_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iter = <span class="built_in">NewErrorIterator</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">Table::NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NewTwoLevelIterator</span>(</span><br><span class="line">      rep_-&gt;index_block-&gt;<span class="built_in">NewIterator</span>(rep_-&gt;options.comparator),</span><br><span class="line">      &amp;Table::BlockReader, <span class="keyword">const_cast</span>&lt;Table*&gt;(<span class="keyword">this</span>), options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Table::NewIterator</code> 中会构造一个二级迭代器，第一级自然是 <code>index_block</code> 的迭代器，并且提供了第二级迭代器的创建函数 <code>Table::BlockReader</code>。该函数的第一个参数实际上为 <code>Table</code> 对象的指针，第三个参数是 <code>index_block</code> 键值对中的 <code>Value</code>，也就是对应的 Data Block Handle。如果不考虑缓存部分，代码还是很容易理解的：首先解析对应的 <code>BlockHandle</code>，据此读取 <code>block</code>，创建迭代器并且注册迭代器清理函数 <code>DeleteBlock</code>，当删除迭代器时删除对应的 <code>block</code>。当考虑缓存时，可以回忆下系列第一篇介绍的 <code>LRUCache</code> 再来看代码：使用 <code>cache_id</code> 和 <code>handle.offset</code> 构建一个缓存的 <code>Key</code>，将 <code>block</code> 作为缓存的 <code>Value</code>，后者的清理函数为 <code>DeleteCachedBlock</code>；当前使用 <code>block</code> 创建迭代器增加了 <code>block</code> 的引用计数，当迭代器析构时需要调用 <code>ReleaseBlock</code> 以减少缓存的 <code>block</code> 的引用计数。这样就非常合理且高效了。</p>
<h3 id="7-Table-Cache"><a href="#7-Table-Cache" class="headerlink" title="7. Table Cache"></a>7. Table Cache</h3><p>LevelDB 中会使用 <code>file_number</code> 给 Sorted Table 编号。为了提高读取性能、简化使用，LevelDB 提供了 <code>TableCache</code> 用以缓存 Sorted Table 及对应的 <code>.ldb</code> 文件，定义于 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/db/table_cache.h"><code>db/table_cache.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableCache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TableCache</span>(<span class="keyword">const</span> std::string&amp; dbname, <span class="keyword">const</span> Options&amp; options, <span class="keyword">int</span> entries);</span><br><span class="line">  ~<span class="built_in">TableCache</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an iterator for the specified file number (the corresponding</span></span><br><span class="line">  <span class="comment">// file length must be exactly &quot;file_size&quot; bytes).  If &quot;tableptr&quot; is</span></span><br><span class="line">  <span class="comment">// non-null, also sets &quot;*tableptr&quot; to point to the Table object</span></span><br><span class="line">  <span class="comment">// underlying the returned iterator, or to nullptr if no Table object</span></span><br><span class="line">  <span class="comment">// underlies the returned iterator.  The returned &quot;*tableptr&quot; object is owned</span></span><br><span class="line">  <span class="comment">// by the cache and should not be deleted, and is valid for as long as the</span></span><br><span class="line">  <span class="comment">// returned iterator is live.</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">uint64_t</span> file_size, Table** tableptr = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a seek to internal key &quot;k&quot; in specified file finds an entry,</span></span><br><span class="line">  <span class="comment">// call (*handle_result)(arg, found_key, found_value).</span></span><br><span class="line">  <span class="function">Status <span class="title">Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">uint64_t</span> file_size, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;, <span class="keyword">const</span> Slice&amp;))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Evict any entry for the specified file number</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Evict</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">Status <span class="title">FindTable</span><span class="params">(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size, Cache::Handle**)</span></span>;</span><br><span class="line"></span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> std::string dbname_;</span><br><span class="line">  <span class="keyword">const</span> Options&amp; options_;</span><br><span class="line">  Cache* cache_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>核心接口 <code>TableCache::NewIterator</code>，只需要提供 <code>file_number</code> 和 <code>file_size</code>，就可以返回对应的 Sorted Table 对象及其迭代器。TableCache 封装了缓存和清理的逻辑，其实现也非常简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TableAndFile</span> &#123;</span></span><br><span class="line">  RandomAccessFile* file;</span><br><span class="line">  Table* table;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteEntry</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value)</span> </span>&#123;</span><br><span class="line">  TableAndFile* tf = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(value);</span><br><span class="line">  <span class="keyword">delete</span> tf-&gt;table;</span><br><span class="line">  <span class="keyword">delete</span> tf-&gt;file;</span><br><span class="line">  <span class="keyword">delete</span> tf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnrefEntry</span><span class="params">(<span class="keyword">void</span>* arg1, <span class="keyword">void</span>* arg2)</span> </span>&#123;</span><br><span class="line">  Cache* cache = <span class="keyword">reinterpret_cast</span>&lt;Cache*&gt;(arg1);</span><br><span class="line">  Cache::Handle* h = <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(arg2);</span><br><span class="line">  cache-&gt;<span class="built_in">Release</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TableCache::<span class="built_in">TableCache</span>(<span class="keyword">const</span> std::string&amp; dbname, <span class="keyword">const</span> Options&amp; options,</span><br><span class="line">                       <span class="keyword">int</span> entries)</span><br><span class="line">    : <span class="built_in">env_</span>(options.env),</span><br><span class="line">      <span class="built_in">dbname_</span>(dbname),</span><br><span class="line">      <span class="built_in">options_</span>(options),</span><br><span class="line">      <span class="built_in">cache_</span>(<span class="built_in">NewLRUCache</span>(entries)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">TableCache::~<span class="built_in">TableCache</span>() &#123; <span class="keyword">delete</span> cache_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TableCache::FindTable</span><span class="params">(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Cache::Handle** handle)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="built_in"><span class="keyword">sizeof</span></span>(file_number)];</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(buf, file_number);</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">(buf, <span class="keyword">sizeof</span>(buf))</span></span>;</span><br><span class="line">  *handle = cache_-&gt;<span class="built_in">Lookup</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (*handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    std::string fname = <span class="built_in">TableFileName</span>(dbname_, file_number);</span><br><span class="line">    RandomAccessFile* file = <span class="literal">nullptr</span>;</span><br><span class="line">    Table* table = <span class="literal">nullptr</span>;</span><br><span class="line">    s = env_-&gt;<span class="built_in">NewRandomAccessFile</span>(fname, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      std::string old_fname = <span class="built_in">SSTTableFileName</span>(dbname_, file_number);</span><br><span class="line">      <span class="keyword">if</span> (env_-&gt;<span class="built_in">NewRandomAccessFile</span>(old_fname, &amp;file).<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        s = Status::<span class="built_in">OK</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = Table::<span class="built_in">Open</span>(options_, file, file_size, &amp;table);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(table == <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">delete</span> file;</span><br><span class="line">      <span class="comment">// We do not cache error results so that if the error is transient,</span></span><br><span class="line">      <span class="comment">// or somebody repairs the file, we recover automatically.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TableAndFile* tf = <span class="keyword">new</span> TableAndFile;</span><br><span class="line">      tf-&gt;file = file;</span><br><span class="line">      tf-&gt;table = table;</span><br><span class="line">      *handle = cache_-&gt;<span class="built_in">Insert</span>(key, tf, <span class="number">1</span>, &amp;DeleteEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">TableCache::NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Table** tableptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *tableptr = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  Status s = <span class="built_in">FindTable</span>(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NewErrorIterator</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;<span class="built_in">Value</span>(handle))-&gt;table;</span><br><span class="line">  Iterator* result = table-&gt;<span class="built_in">NewIterator</span>(options);</span><br><span class="line">  result-&gt;<span class="built_in">RegisterCleanup</span>(&amp;UnrefEntry, cache_, handle);</span><br><span class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *tableptr = table;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TableCache::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">uint64_t</span> file_size, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="keyword">const</span> Slice&amp;))</span> </span>&#123;</span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  Status s = <span class="built_in">FindTable</span>(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    Table* t = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;<span class="built_in">Value</span>(handle))-&gt;table;</span><br><span class="line">    s = t-&gt;<span class="built_in">InternalGet</span>(options, k, arg, handle_result);</span><br><span class="line">    cache_-&gt;<span class="built_in">Release</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableCache::Evict</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="built_in"><span class="keyword">sizeof</span></span>(file_number)];</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(buf, file_number);</span><br><span class="line">  cache_-&gt;<span class="built_in">Erase</span>(<span class="built_in">Slice</span>(buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TableCache::FindTable</code> 中会根据 <code>file_number</code> 构建缓存的 Key，首先尝试在缓存中查找，如果找不到则手动的打开文件、构造 Table。对应迭代器的实现也很简单，只需要设定好对应的清理函数 <code>DeleteEntry</code> 和 <code>UnrefEntry</code>，就可以放心使用了。每多加一层封装，就多屏蔽一分底层实现的细节，对使用者来说就更易用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前后两篇完成了对 Sorted Table 代码的阅读和分析。当数据位于内存时，查找过程中随机访问的时间微乎其微；但当数据保存到硬盘后，将 Sorted Table 载入内存的 IO 时间就非常可观了。Sorted Table 使用多级迭代器来缓和这个问题，首先完整地读取了 Index Block 到内存中；进行查找时首先在 Index Block 上二分，确定 Data Block 的位置后再进行必要的 IO 读取，并且通过缓存 Data Block 的方式提升读取的性能。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://gasolly.github.io/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%947.Sorted%20String%20Table%E7%BB%AD/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LevelDB/" rel="tag">LevelDB</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%948.%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            LevelDB源码分析——8.版本管理
          
        </div>
      </a>
    
    
      <a href="/2022/02/10/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%946.Sorted%20String%20Table/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">LevelDB源码分析——6.Sorted String Table</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "NSGUA2zFQlabQAWLXHM8G89r-MdYXbMMI",
    app_key: "dxEn5Cz3tIz4zHFNpVdfQWgB",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2022
        <i class="ri-heart-fill heart_icon"></i> Xufei Pan
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://v1.cnzz.com/z_stat.php?id=1280023895&amp;web_id=1280023895'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Gasol"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">目录</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/photos/">图片</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2021/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯奶茶吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
</body>

</html>