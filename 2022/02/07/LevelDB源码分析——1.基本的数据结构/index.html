<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>LevelDB源码分析——1.基本的数据结构 |  Gasol</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
    <link rel="alternate" href="/atom.xml" title="Gasol" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-LevelDB源码分析——1.基本的数据结构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  LevelDB源码分析——1.基本的数据结构
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2022-02-07T04:08:41.000Z" itemprop="datePublished">2022-02-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/LevelDB/">LevelDB</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">5.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">26 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一．基本的数据结构"><a href="#一．基本的数据结构" class="headerlink" title="一．基本的数据结构"></a>一．基本的数据结构</h2><p>为了督促自己认真的阅读LevelDB源码，同时记录下相关的收获，避免阅后即忘，因此在Blog中记录下LevelDB源码分析的相关内容。</p>
<p>本文会介绍 LevelDB 中的基本数据结构，包括 <code>Slice</code>、<code>Hash</code>、<code>LRUCache</code>。</p>
<h3 id="1-字符串封装-Slice"><a href="#1-字符串封装-Slice" class="headerlink" title="1. 字符串封装 Slice"></a>1. 字符串封装 Slice</h3><p>Slice 定义于 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/include/leveldb/slice.h"><code>include/leveldb/slice.h</code></a>，源码不过百行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Slice is a simple structure containing a pointer into some external</span></span><br><span class="line"><span class="comment">// storage and a size.  The user of a Slice must ensure that the slice</span></span><br><span class="line"><span class="comment">// is not used after the corresponding external storage has been</span></span><br><span class="line"><span class="comment">// deallocated.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Multiple threads can invoke const methods on a Slice without</span></span><br><span class="line"><span class="comment">// external synchronization, but if any of the threads may call a</span></span><br><span class="line"><span class="comment">// non-const method, all threads accessing the same Slice must use</span></span><br><span class="line"><span class="comment">// external synchronization.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STORAGE_LEVELDB_INCLUDE_SLICE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORAGE_LEVELDB_INCLUDE_SLICE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/export.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"><span class="comment">//字符串处理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Slice</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create an empty slice.</span></span><br><span class="line">  <span class="built_in">Slice</span>() : <span class="built_in">data_</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">size_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to d[0,n-1].</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> <span class="keyword">char</span>* d, <span class="keyword">size_t</span> n) : <span class="built_in">data_</span>(d), <span class="built_in">size_</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to the contents of &quot;s&quot;</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> std::string&amp; s) : <span class="built_in">data_</span>(s.<span class="built_in">data</span>()), <span class="built_in">size_</span>(s.<span class="built_in">size</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to s[0,strlen(s)-1]</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s) : <span class="built_in">data_</span>(s), <span class="built_in">size_</span>(<span class="built_in">strlen</span>(s)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Intentionally copyable.</span></span><br><span class="line">  <span class="built_in">Slice</span>(<span class="keyword">const</span> Slice&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  Slice&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Slice&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a pointer to the beginning of the referenced data</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the length (in bytes) of the referenced data</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true iff the length of the referenced data is zero</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_ == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the ith byte in the referenced data.</span></span><br><span class="line">  <span class="comment">// REQUIRES: n &lt; size()</span></span><br><span class="line">  <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &lt; <span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> data_[n];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Change this slice to refer to an empty array</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    size_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//移除数据的前n位</span></span><br><span class="line">  <span class="comment">// Drop the first &quot;n&quot; bytes from this slice.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove_prefix</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &lt;= <span class="built_in">size</span>());</span><br><span class="line">    data_ += n;</span><br><span class="line">    size_ -= n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a string that contains the copy of the referenced data.</span></span><br><span class="line">  <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">string</span>(data_, size_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Three-way comparison.  Returns value:</span></span><br><span class="line">  <span class="comment">//   &lt;  0 iff &quot;*this&quot; &lt;  &quot;b&quot;,</span></span><br><span class="line">  <span class="comment">//   == 0 iff &quot;*this&quot; == &quot;b&quot;,</span></span><br><span class="line">  <span class="comment">//   &gt;  0 iff &quot;*this&quot; &gt;  &quot;b&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//判断参数x是否是该slice的前缀</span></span><br><span class="line">  <span class="comment">// Return true iff &quot;x&quot; is a prefix of &quot;*this&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">starts_with</span><span class="params">(<span class="keyword">const</span> Slice&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((size_ &gt;= x.size_) &amp;&amp; (<span class="built_in">memcmp</span>(data_, x.data_, x.size_) == <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//成员变量：data_存储数据地址;size_记录数据长度</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;</span><br><span class="line">  <span class="keyword">size_t</span> size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">return</span></span> ((x.<span class="built_in">size</span>() == y.<span class="built_in">size</span>()) &amp;&amp;</span><br><span class="line">          (<span class="built_in">memcmp</span>(x.<span class="built_in">data</span>(), y.<span class="built_in">data</span>(), x.<span class="built_in">size</span>()) == <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123; <span class="keyword">return</span> !(x == y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Slice::compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> min_len = (size_ &lt; b.size_) ? size_ : b.size_;</span><br><span class="line">  <span class="keyword">int</span> r = <span class="built_in">memcmp</span>(data_, b.data_, min_len);</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size_ &lt; b.size_)</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_ &gt; b.size_)</span><br><span class="line">      r = +<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// STORAGE_LEVELDB_INCLUDE_SLICE_H_</span></span></span><br></pre></td></tr></table></figure>

<p>没有外部依赖，代码也非常清晰易懂。整个定义可以分为四个部分：构造、获取、修改和比较。</p>
<p><strong>构造</strong>：默认构造为空字符串，字符串构造提供了带长度和不带长度，并且支持默认的复制构造函数和赋值操作符（毕竟只有 <code>data_</code> 和 <code>size_</code> 两个属性）。</p>
<p><strong>获取</strong>：获取 <code>Slice</code> 的基本信息，支持导出为 <code>std::string</code>。</p>
<p><strong>修改</strong>：支持 <code>clear</code> 操作字符串清空，也支持 <code>remove_prefix</code> 将指定长度的前缀去除。注意 <code>data_</code> 的类型为 <code>const char *</code>，对应的字符串内容是不可修改的，<code>Slice</code> 只能修改字符串的起始位置。</p>
<p><strong>比较</strong>：<code>Slice::compare</code> 实现了非常严谨的字符串比较，返回 0/1/-1。注意为了提高性能，<code>operator==</code> 并没有直接调用 <code>Slice::compare</code>。</p>
<p>值得注意的是，<code>Slice</code> 本身并没有任何内存管理，仅仅是 C 风格字符串及其长度的封装。</p>
<h3 id="2-哈希函数-Hash"><a href="#2-哈希函数-Hash" class="headerlink" title="2. 哈希函数 Hash"></a>2. 哈希函数 Hash</h3><p>哈希函数定义于 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/util/hash.cc"><code>util/hash.[h/cc]</code></a>，源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/hash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;util/coding.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The FALLTHROUGH_INTENDED macro can be used to annotate implicit fall-through</span></span><br><span class="line"><span class="comment">// between switch labels. The real definition should be provided externally.</span></span><br><span class="line"><span class="comment">// This one is a fallback version for unsupported compilers.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FALLTHROUGH_INTENDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALLTHROUGH_INTENDED \</span></span><br><span class="line"><span class="meta">  do &#123;                       \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次按照四字节长度读取字节流中的数据 w，并使用普通的哈希函数计算哈希值。</span></span><br><span class="line"><span class="comment"> * 计算过程中使用 uint32_t 的自然溢出特性。四字节读取则为了加速，最终可能剩下 3/2/1 个多余的字节，</span></span><br><span class="line"><span class="comment"> * 使用 switch 语句补充计算，以实现最好的性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> n, <span class="keyword">uint32_t</span> seed)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Similar to murmur hash</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> m = <span class="number">0xc6a4a793</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> r = <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* limit = data + n;</span><br><span class="line">  <span class="keyword">uint32_t</span> h = seed ^ (n * m);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick up four bytes at a time</span></span><br><span class="line">  <span class="keyword">while</span> (data + <span class="number">4</span> &lt;= limit) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> w = <span class="built_in">DecodeFixed32</span>(data);</span><br><span class="line">    data += <span class="number">4</span>;</span><br><span class="line">    h += w;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= (h &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick up remaining bytes</span></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (limit - data) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">      FALLTHROUGH_INTENDED;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">      FALLTHROUGH_INTENDED;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">0</span>]);</span><br><span class="line">      h *= m;</span><br><span class="line">      h ^= (h &gt;&gt; r);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>

<p>每次按照四字节长度读取字节流中的数据 <code>w</code>，并使用普通的哈希函数计算哈希值。计算过程中使用 <code>uint32_t</code> 的自然溢出特性。四字节读取则为了加速，最终可能剩下 3/2/1 个多余的字节，使用 <code>switch</code> 语句补充计算，以实现最好的性能。</p>
<p>这里 <code>FALLTHROUGH_INTENDED</code> 宏并无实际作用，仅仅作为一种“我确定我这里想跳过”的标志。<code>do &#123;&#125; while(0)</code> 对代码无影响，这种写法也会出现在一些多行的宏定义里（见<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/257418/do-while-0-what-is-it-good-for">链接</a>）。</p>
<p>LevelDB 中哈希表和布隆过滤器会使用到该哈希函数。</p>
<h3 id="3-缓存-LRUCache"><a href="#3-缓存-LRUCache" class="headerlink" title="3. 缓存 LRUCache"></a>3. 缓存 LRUCache</h3><p>LevelDB 中使用的是 Least Recently Used Cache，即最近最少使用缓存。缓存接口定义于 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/include/leveldb/cache.h"><code>include/leveldb/cache.h</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Cache is an interface that maps keys to values.  It has internal</span></span><br><span class="line"><span class="comment">// synchronization and may be safely accessed concurrently from</span></span><br><span class="line"><span class="comment">// multiple threads.  It may automatically evict entries to make room</span></span><br><span class="line"><span class="comment">// for new entries.  Values have a specified charge against the cache</span></span><br><span class="line"><span class="comment">// capacity.  For example, a cache where the values are variable</span></span><br><span class="line"><span class="comment">// length strings, may use the length of the string as the charge for</span></span><br><span class="line"><span class="comment">// the string.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A builtin cache implementation with a least-recently-used eviction</span></span><br><span class="line"><span class="comment">// policy is provided.  Clients may use their own implementations if</span></span><br><span class="line"><span class="comment">// they want something more sophisticated (like scan-resistance, a</span></span><br><span class="line"><span class="comment">// custom eviction policy, variable cache sizing, etc.)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STORAGE_LEVELDB_INCLUDE_CACHE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORAGE_LEVELDB_INCLUDE_CACHE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/export.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/slice.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//仅依赖Slice</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Cache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new cache with a fixed size capacity.  This implementation</span></span><br><span class="line"><span class="comment">// of Cache uses a least-recently-used eviction policy.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认采用LRU替换策略</span></span><br><span class="line"><span class="function">LEVELDB_EXPORT Cache* <span class="title">NewLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Cache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cache</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//=delete表示编译器不生成默认构造函数。作用是，避免以下2个函数被调用，避免拷贝</span></span><br><span class="line">  <span class="built_in">Cache</span>(<span class="keyword">const</span> Cache&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Cache&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Cache&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Destroys all existing entries by calling the &quot;deleter&quot;</span></span><br><span class="line">  <span class="comment">// function that was passed to the constructor.</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Cache</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Opaque handle to an entry stored in the cache.</span></span><br><span class="line">  <span class="comment">//定义的 Handle 仅作为指针类型使用，实际上使用 void * 也并无区别，Handle 增加语意而已</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Handle</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert a mapping from key-&gt;value into the cache and assign it</span></span><br><span class="line">  <span class="comment">// the specified charge against the total cache capacity.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Returns a handle that corresponds to the mapping.  The caller</span></span><br><span class="line">  <span class="comment">// must call this-&gt;Release(handle) when the returned mapping is no</span></span><br><span class="line">  <span class="comment">// longer needed.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// When the inserted entry is no longer needed, the key and</span></span><br><span class="line">  <span class="comment">// value will be passed to &quot;deleter&quot;.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the cache has no mapping for &quot;key&quot;, returns nullptr.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Else return a handle that corresponds to the mapping.  The caller</span></span><br><span class="line">  <span class="comment">// must call this-&gt;Release(handle) when the returned mapping is no</span></span><br><span class="line">  <span class="comment">// longer needed.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release a mapping returned by a previous Lookup().</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must not have been released yet.</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must have been returned by a method on *this.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Release</span><span class="params">(Handle* handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the value encapsulated in a handle returned by a</span></span><br><span class="line">  <span class="comment">// successful Lookup().</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must not have been released yet.</span></span><br><span class="line">  <span class="comment">// REQUIRES: handle must have been returned by a method on *this.</span></span><br><span class="line">  <span class="comment">// 获取lookup()操作成功返回的Handle指向的表项中的Value</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">Value</span><span class="params">(Handle* handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the cache contains entry for key, erase it.  Note that the</span></span><br><span class="line">  <span class="comment">// underlying entry will be kept around until all existing handles</span></span><br><span class="line">  <span class="comment">// to it have been released.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a new numeric id.  May be used by multiple clients who are</span></span><br><span class="line">  <span class="comment">// sharing the same cache to partition the key space.  Typically the</span></span><br><span class="line">  <span class="comment">// client will allocate a new id at startup and prepend the id to</span></span><br><span class="line">  <span class="comment">// its cache keys.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span> <span class="title">NewId</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove all cache entries that are not actively in use.  Memory-constrained</span></span><br><span class="line">  <span class="comment">// applications may wish to call this method to reduce memory usage.</span></span><br><span class="line">  <span class="comment">// Default implementation of Prune() does nothing.  Subclasses are strongly</span></span><br><span class="line">  <span class="comment">// encouraged to override the default implementation.  A future release of</span></span><br><span class="line">  <span class="comment">// leveldb may change Prune() to a pure abstract method.</span></span><br><span class="line">  <span class="comment">// 修建所有不活跃的表项。适合对内存有限制的应用</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an estimate of the combined charges of all elements stored in the</span></span><br><span class="line">  <span class="comment">// cache.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// STORAGE_LEVELDB_INCLUDE_CACHE_H_</span></span></span><br></pre></td></tr></table></figure>

<p>接口仅依赖 <code>Slice</code>，接口也很容易看懂。<code>Cache</code> 中定义的 <code>Handle</code> 仅作为指针类型使用，实际上使用 <code>void *</code> 也并无区别，<code>Handle</code> 增加语意而已。</p>
<p><code>NewLRUCache</code> 作为工厂函数，可以生产一个 <code>LRUCache</code>，其定义于 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/util/cache.cc"><code>util/cache.cc</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cache* <span class="title">NewLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ShardedLRUCache</span>(capacity); &#125;</span><br></pre></td></tr></table></figure>

<p><code>LRUCahce</code> 的实现依靠双向环形链表和哈希表。其中双向环形链表维护 <code>Recently</code> 属性，哈希表维护 <code>Used</code> 属性。双向环形链表和哈希表的节点信息都存储于 <code>LRUHandle</code> 结构中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUHandle</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>* value;</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*deleter)(<span class="keyword">const</span> Slice&amp;, <span class="keyword">void</span>* value);</span><br><span class="line">  LRUHandle* next_hash;</span><br><span class="line">  LRUHandle* next;</span><br><span class="line">  LRUHandle* prev;</span><br><span class="line">  <span class="keyword">size_t</span> charge;  <span class="comment">// TODO(opt): Only allow uint32_t?</span></span><br><span class="line">  <span class="keyword">size_t</span> key_length;</span><br><span class="line">  <span class="keyword">bool</span> in_cache;     <span class="comment">// Whether entry is in the cache.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> refs;     <span class="comment">// References, including cache reference, if present.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hash;     <span class="comment">// Hash of key(); used for fast sharding and comparisons</span></span><br><span class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next_ is only equal to this if the LRU handle is the list head of an</span></span><br><span class="line">    <span class="comment">// empty list. List heads never have meaningful keys.</span></span><br><span class="line">    <span class="built_in">assert</span>(next != <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>依次解释每一项属性：</p>
<ol>
<li><code>value</code> 为缓存存储的数据，类型无关；</li>
<li><code>deleter</code> 为键值对的析构函数指针；</li>
<li><code>next_hash</code> 为开放式哈希表中同一个桶下存储链表时使用的指针；</li>
<li><code>next</code> 和 <code>prev</code> 自然是双向环形链接的前后指针；</li>
<li><code>charge</code> 为当前节点的缓存费用，比如一个字符串的费用可能就是它的长度；</li>
<li><code>key_length</code> 为 <code>key</code> 的长度；</li>
<li><code>in_cache</code> 为节点是否在缓存里的标志；</li>
<li><code>refs</code> 为引用计数，当计数为 0 时则可以用 <code>deleter</code> 清理掉；</li>
<li><code>hash</code> 为 <code>key</code> 的哈希值；</li>
<li><code>key_data</code> 为变长的 <code>key</code> 数据，最小长度为 1，<code>malloc</code> 时动态指定长度。</li>
</ol>
<p>接着看哈希表的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">HandleTable</span>() : <span class="built_in">length_</span>(<span class="number">0</span>), <span class="built_in">elems_</span>(<span class="number">0</span>), <span class="built_in">list_</span>(<span class="literal">nullptr</span>) &#123; <span class="built_in">Resize</span>(); &#125;</span><br><span class="line">  ~<span class="built_in">HandleTable</span>() &#123; <span class="keyword">delete</span>[] list_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = <span class="built_in">FindPointer</span>(h-&gt;<span class="built_in">key</span>(), h-&gt;hash);</span><br><span class="line">    LRUHandle* old = *ptr;</span><br><span class="line">    h-&gt;next_hash = (old == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;next_hash);</span><br><span class="line">    *ptr = h;</span><br><span class="line">    <span class="keyword">if</span> (old == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      ++elems_;</span><br><span class="line">      <span class="keyword">if</span> (elems_ &gt; length_) &#123;</span><br><span class="line">        <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">        <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">        <span class="built_in">Resize</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = <span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">    LRUHandle* result = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      *ptr = result-&gt;next_hash;</span><br><span class="line">      --elems_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The table consists of an array of buckets where each bucket is</span></span><br><span class="line">  <span class="comment">// a linked list of cache entries that hash into the bucket.</span></span><br><span class="line">  <span class="comment">// 这个表由一个存储桶数组组成，每个存储桶是一个散列到存储桶中的缓存条目的链表。</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length_;   <span class="comment">//存储桶的数量</span></span><br><span class="line">  <span class="keyword">uint32_t</span> elems_;    <span class="comment">//当前哈希表的实际元素个数</span></span><br><span class="line">  LRUHandle** list_;  <span class="comment">//桶数组。实际存储的数据内容，底层结构</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a pointer to slot that points to a cache entry that</span></span><br><span class="line">  <span class="comment">// matches key/hash.  If there is no such cache entry, return a</span></span><br><span class="line">  <span class="comment">// pointer to the trailing slot in the corresponding linked list.</span></span><br><span class="line">  <span class="comment">// 根据指定的key与hash，返回对应的双重指针。</span></span><br><span class="line">  <span class="comment">// (先根据Hash值与存储桶数目length_，找到list_中对应的桶，然后再根据hash与key寻找，避免hash冲突)</span></span><br><span class="line">  <span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="literal">nullptr</span> &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;<span class="built_in">key</span>())) &#123;</span><br><span class="line">      ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Resize 则根据存储的节点数，对哈希表进行缩放。</span></span><br><span class="line"><span class="comment">   * 如果不缩放，这样的结构会退化到链表的复杂度。</span></span><br><span class="line"><span class="comment">   * 使用 2 的幂可以规避掉哈希值的模除，同样可以加速。</span></span><br><span class="line"><span class="comment">   * Resize时会遍历节点，将其从原位置取出，重新计算哈希值放到新位置，</span></span><br><span class="line"><span class="comment">   * 每次会加到桶中链表的头部。Resize 过程中链表需要拒绝其他请求。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 值得注意的是：新的桶的数目（新的length_）是根据 现有的存储的实际数据的个数 来决定的。</span></span><br><span class="line"><span class="comment">   * 使得new_length &gt;= 实际元素个数。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> new_length = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (new_length &lt; elems_) &#123;</span><br><span class="line">      new_length *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LRUHandle** new_list = <span class="keyword">new</span> LRUHandle*[new_length];</span><br><span class="line">    <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) &#123;</span><br><span class="line">      LRUHandle* h = list_[i];</span><br><span class="line">      <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        LRUHandle* next = h-&gt;next_hash;</span><br><span class="line">        <span class="keyword">uint32_t</span> hash = h-&gt;hash;</span><br><span class="line">        LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)];</span><br><span class="line">        h-&gt;next_hash = *ptr;</span><br><span class="line">        *ptr = h;</span><br><span class="line">        h = next;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(elems_ == count);</span><br><span class="line">    <span class="keyword">delete</span>[] list_;</span><br><span class="line">    list_ = new_list;</span><br><span class="line">    length_ = new_length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个标准的开放式哈希实现。属性中 <code>length_</code> 存储桶的数量，<code>elems_</code> 存储哈希表中节点数，<code>list_</code> 则为桶数组。每一个桶里存储 <code>hash</code> 值相同的一系列节点，这些节点构成一个链表，通过 <code>next_hash</code> 属性连接。</p>
<p><code>FindPointer</code> 函数返回一个二级指针。无论是 <code>list_[i]</code> 还是 <code>entry-&gt;next_hash</code>，均为 <code>LRUHandle *</code>，那么一个节点总会有一个正确的 <code>LRUHandle *</code> 变量指向它，该函数就返回这个变量的指针。说起来有点绕，仔细看懂就好。</p>
<p>看懂后，理解 <code>Insert</code> 和 <code>Remove</code> 都不难。<code>Resize</code> 则根据存储的节点数，对哈希表进行缩放。如果不缩放，这样的结构会退化到链表的复杂度。使用 2 的幂可以规避掉哈希值的模除，同样可以加速。<code>Resize</code> 时会遍历每一个节点，将其从原位置取出，重新计算哈希值放到新位置，每次会加到桶中链表的头部。<code>Resize</code> 过程中链表需要拒绝其他请求。</p>
<p>最后看 <code>LRUCache</code> 的实现就很简单了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A single shard of sharded cache.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LRUCache</span>();</span><br><span class="line">  ~<span class="built_in">LRUCache</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Separate from constructor so caller can easily make an array of LRUCache</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetCapacity</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> </span>&#123; capacity_ = capacity; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Like Cache methods, but with an extra &quot;hash&quot; parameter.</span></span><br><span class="line">  <span class="function">Cache::Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span></span>;</span><br><span class="line">  <span class="function">Cache::Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Cache::Handle* handle)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> usage_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Remove</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Append</span><span class="params">(LRUHandle* list, LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">FinishErase</span><span class="params">(LRUHandle* e)</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialized before use.</span></span><br><span class="line">  <span class="comment">// 初始化的容量</span></span><br><span class="line">  <span class="keyword">size_t</span> capacity_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mutex_ protects the following state.</span></span><br><span class="line">  <span class="comment">// 锁,用来保护下列的状态</span></span><br><span class="line">  <span class="keyword">mutable</span> port::Mutex mutex_;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> usage_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * LRUCache 中存储了两条链表，lru_ 和 in_use_，</span></span><br><span class="line"><span class="comment">   * 分别记录普通节点和外部正在使用中的节点。外部正在使用中的节点是不可删除的，</span></span><br><span class="line"><span class="comment">   * 将二者区分开也方便做对应的清理。Ref 和 Unref 分别增删引用计数，</span></span><br><span class="line"><span class="comment">   * 并完成节点在 lru_ 和 in_use_ 的交换，以及计数为 0 时做最后的删除。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 双向链表，会将最新使用的节点放到链表的末端。这样在容量超标时，</span></span><br><span class="line"><span class="comment">   * 删除链表头部的、长时间未用的节点即可。该逻辑实现于 Insert 函数的结尾。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dummy head of LRU list.</span></span><br><span class="line">  <span class="comment">// lru.prev is newest entry, lru.next is oldest entry.</span></span><br><span class="line">  <span class="comment">// Entries have refs==1 and in_cache==true.</span></span><br><span class="line">  <span class="function">LRUHandle lru_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dummy head of in-use list.</span></span><br><span class="line">  <span class="comment">// Entries are in use by clients, and have refs &gt;= 2 and in_cache==true.</span></span><br><span class="line">  <span class="function">LRUHandle in_use_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">HandleTable table_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache::<span class="built_in">LRUCache</span>() : <span class="built_in">capacity_</span>(<span class="number">0</span>), <span class="built_in">usage_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Make empty circular linked lists.</span></span><br><span class="line">  lru_.next = &amp;lru_;</span><br><span class="line">  lru_.prev = &amp;lru_;</span><br><span class="line">  in_use_.next = &amp;in_use_;</span><br><span class="line">  in_use_.prev = &amp;in_use_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRUCache::~<span class="built_in">LRUCache</span>() &#123;</span><br><span class="line">  <span class="built_in">assert</span>(in_use_.next == &amp;in_use_);  <span class="comment">// Error if caller has an unreleased handle</span></span><br><span class="line">  <span class="keyword">for</span> (LRUHandle* e = lru_.next; e != &amp;lru_;) &#123;</span><br><span class="line">    LRUHandle* next = e-&gt;next;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;in_cache);</span><br><span class="line">    e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;refs == <span class="number">1</span>);  <span class="comment">// Invariant of lru_ list.</span></span><br><span class="line">    <span class="built_in">Unref</span>(e);</span><br><span class="line">    e = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加引用计数。</span></span><br><span class="line"><span class="comment">// 若引用计数为1且in_cache==true，则将其从原链表中移除，添加到in_use链表的末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Ref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">1</span> &amp;&amp; e-&gt;in_cache) &#123;  <span class="comment">// If on lru_ list, move to in_use_ list.</span></span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;in_use_, e);</span><br><span class="line">  &#125;</span><br><span class="line">  e-&gt;refs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少引用计数。</span></span><br><span class="line"><span class="comment">// 若减少后引用计数为0，则删除对应空间。否则，将其从原链表中移除，添加到lru_链表的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Unref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(e-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">  e-&gt;refs--;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">0</span>) &#123;  <span class="comment">// Deallocate.</span></span><br><span class="line">    <span class="built_in">assert</span>(!e-&gt;in_cache);</span><br><span class="line">    (*e-&gt;deleter)(e-&gt;<span class="built_in">key</span>(), e-&gt;value);</span><br><span class="line">    <span class="built_in">free</span>(e);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;in_cache &amp;&amp; e-&gt;refs == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// No longer in use; move to lru_ list.</span></span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;lru_, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Remove</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  e-&gt;next-&gt;prev = e-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Append</span><span class="params">(LRUHandle* list, LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make &quot;e&quot; newest entry by inserting just before *list</span></span><br><span class="line">  e-&gt;next = list;</span><br><span class="line">  e-&gt;prev = list-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e;</span><br><span class="line">  e-&gt;next-&gt;prev = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过HandleTable哈希表查询，并添加引用计数</span></span><br><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  LRUHandle* e = table_.<span class="built_in">Lookup</span>(key, hash);</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">Ref</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减少引用计数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Release</span><span class="params">(Cache::Handle* handle)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">Unref</span>(<span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">void</span>* value))</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  LRUHandle* e =</span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  e-&gt;deleter = deleter;</span><br><span class="line">  e-&gt;charge = charge;</span><br><span class="line">  e-&gt;key_length = key.<span class="built_in">size</span>();</span><br><span class="line">  e-&gt;hash = hash;</span><br><span class="line">  e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">  e-&gt;refs = <span class="number">1</span>;  <span class="comment">// for the returned handle.</span></span><br><span class="line">  std::<span class="built_in">memcpy</span>(e-&gt;key_data, key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (capacity_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    e-&gt;refs++;  <span class="comment">// for the cache&#x27;s reference.</span></span><br><span class="line">    e-&gt;in_cache = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;in_use_, e);</span><br><span class="line">    usage_ += charge;</span><br><span class="line">    <span class="comment">//在哈希表HandleTable中插入新节点，同时在链表中删除 table_.Insert()返回的旧节点</span></span><br><span class="line">    <span class="built_in">FinishErase</span>(table_.<span class="built_in">Insert</span>(e));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// don&#x27;t cache. (capacity_==0 is supported and turns off caching.)</span></span><br><span class="line">    <span class="comment">// next is read by key() in an assert, so it must be initialized</span></span><br><span class="line">    e-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 双向链表，会将最新使用的节点放到链表的末端。</span></span><br><span class="line">  <span class="comment">// 这样在容量超标时，删除链表头部的、长时间未用的节点即可。</span></span><br><span class="line">  <span class="keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123;</span><br><span class="line">    LRUHandle* old = lru_.next;</span><br><span class="line">    <span class="built_in">assert</span>(old-&gt;refs == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//若容量超标，在哈希表与链表中都删除对应的节点</span></span><br><span class="line">    <span class="keyword">bool</span> erased = <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(old-&gt;<span class="built_in">key</span>(), old-&gt;hash));</span><br><span class="line">    <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">      <span class="built_in">assert</span>(erased);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If e != nullptr, finish removing *e from the cache; it has already been</span></span><br><span class="line"><span class="comment">// removed from the hash table.  Return whether e != nullptr.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LRUCache::FinishErase</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;in_cache);</span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">    usage_ -= e-&gt;charge;</span><br><span class="line">    <span class="built_in">Unref</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> e != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(key, hash));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Prune</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (lru_.next != &amp;lru_) &#123;</span><br><span class="line">    LRUHandle* e = lru_.next;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;refs == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> erased = <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(e-&gt;<span class="built_in">key</span>(), e-&gt;hash));</span><br><span class="line">    <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">      <span class="built_in">assert</span>(erased);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LRUCache</code> 中存储了两条链表，<code>lru_</code> 和 <code>in_use_</code>，分别记录普通节点和外部正在使用中的节点。外部正在使用中的节点是不可删除的，将二者区分开也方便做对应的清理。<code>Ref</code> 和 <code>Unref</code> 分别增删引用计数，并完成节点在 <code>lru_</code> 和 <code>in_use_</code> 的交换，以及计数为 0 时做最后的删除。</p>
<p>双向链表，会将最新使用的节点放到链表的末端。这样在容量超标时，删除链表头部的、长时间未用的节点即可。该逻辑实现于 <code>Insert</code> 函数的结尾。</p>
<p><code>LRUCache</code> 中在添删查操作中均使用互斥锁完成额外同步。<code>LevelDB</code> 中的锁将在后续文章中详细介绍。</p>
<p>最后看分片 <code>ShardedLRUCache</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShardBits = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShards = <span class="number">1</span> &lt;&lt; kNumShardBits;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分片LRUCache</span></span><br><span class="line"><span class="comment">// LevelDB 默认将 LRUCache 分为2^4块，取哈希值的高 4 位作为分片的位置。</span></span><br><span class="line"><span class="comment">// 分片可以提高查询和插入的速度，减少锁的压力，是提高缓存性能的常用方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//LRUCache的数组，包含2^4=16个LRUCache</span></span><br><span class="line">  LRUCache shard_[kNumShards];</span><br><span class="line">  port::Mutex id_mutex_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_id_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对Slice进行Hash操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">HashSlice</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Hash</span>(s.<span class="built_in">data</span>(), s.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对hash值进行右移，仅保留高4位作为分片的位置</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">Shard</span><span class="params">(<span class="keyword">uint32_t</span> hash)</span> </span>&#123; <span class="keyword">return</span> hash &gt;&gt; (<span class="number">32</span> - kNumShardBits); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ShardedLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> : last_id_(<span class="number">0</span>) &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> per_shard = (capacity + (kNumShards - <span class="number">1</span>)) / kNumShards;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].<span class="built_in">SetCapacity</span>(per_shard);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">ShardedLRUCache</span>() <span class="keyword">override</span> &#123;&#125;</span><br><span class="line">  <span class="function">Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">    <span class="keyword">return</span> shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Insert</span>(key, hash, value, charge, deleter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">    <span class="keyword">return</span> shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Lookup</span>(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Handle* handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    LRUHandle* h = <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle);</span><br><span class="line">    shard_[<span class="built_in">Shard</span>(h-&gt;hash)].<span class="built_in">Release</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">    shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Erase</span>(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">Value</span><span class="params">(Handle* handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle)-&gt;value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">NewId</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;id_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ++(last_id_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].<span class="built_in">Prune</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      total += shard_[s].<span class="built_in">TotalCharge</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>LevelDB</code> 默认将 <code>LRUCache</code> 分为 2^424 块，取哈希值的高 4 位作为分片的位置。分片可以提高查询和插入的速度，减少锁的压力，是提高缓存性能的常用方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文简单介绍了 <code>LevelDB</code> 中的 <code>Slice</code>、<code>Hash</code> 和 <code>LRUCache</code> 的实现。慢慢会觉得代码中的每个细节都是有意义的，不可忽略。<code>LevelDB</code> 源代码不超过 2万行，非常推荐学习 C++ 的同学阅读。建议可以先读 <code>util</code> 部分，这里是通用的数据结构，没有太多依赖。</p>
<p>下一篇会继续介绍 <code>LevelDB</code> 中的其他数据结构，包括布隆过滤器、内存池和跳表。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://gasolly.github.io/2022/02/07/LevelDB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941.%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVStore/" rel="tag">KVStore</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LevelDB/" rel="tag">LevelDB</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2021/06/17/Virtual-OCSSD-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Virtual OCSSD 环境搭建</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "NSGUA2zFQlabQAWLXHM8G89r-MdYXbMMI",
    app_key: "dxEn5Cz3tIz4zHFNpVdfQWgB",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2022
        <i class="ri-heart-fill heart_icon"></i> Xufei Pan
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://v1.cnzz.com/z_stat.php?id=1280023895&amp;web_id=1280023895'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Gasol"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">目录</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/photos/">图片</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2021/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯奶茶吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
</body>

</html>